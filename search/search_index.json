{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome","text":"Program the world's first open-source, full-stack quantum computer.      <p>Note</p> <p>Welcome to the Open Quantum Design framework for programming quantum computers. This documentation is still under development, please feel to contribute! \u00a9 Open Quantum Design</p>"},{"location":"index.html#whats-here","title":"What's here","text":"<p>Open Quantum Design is a non-profit foundation supporting the development of full-stack, open-source quantum computers. OQD's current designs are based on laser-cooled trapped ion quantum computing hardware, including real-time control, backend and frontend software. This documentation covers the software components of the OQD stack, including the core programming interfaces, classical emulation backends, compiler infrastructure, and cloud server containers.</p>"},{"location":"index.html#the-stack","title":"The stack","text":"<p>OQD's quantum computer stack can be interfaced at different levels, including the digital layer, analog layer, and atomic layer. <pre><code>block-beta\n   columns 3\n\n   block:Interface\n       columns 1\n       InterfaceTitle(\"&lt;i&gt;&lt;b&gt;Interfaces&lt;/b&gt;&lt;i/&gt;\")\n       InterfaceDigital[\"&lt;b&gt;Digital Interface&lt;/b&gt;\\nQuantum circuits with discrete gates\"]\n       space\n       InterfaceAnalog[\"&lt;b&gt;Analog Interface&lt;/b&gt;\\n Continuous-time evolution with Hamiltonians\"]\n       space\n       InterfaceAtomic[\"&lt;b&gt;Atomic Interface&lt;/b&gt;\\nLight-matter interactions between lasers and ions\"]\n       space\n    end\n\n    block:IR\n       columns 1\n       IRTitle(\"&lt;i&gt;&lt;b&gt;IRs&lt;/b&gt;&lt;i/&gt;\")\n       IRDigital[\"Quantum circuit IR\\nopenQASM, LLVM+QIR\"]\n       space\n       IRAnalog[\"openQSIM\"]\n       space\n       IRAtomic[\"openAPL\"]\n       space\n    end\n\n    block:Emulator\n       columns 1\n       EmulatorsTitle(\"&lt;i&gt;&lt;b&gt;Classical Emulators&lt;/b&gt;&lt;i/&gt;\")\n\n       EmulatorDigital[\"Pennylane, Qiskit\"]\n       space\n       EmulatorAnalog[\"QuTiP, QuantumOptics.jl\"]\n       space\n       EmulatorAtomic[\"TrICal, QuantumIon.jl\"]\n       space\n    end\n\n    space\n    block:RealTime\n       columns 1\n       RealTimeTitle(\"&lt;i&gt;&lt;b&gt;Real-Time&lt;/b&gt;&lt;i/&gt;\")\n       space\n       RTSoftware[\"ARTIQ, DAX, OQDAX\"]\n       space\n       RTGateware[\"Sinara Real-Time Control\"]\n       space\n       RTHardware[\"Lasers, Modulators, Photodetection, Ion Trap\"]\n       space\n       RTApparatus[\"Trapped-Ion QPU (&lt;sup&gt;171&lt;/sup&gt;Yt&lt;sup&gt;+&lt;/sup&gt;, &lt;sup&gt;133&lt;/sup&gt;Ba&lt;sup&gt;+&lt;/sup&gt;)\"]\n       space\n    end\n    space\n\n   InterfaceDigital --&gt; IRDigital\n   InterfaceAnalog --&gt; IRAnalog\n   InterfaceAtomic --&gt; IRAtomic\n\n   IRDigital --&gt; IRAnalog\n   IRAnalog --&gt; IRAtomic\n\n   IRDigital --&gt; EmulatorDigital\n   IRAnalog --&gt; EmulatorAnalog\n   IRAtomic --&gt; EmulatorAtomic\n\n   IRAtomic --&gt; RealTimeTitle\n\n   RTSoftware --&gt; RTGateware\n   RTGateware --&gt; RTHardware\n   RTHardware --&gt; RTApparatus\n\n    classDef title fill:#d6d4d4,stroke:#333,color:#333;\n    classDef digital fill:#E7E08B,stroke:#333,color:#333;\n    classDef analog fill:#E4E9B2,stroke:#333,color:#333;\n    classDef atomic fill:#D2E4C4,stroke:#333,color:#333;\n    classDef realtime fill:#B5CBB7,stroke:#333,color:#333;\n\n    classDef highlight fill:#f2bbbb,stroke:#333,color:#333,stroke-dasharray: 5 5;\n\n    class InterfaceTitle,IRTitle,EmulatorsTitle,RealTimeTitle title\n    class InterfaceDigital,IRDigital,EmulatorDigital digital\n    class InterfaceAnalog,IRAnalog,EmulatorAnalog analog\n    class InterfaceAtomic,IRAtomic,EmulatorAtomic atomic\n    class RTSoftware,RTGateware,RTHardware,RTApparatus realtime</code></pre></p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<p>Here's a short example of how to use the analog interface to specify, serialize, and simulate an analog quantum program. We use a simple, single-qubit Rabi-flopping experiment as an example: <pre><code>from oqd_core.interface.analog.operator import PauliZ, PauliX\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\n\nX = PauliX()\nZ = PauliZ()\n\nHx = AnalogGate(hamiltonian=X)\n\ncircuit = AnalogCircuit()\ncircuit.evolve(duration=10, gate=Hx)\ncircuit.measure()\n\nargs = TaskArgsAnalog(\n  n_shots=100,\n  fock_cutoff=4,\n  metrics={\"Z\": Expectation(operator=Z)},\n  dt=1e-3,\n)\n\ntask = Task(program=circuit, args=args)\n\nbackend = QutipBackend()\nresults = backend.run(task=task)\n</code></pre></p>"},{"location":"about.html","title":"About","text":"<p>Open Quantum Design (OQD) is a non-profit organization. Our mission is to develop full-stack open-source quantum computer designs by fostering a collaborative community of diverse contributors from academia, industry, and government. OQD's current designs are based on laser-cooled trapped ion quantum computing hardware and software. The OQD intellectual property was developed by University of Waterloo Professors Crystal Senko, Rajibul Islam and Roger Melko, with physicists, engineers, and computer scientists working at the Institute for Quantum Computing and the Perimeter Institute Quantum Intelligence Lab.</p> <p>OQD\u2019s technology features novel and scalable approaches for the trapping, control, and read-out of ions. This includes a unique blade trap design, agile optical scheme for low crosstalk addressing of the ions, high-fidelity and all-to-all gate connectivity, and native support for mid-circuit measurements.</p> <p>All components of the stack will be open under an Apache 2.0 or similar license - from hardware designs and the middleware control stack, to the top level programming interfaces. OQD\u2019s vision is to be a global leader in open quantum technology, driving breakthroughs that revolutionize science, industry, and society, in order to improve the quality of life for future generations.</p>"},{"location":"about.html#why-open","title":"Why Open?","text":"<p>Open-source is more accessible and a proven environment for innovation. By sharing resources, knowledge, and designs, a global community of participants from diverse backgrounds can contribute to and accelerate the development of quantum technologies. OQD is building a collaborative community for technology co-creation, in order to democratize and accelerate the benefits of quantum computing technologies for all. Our purpose is to harness the potential of open quantum technology for the betterment of society, ensuring equitable access to its benefits, to foster an environment for innovation, and nurture the quantum workforce of the future.</p>"},{"location":"about.html#oqds-open-source-approach","title":"OQD\u2019s open-source approach:","text":"<ul> <li>Provides transparency and accessibility to software and hardware</li> <li>Deepens connections between academia, industry, and government through a collaborative sandbox with clear rules of engagement</li> <li>Builds trust through collective decision-making to the benefit of the ecosystem and technology</li> <li>Fosters collaboration on the hardest technical challenges</li> <li>Increases cost-efficiency through collaboration and standards development</li> <li>Attracts and mobilizes IP into the quantum ecosystem</li> <li>Fuels outreach and education to train the next generation of scientists and entrepreneurs</li> </ul> <p>Join the OQD community.</p>"},{"location":"get-started.html","title":"Installation","text":""},{"location":"get-started.html#installation","title":"Installation","text":"<p>To install, <pre><code>pip install git+https://github.com/OpenQuantumDesign/equilux.git\n</code></pre></p> <p>Or clone the repository locally and install with:</p> <pre><code>git clone https://github.com/OpenQuantumDesign/equilux\npip install .\n</code></pre>"},{"location":"get-started.html#documentation","title":"Documentation","text":"<p>Documentation is implemented with MkDocs and can be read from the docs folder.</p> <p>To install the dependencies for documentation, run:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre> <p>To deploy the documentation server locally:</p> <pre><code>cp -r examples/ docs/examples/\nmkdocs serve\n</code></pre>"},{"location":"examples/adiabatic_linear.html","title":"Linear time-dependence","text":"In\u00a0[1]: Copied! <pre>import itertools\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ\nfrom oqd_core.interface.math import MathStr\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import itertools import warnings  import matplotlib.pyplot as plt import numpy as np import seaborn as sns from oqd_analog_emulator.qutip_backend import QutipBackend from oqd_core.backend.metric import Expectation from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ from oqd_core.interface.math import MathStr  warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741\n</pre> X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741 In\u00a0[3]: Copied! <pre>Hxx = X @ X\nHz = I @ Z + Z @ I\n\nlinear = MathStr(string=\"0.05*t\")\n\nH = -(1 - linear) * Hz + -linear * Hxx\n\ngate = AnalogGate(hamiltonian=H)\n\nGxx = AnalogGate(hamiltonian=Hxx)\n</pre> Hxx = X @ X Hz = I @ Z + Z @ I  linear = MathStr(string=\"0.05*t\")  H = -(1 - linear) * Hz + -linear * Hxx  gate = AnalogGate(hamiltonian=H)  Gxx = AnalogGate(hamiltonian=Hxx) In\u00a0[4]: Copied! <pre>n = 2  # number of qubits\n\ncircuit = AnalogCircuit()\ncircuit.evolve(gate=gate, duration=20)\ncircuit.evolve(gate=Gxx, duration=10)\ncircuit.measure()\n</pre> n = 2  # number of qubits  circuit = AnalogCircuit() circuit.evolve(gate=gate, duration=20) circuit.evolve(gate=Gxx, duration=10) circuit.measure() In\u00a0[5]: Copied! <pre>args = TaskArgsAnalog(\n    n_shots=1000,\n    metrics={\n        \"Z\": Expectation(operator=0.5 * (I @ Z + Z @ I)),\n        \"XX\": Expectation(operator=X @ X),\n    },\n    dt=1e-2,\n)\n\ntask = Task(program=circuit, args=args)\n</pre> args = TaskArgsAnalog(     n_shots=1000,     metrics={         \"Z\": Expectation(operator=0.5 * (I @ Z + Z @ I)),         \"XX\": Expectation(operator=X @ X),     },     dt=1e-2, )  task = Task(program=circuit, args=args) In\u00a0[6]: Copied! <pre>backend = QutipBackend()\nresults = backend.run(task=task);\n</pre> backend = QutipBackend() results = backend.run(task=task); <pre>[1/1] Cythonizing qtcoeff_be2b8a7b080282c382b3bc365b5cd7.pyx\nrunning build_ext\nbuilding 'qtcoeff_be2b8a7b080282c382b3bc365b5cd7' extension\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\cl.exe\" /c /nologo /O2 /W3 /GL /DNDEBUG /MD -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\qutip\\core\\data -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\numpy\\core\\include -Id:\\work\\Projects\\equilux\\.venv\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\Include \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\VS\\include\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.22621.0\\ucrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\um\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\shared\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\winrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\cppwinrt\" /EHsc /Tpqtcoeff_be2b8a7b080282c382b3bc365b5cd7.cpp /Fobuild\\temp.win-amd64-cpython-312\\Release\\qtcoeff_be2b8a7b080282c382b3bc365b5cd7.obj\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\link.exe\" /nologo /INCREMENTAL:NO /LTCG /DLL /MANIFEST:EMBED,ID=2 /MANIFESTUAC:NO /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\PCbuild\\amd64 \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\lib\\x64\" \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\lib\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\lib\\10.0.22621.0\\ucrt\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\\\lib\\10.0.22621.0\\\\um\\x64\" /EXPORT:PyInit_qtcoeff_be2b8a7b080282c382b3bc365b5cd7 build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_be2b8a7b080282c382b3bc365b5cd7.obj /OUT:build\\lib.win-amd64-cpython-312\\qtcoeff_be2b8a7b080282c382b3bc365b5cd7.cp312-win_amd64.pyd /IMPLIB:build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_be2b8a7b080282c382b3bc365b5cd7.cp312-win_amd64.lib\ncopying build\\lib.win-amd64-cpython-312\\qtcoeff_be2b8a7b080282c382b3bc365b5cd7.cp312-win_amd64.pyd -&gt; \n</pre> In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"crest\", n_colors=4)\n\nfor k, (name, metric) in enumerate(results.metrics.items()):\n    ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\nax.set(xlabel=\"Time\", ylabel=\"Expectation Value\")\nax.legend();\n</pre> fig, ax = plt.subplots(1, 1, figsize=[6, 3]) colors = sns.color_palette(palette=\"crest\", n_colors=4)  for k, (name, metric) in enumerate(results.metrics.items()):     ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k]) ax.set(xlabel=\"Time\", ylabel=\"Expectation Value\") ax.legend(); In\u00a0[8]: Copied! <pre>fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])\n\nstate = np.array([basis.real + 1j * basis.imag for basis in results.state])\nbases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)]\ncounts = {basis: results.counts.get(basis, 0) for basis in bases}\n\nax = axs[0]\nax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0])\nax.set(ylabel=\"Probability\")\n\n\nax = axs[1]\nax.bar(x=bases, height=list(counts.values()), color=colors[1])\nax.set(ylabel=\"Count\")\n\n\nax = axs[2]\nax.bar(x=bases, height=state.real, color=colors[2])\nax.set(ylabel=\"Amplitude (real)\")\n\nax = axs[3]\nax.bar(x=bases, height=state.imag, color=colors[3])\nax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);\n</pre> fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])  state = np.array([basis.real + 1j * basis.imag for basis in results.state]) bases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)] counts = {basis: results.counts.get(basis, 0) for basis in bases}  ax = axs[0] ax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0]) ax.set(ylabel=\"Probability\")   ax = axs[1] ax.bar(x=bases, height=list(counts.values()), color=colors[1]) ax.set(ylabel=\"Count\")   ax = axs[2] ax.bar(x=bases, height=state.real, color=colors[2]) ax.set(ylabel=\"Amplitude (real)\")  ax = axs[3] ax.bar(x=bases, height=state.imag, color=colors[3]) ax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]); <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre>"},{"location":"examples/adiabatic_linear.html#linear-adiabatic-state-preparation","title":"Linear Adiabatic State Preparation\u00b6","text":"<p>Linear Adiabatic State Preparation is a quantum method that prepares a target state by slowly transforming an initial Hamiltonian into a final Hamiltonian. By starting in the ground state of an initial Hamiltonian and evolving gradually, the system ideally stays in the ground state, ultimately reaching the ground state of the target Hamiltonian. This method leverages the adiabatic theorem, which states that a quantum system will remain in its instantaneous ground state if the Hamiltonian changes slowly enough.</p> <p>In this example, the Hamiltonian $H(t)$ is a linear interpolation between two Hamiltonians:</p> <ol> <li>Initial Hamiltonian, $ H_z $: Encodes the starting state. Here, $ H_z = I \\otimes Z + Z \\otimes I $, which introduces interactions based on the $ Z $-basis of the qubits.</li> <li>Target Hamiltonian, $ H\\_{xx} $: Encodes the desired end state. Here, $ H\\_{xx} = X \\otimes X $, which induces transitions that align the final state along the $ X $-axis.</li> </ol> <p>The time-dependent Hamiltonian is given by:</p> <p>$$ H(t) = -(1 - \\text{linear}) \\cdot H_z - \\text{linear} \\cdot H_{xx} $$</p> <p>where $\\text{linear} = 0.05 \\cdot t$ provides a gradual increase over time. The <code>AnalogGate</code> with Hamiltonian $ H(t) $ simulates this gradual evolution.</p> <p>In this setup, we prepare a two-qubit system with <code>AnalogCircuit</code>, evolving it first under the time-dependent Hamiltonian $ H(t) $ over 20 units of time, and then under $ H*{xx} $ for an additional 10 units. The final <code>measure()</code> captures the state, which ideally approximates the ground state of $ H*{xx} $, aligning with the target configuration.</p>"},{"location":"examples/adiabatic_sigmoid.html","title":"Sigmoid time-dependence","text":"In\u00a0[1]: Copied! <pre>import itertools\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ\nfrom oqd_core.interface.math import MathStr\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import itertools import warnings  import matplotlib.pyplot as plt import numpy as np import seaborn as sns from oqd_analog_emulator.qutip_backend import QutipBackend from oqd_core.backend.metric import Expectation from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ from oqd_core.interface.math import MathStr  warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741\n</pre> X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741 In\u00a0[3]: Copied! <pre>Hxx = X @ X\nHz = I @ Z + Z @ I\n\nsigmoid = MathStr(string=f\"1/(1+{np.e}**(-(0.5*(t-10))))\")\n\nH = -(1 - sigmoid) * Hz + -sigmoid * Hxx\n\ngate = AnalogGate(hamiltonian=H)\n</pre> Hxx = X @ X Hz = I @ Z + Z @ I  sigmoid = MathStr(string=f\"1/(1+{np.e}**(-(0.5*(t-10))))\")  H = -(1 - sigmoid) * Hz + -sigmoid * Hxx  gate = AnalogGate(hamiltonian=H) In\u00a0[4]: Copied! <pre>n = 2  # number of qubits\ncircuit = AnalogCircuit()\ncircuit.evolve(gate=gate, duration=30)\ncircuit.measure()\n</pre> n = 2  # number of qubits circuit = AnalogCircuit() circuit.evolve(gate=gate, duration=30) circuit.measure() In\u00a0[5]: Copied! <pre>args = TaskArgsAnalog(\n    n_shots=100,\n    fock_cutoff=4,\n    metrics={\n        \"Z\": Expectation(operator=((I @ Z + Z @ I) * -0.5)),\n        \"XX\": Expectation(operator=(X @ X) * -1),\n    },\n    dt=1e-2,\n)\n\ntask = Task(program=circuit, args=args)\n</pre> args = TaskArgsAnalog(     n_shots=100,     fock_cutoff=4,     metrics={         \"Z\": Expectation(operator=((I @ Z + Z @ I) * -0.5)),         \"XX\": Expectation(operator=(X @ X) * -1),     },     dt=1e-2, )  task = Task(program=circuit, args=args) In\u00a0[6]: Copied! <pre>backend = QutipBackend()\nresults = backend.run(task=task)\n</pre> backend = QutipBackend() results = backend.run(task=task) <pre>[1/1] Cythonizing qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca.pyx\nrunning build_ext\nbuilding 'qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca' extension\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\cl.exe\" /c /nologo /O2 /W3 /GL /DNDEBUG /MD -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\qutip\\core\\data -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\numpy\\core\\include -Id:\\work\\Projects\\equilux\\.venv\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\Include \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\VS\\include\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.22621.0\\ucrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\um\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\shared\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\winrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\cppwinrt\" /EHsc /Tpqtcoeff_4c40d521ad5adc5cbe1184ce8eeeca.cpp /Fobuild\\temp.win-amd64-cpython-312\\Release\\qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca.obj\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\link.exe\" /nologo /INCREMENTAL:NO /LTCG /DLL /MANIFEST:EMBED,ID=2 /MANIFESTUAC:NO /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\PCbuild\\amd64 \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\lib\\x64\" \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\lib\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\lib\\10.0.22621.0\\ucrt\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\\\lib\\10.0.22621.0\\\\um\\x64\" /EXPORT:PyInit_qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca.obj /OUT:build\\lib.win-amd64-cpython-312\\qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca.cp312-win_amd64.pyd /IMPLIB:build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca.cp312-win_amd64.lib\ncopying build\\lib.win-amd64-cpython-312\\qtcoeff_4c40d521ad5adc5cbe1184ce8eeeca.cp312-win_amd64.pyd -&gt; \n[1/1] Cythonizing qtcoeff_48c14ae02a35a794064262699a8766.pyx\nrunning build_ext\nbuilding 'qtcoeff_48c14ae02a35a794064262699a8766' extension\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\cl.exe\" /c /nologo /O2 /W3 /GL /DNDEBUG /MD -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\qutip\\core\\data -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\numpy\\core\\include -Id:\\work\\Projects\\equilux\\.venv\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\Include \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\VS\\include\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.22621.0\\ucrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\um\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\shared\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\winrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\cppwinrt\" /EHsc /Tpqtcoeff_48c14ae02a35a794064262699a8766.cpp /Fobuild\\temp.win-amd64-cpython-312\\Release\\qtcoeff_48c14ae02a35a794064262699a8766.obj\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\link.exe\" /nologo /INCREMENTAL:NO /LTCG /DLL /MANIFEST:EMBED,ID=2 /MANIFESTUAC:NO /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\PCbuild\\amd64 \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\lib\\x64\" \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\lib\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\lib\\10.0.22621.0\\ucrt\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\\\lib\\10.0.22621.0\\\\um\\x64\" /EXPORT:PyInit_qtcoeff_48c14ae02a35a794064262699a8766 build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_48c14ae02a35a794064262699a8766.obj /OUT:build\\lib.win-amd64-cpython-312\\qtcoeff_48c14ae02a35a794064262699a8766.cp312-win_amd64.pyd /IMPLIB:build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_48c14ae02a35a794064262699a8766.cp312-win_amd64.lib\ncopying build\\lib.win-amd64-cpython-312\\qtcoeff_48c14ae02a35a794064262699a8766.cp312-win_amd64.pyd -&gt; \n</pre> In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"crest\", n_colors=4)\n\nfor k, (name, metric) in enumerate(results.metrics.items()):\n    ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\nax.legend();\n</pre> fig, ax = plt.subplots(1, 1, figsize=[6, 3]) colors = sns.color_palette(palette=\"crest\", n_colors=4)  for k, (name, metric) in enumerate(results.metrics.items()):     ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k]) ax.legend(); In\u00a0[8]: Copied! <pre>fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])\n\nstate = np.array([basis.real + 1j * basis.imag for basis in results.state])\nbases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)]\ncounts = {basis: results.counts.get(basis, 0) for basis in bases}\n\nax = axs[0]\nax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0])\nax.set(ylabel=\"Probability\")\n\nax = axs[1]\nax.bar(x=bases, height=list(counts.values()), color=colors[1])\nax.set(ylabel=\"Count\")\n\nax = axs[2]\nax.bar(x=bases, height=state.real, color=colors[2])\nax.set(ylabel=\"Amplitude (real)\")\n\nax = axs[3]\nax.bar(x=bases, height=state.imag, color=colors[3])\nax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);\n</pre> fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])  state = np.array([basis.real + 1j * basis.imag for basis in results.state]) bases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)] counts = {basis: results.counts.get(basis, 0) for basis in bases}  ax = axs[0] ax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0]) ax.set(ylabel=\"Probability\")  ax = axs[1] ax.bar(x=bases, height=list(counts.values()), color=colors[1]) ax.set(ylabel=\"Count\")  ax = axs[2] ax.bar(x=bases, height=state.real, color=colors[2]) ax.set(ylabel=\"Amplitude (real)\")  ax = axs[3] ax.bar(x=bases, height=state.imag, color=colors[3]) ax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]); <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre>"},{"location":"examples/adiabatic_sigmoid.html#sigmoid-adiabatic-state-preparation","title":"Sigmoid Adiabatic State Preparation\u00b6","text":"<p>Sigmoid Adiabatic State Preparation is a variation of adiabatic evolution where the transition between the initial and target Hamiltonians follows a sigmoid curve. This smooth, gradual transformation avoids abrupt changes and allows the system to closely follow the ground state path, as required by the adiabatic theorem.</p> <p>In this example, the Hamiltonian $ H(t) $ is adjusted over time using a sigmoid function:</p> <ol> <li>Initial Hamiltonian, $ H_z $: Encodes the initial ground state. Here, $ H_z = I \\otimes Z + Z \\otimes I $.</li> <li>Target Hamiltonian, $ H\\_{xx} $: Represents the desired end state. Here, $ H\\_{xx} = X \\otimes X $, which applies $X$-basis interactions.</li> </ol> <p>The time-dependent Hamiltonian is given by:</p> <p>$$ H(t) = -(1 - \\text{sigmoid}) \\cdot H_z - \\text{sigmoid} \\cdot H_{xx} $$</p> <p>where $\\text{sigmoid} = \\frac{1}{1 + e^{-0.5 \\cdot (t - 10)}}$ is a sigmoid function that smoothly shifts the weight from $ H*z $ to $ H*{xx} $ as $ t $ progresses. Initially, $ H*z $ dominates; over time, the system increasingly aligns with $ H*{xx} $.</p> <p>In this setup, a two-qubit system evolves under the <code>AnalogGate</code> defined by $ H(t) $ over 30 units of time. The gradual transition led by the sigmoid function allows the state to evolve gently towards the target ground state of $ H\\_{xx} $, which is captured by <code>measure()</code> at the end, approximating the desired solution.</p>"},{"location":"examples/bell_state.html","title":"Bell state preparation","text":"In\u00a0[1]: Copied! <pre>import itertools\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import itertools import warnings  import matplotlib.pyplot as plt import numpy as np import seaborn as sns from oqd_analog_emulator.qutip_backend import QutipBackend from oqd_core.backend.metric import Expectation from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ  warnings.filterwarnings(\"ignore\") <p>Next, we define the one- and two qubit Rabi frequencies and the control Hamiltonians.</p> In\u00a0[2]: Copied! <pre>X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741\n\nn = 2  # number of qubits\n\n# 1-qubit &amp; 2-qubit Rabi frequencies\nw1 = 2 * np.pi * 1\nw2 = 2 * np.pi * 0.1\n</pre> X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741  n = 2  # number of qubits  # 1-qubit &amp; 2-qubit Rabi frequencies w1 = 2 * np.pi * 1 w2 = 2 * np.pi * 0.1 In\u00a0[3]: Copied! <pre>Hii = AnalogGate(hamiltonian=I @ I)\nHxi = AnalogGate(hamiltonian=X @ I)\nHyi = AnalogGate(hamiltonian=Y @ I)\nHxx = AnalogGate(hamiltonian=X @ X)\nHmix = AnalogGate(hamiltonian=-1 * (I @ X))\nHmxi = AnalogGate(hamiltonian=-1 * (X @ I))\nHmyi = AnalogGate(hamiltonian=-1 * (Y @ I))\n</pre> Hii = AnalogGate(hamiltonian=I @ I) Hxi = AnalogGate(hamiltonian=X @ I) Hyi = AnalogGate(hamiltonian=Y @ I) Hxx = AnalogGate(hamiltonian=X @ X) Hmix = AnalogGate(hamiltonian=-1 * (I @ X)) Hmxi = AnalogGate(hamiltonian=-1 * (X @ I)) Hmyi = AnalogGate(hamiltonian=-1 * (Y @ I)) <p>Now, we apply these Hamiltonians sequentially on the two qubits to prepare the entangled state and measure the whole system.</p> In\u00a0[4]: Copied! <pre>circuit = AnalogCircuit()\n\n# Hadamard\ncircuit.evolve(duration=(3 * np.pi) / 2, gate=Hii)\ncircuit.evolve(duration=np.pi / 2, gate=Hxi)\ncircuit.evolve(duration=np.pi / 4, gate=Hmyi)\n\n# CNOT\ncircuit.evolve(duration=np.pi / 4, gate=Hyi)\ncircuit.evolve(duration=np.pi / 4, gate=Hxx)\ncircuit.evolve(duration=np.pi / 4, gate=Hmix)\ncircuit.evolve(duration=np.pi / 4, gate=Hmxi)\ncircuit.evolve(duration=np.pi / 4, gate=Hmyi)\ncircuit.evolve(duration=np.pi / 4, gate=Hii)\n\ncircuit.measure()\n</pre> circuit = AnalogCircuit()  # Hadamard circuit.evolve(duration=(3 * np.pi) / 2, gate=Hii) circuit.evolve(duration=np.pi / 2, gate=Hxi) circuit.evolve(duration=np.pi / 4, gate=Hmyi)  # CNOT circuit.evolve(duration=np.pi / 4, gate=Hyi) circuit.evolve(duration=np.pi / 4, gate=Hxx) circuit.evolve(duration=np.pi / 4, gate=Hmix) circuit.evolve(duration=np.pi / 4, gate=Hmxi) circuit.evolve(duration=np.pi / 4, gate=Hmyi) circuit.evolve(duration=np.pi / 4, gate=Hii)  circuit.measure() <p>Finally, we can emulate the circuit evolution using a classical emulation and track the $Z_1$ and $Z_2$ expectation values.</p> In\u00a0[5]: Copied! <pre>args = TaskArgsAnalog(\n    n_shots=1000,\n    fock_cutoff=4,\n    metrics={\n        \"Z_0\": Expectation(operator=(Z @ I)),\n        \"Z_1\": Expectation(operator=(I @ Z)),\n    },\n    dt=1e-2,\n)\ntask = Task(program=circuit, args=args)\n</pre> args = TaskArgsAnalog(     n_shots=1000,     fock_cutoff=4,     metrics={         \"Z_0\": Expectation(operator=(Z @ I)),         \"Z_1\": Expectation(operator=(I @ Z)),     },     dt=1e-2, ) task = Task(program=circuit, args=args) In\u00a0[6]: Copied! <pre>backend = QutipBackend()\nresults = backend.run(task=task)\n</pre> backend = QutipBackend() results = backend.run(task=task) <pre>[1/1] Cythonizing qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4.pyx\nrunning build_ext\nbuilding 'qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4' extension\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\cl.exe\" /c /nologo /O2 /W3 /GL /DNDEBUG /MD -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\qutip\\core\\data -Id:\\work\\Projects\\equilux\\.venv\\Lib\\site-packages\\numpy\\core\\include -Id:\\work\\Projects\\equilux\\.venv\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\include -IC:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\Include \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\include\" \"-IC:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Auxiliary\\VS\\include\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.22621.0\\ucrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\um\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\shared\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\winrt\" \"-IC:\\Program Files (x86)\\Windows Kits\\10\\\\include\\10.0.22621.0\\\\cppwinrt\" /EHsc /Tpqtcoeff_9935efd7b07a5b0c7f90e15bb1eec4.cpp /Fobuild\\temp.win-amd64-cpython-312\\Release\\qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4.obj\n\"C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\bin\\HostX86\\x64\\link.exe\" /nologo /INCREMENTAL:NO /LTCG /DLL /MANIFEST:EMBED,ID=2 /MANIFESTUAC:NO /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none\\libs /LIBPATH:C:\\Users\\Salieri\\AppData\\Roaming\\uv\\python\\cpython-3.12.9-windows-x86_64-none /LIBPATH:d:\\work\\Projects\\equilux\\.venv\\PCbuild\\amd64 \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\ATLMFC\\lib\\x64\" \"/LIBPATH:C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.42.34433\\lib\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\lib\\10.0.22621.0\\ucrt\\x64\" \"/LIBPATH:C:\\Program Files (x86)\\Windows Kits\\10\\\\lib\\10.0.22621.0\\\\um\\x64\" /EXPORT:PyInit_qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4 build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4.obj /OUT:build\\lib.win-amd64-cpython-312\\qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4.cp312-win_amd64.pyd /IMPLIB:build\\temp.win-amd64-cpython-312\\Release\\qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4.cp312-win_amd64.lib\ncopying build\\lib.win-amd64-cpython-312\\qtcoeff_9935efd7b07a5b0c7f90e15bb1eec4.cp312-win_amd64.pyd -&gt; \n</pre> <p>Finally, we visualize and plot the results for the circuit evolution and the resultant state.</p> In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"crest\", n_colors=4)\n\nfor k, (name, metric) in enumerate(results.metrics.items()):\n    ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\nax.legend()\n</pre> fig, ax = plt.subplots(1, 1, figsize=[6, 3]) colors = sns.color_palette(palette=\"crest\", n_colors=4)  for k, (name, metric) in enumerate(results.metrics.items()):     ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k]) ax.legend() Out[7]: <pre>&lt;matplotlib.legend.Legend at 0x2b0ce6e12e0&gt;</pre> In\u00a0[8]: Copied! <pre>fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])\n\nstate = np.array([basis.real + 1j * basis.imag for basis in results.state])\nbases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)]\ncounts = {basis: results.counts.get(basis, 0) for basis in bases}\n\nax = axs[0]\nax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0])\nax.set(ylabel=\"Probability\")\n\n\nax = axs[1]\nax.bar(x=bases, height=list(counts.values()), color=colors[1])\nax.set(ylabel=\"Count\")\n\nax = axs[2]\nax.bar(x=bases, height=state.real, color=colors[2])\nax.set(ylabel=\"Amplitude (real)\")\n\nax = axs[3]\nax.bar(x=bases, height=state.imag, color=colors[3])\nax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi])\n</pre> fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])  state = np.array([basis.real + 1j * basis.imag for basis in results.state]) bases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)] counts = {basis: results.counts.get(basis, 0) for basis in bases}  ax = axs[0] ax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0]) ax.set(ylabel=\"Probability\")   ax = axs[1] ax.bar(x=bases, height=list(counts.values()), color=colors[1]) ax.set(ylabel=\"Count\")  ax = axs[2] ax.bar(x=bases, height=state.real, color=colors[2]) ax.set(ylabel=\"Amplitude (real)\")  ax = axs[3] ax.bar(x=bases, height=state.imag, color=colors[3]) ax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]) <pre>Using categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\nUsing categorical units to plot a list of strings that are all parsable as floats or dates. If these strings should be plotted as numbers, cast to the appropriate data type before plotting.\n</pre> Out[8]: <pre>[Text(0.5, 0, 'Basis state'),\n Text(0, 0.5, 'Amplitude (imag)'),\n (-3.141592653589793, 3.141592653589793)]</pre>"},{"location":"examples/bell_state.html#analog-circuit-for-preparing-a-bell-state","title":"Analog circuit for preparing a Bell state\u00b6","text":"<p>Bell states are maximally entangled, two-qubit states that are ubiquitous in quantum information tasks. Here, we will create the analog quantum program to prepare the two-qubit Bell state,</p> <p>$$ | \\psi \\rangle = \\frac{1}{\\sqrt{2}} \\left( |00\\rangle + |11\\rangle \\right) $$</p> <p>First, we import the relevant libraries and OQD modules.</p>"},{"location":"examples/ghz_state.html","title":"GHZ state preparation","text":"In\u00a0[1]: Copied! <pre>import functools\nimport itertools\nimport operator\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import functools import itertools import operator import warnings  import matplotlib.pyplot as plt import numpy as np import seaborn as sns from oqd_analog_emulator.qutip_backend import QutipBackend from oqd_core.backend.metric import Expectation from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ  warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741\n\n\nn = 3\n</pre> X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741   n = 3 In\u00a0[3]: Copied! <pre>def sum(args):\n    return functools.reduce(operator.add, args)\n\n\ndef prod(args):\n    return functools.reduce(operator.mul, args)\n\n\ndef tensor(args):\n    return functools.reduce(operator.matmul, args)\n</pre> def sum(args):     return functools.reduce(operator.add, args)   def prod(args):     return functools.reduce(operator.mul, args)   def tensor(args):     return functools.reduce(operator.matmul, args) In\u00a0[4]: Copied! <pre># Hadamard on first qubit\nii = tensor([I for i in range(n)])\nxi = tensor([X if i == 0 else I for i in range(n)])\nyi = tensor([Y if i == 0 else I for i in range(n)])\n\ncircuit = AnalogCircuit()\n\n# evolve Hadamard gate\ncircuit.evolve(duration=(3 * np.pi) / 2, gate=AnalogGate(hamiltonian=ii))\ncircuit.evolve(duration=np.pi / 2, gate=AnalogGate(hamiltonian=xi))\ncircuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=-1 * yi))\n\nfor j in range(1, n):\n    xx = tensor([X if i in (0, j) else I for i in range(n)])\n    mix = -1 * tensor([X if i == j else I for i in range(n)])\n\n    # CNOT\n    circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=yi))\n    circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=xx))\n    circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=mix))\n    circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=-xi))\n    circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=-yi))\n    circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=ii))\n\ncircuit.measure()\n</pre> # Hadamard on first qubit ii = tensor([I for i in range(n)]) xi = tensor([X if i == 0 else I for i in range(n)]) yi = tensor([Y if i == 0 else I for i in range(n)])  circuit = AnalogCircuit()  # evolve Hadamard gate circuit.evolve(duration=(3 * np.pi) / 2, gate=AnalogGate(hamiltonian=ii)) circuit.evolve(duration=np.pi / 2, gate=AnalogGate(hamiltonian=xi)) circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=-1 * yi))  for j in range(1, n):     xx = tensor([X if i in (0, j) else I for i in range(n)])     mix = -1 * tensor([X if i == j else I for i in range(n)])      # CNOT     circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=yi))     circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=xx))     circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=mix))     circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=-xi))     circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=-yi))     circuit.evolve(duration=np.pi / 4, gate=AnalogGate(hamiltonian=ii))  circuit.measure() In\u00a0[5]: Copied! <pre># define task args\nargs = TaskArgsAnalog(\n    n_shots=1000,\n    fock_cutoff=4,\n    metrics={\n        f\"Z_{i}\": Expectation(operator=tensor([Z if j == i else I for j in range(n)]))\n        for i in range(n)\n    },\n    dt=1e-2,\n)\ntask = Task(program=circuit, args=args)\n</pre> # define task args args = TaskArgsAnalog(     n_shots=1000,     fock_cutoff=4,     metrics={         f\"Z_{i}\": Expectation(operator=tensor([Z if j == i else I for j in range(n)]))         for i in range(n)     },     dt=1e-2, ) task = Task(program=circuit, args=args) In\u00a0[6]: Copied! <pre>backend = QutipBackend()\nresults = backend.run(task=task)\n</pre> backend = QutipBackend() results = backend.run(task=task) In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"crest\", n_colors=max([4, n]))\n\nfor k, (name, metric) in enumerate(results.metrics.items()):\n    ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\nax.legend()\nax.set(xlabel=\"Time\", ylabel=\"Expectation value\");\n</pre> fig, ax = plt.subplots(1, 1, figsize=[6, 3]) colors = sns.color_palette(palette=\"crest\", n_colors=max([4, n]))  for k, (name, metric) in enumerate(results.metrics.items()):     ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k]) ax.legend() ax.set(xlabel=\"Time\", ylabel=\"Expectation value\"); In\u00a0[8]: Copied! <pre>fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])\n\nstate = np.array([basis.real + 1j * basis.imag for basis in results.state])\nbases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)]\ncounts = {basis: results.counts.get(basis, 0) for basis in bases}\n\nax = axs[0]\nax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0])\nax.set(ylabel=\"Probability\")\n\n\nax = axs[1]\nax.bar(x=bases, height=list(counts.values()), color=colors[1])\nax.set(ylabel=\"Count\")\n\n\nax = axs[2]\nax.bar(x=bases, height=state.real, color=colors[2])\nax.set(ylabel=\"Amplitude (real)\")\n\nax = axs[3]\nax.bar(x=bases, height=state.imag, color=colors[3])\nax.set_xticks([bases[0], bases[-1]])\nax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);\n</pre> fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])  state = np.array([basis.real + 1j * basis.imag for basis in results.state]) bases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)] counts = {basis: results.counts.get(basis, 0) for basis in bases}  ax = axs[0] ax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0]) ax.set(ylabel=\"Probability\")   ax = axs[1] ax.bar(x=bases, height=list(counts.values()), color=colors[1]) ax.set(ylabel=\"Count\")   ax = axs[2] ax.bar(x=bases, height=state.real, color=colors[2]) ax.set(ylabel=\"Amplitude (real)\")  ax = axs[3] ax.bar(x=bases, height=state.imag, color=colors[3]) ax.set_xticks([bases[0], bases[-1]]) ax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);"},{"location":"examples/ghz_state.html#analog-circuit-for-preparing-a-ghz-state","title":"Analog circuit for preparing a GHZ state\u00b6","text":"<p>GHZ states, much like Bell states, are highly entangled, multi-qubit states. They have broad application in quantum error correction, quantum communication protocols, quantum sensing, and tests of fundamental physics. Here, we will construct and emulate the analog quantum program to prepare a <code>n</code>-qubit GHZ state,</p> <p>$$ |\\psi\\rangle = \\frac{1}{\\sqrt{2}} \\left( |0\\rangle^{\\otimes n} + |1\\rangle^{\\otimes n} \\right) $$</p> <p>First, we import the relevant libraries and OQD modules.</p>"},{"location":"examples/ising_model.html","title":"Ising model","text":"In\u00a0[1]: Copied! <pre>import functools\nimport itertools\nimport operator\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import functools import itertools import operator import warnings  import matplotlib.pyplot as plt import numpy as np import seaborn as sns from oqd_analog_emulator.qutip_backend import QutipBackend from oqd_core.backend.metric import Expectation from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ  warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>def sum(args):\n    return functools.reduce(operator.add, args)\n\n\ndef prod(args):\n    return functools.reduce(operator.mul, args)\n\n\ndef tensor(args):\n    return functools.reduce(operator.matmul, args)\n</pre> def sum(args):     return functools.reduce(operator.add, args)   def prod(args):     return functools.reduce(operator.mul, args)   def tensor(args):     return functools.reduce(operator.matmul, args) In\u00a0[3]: Copied! <pre>X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741\n\n\nn = 6\n</pre> X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741   n = 6 In\u00a0[4]: Copied! <pre>field = sum([tensor([X if i == j else I for i in range(n)]) for j in range(n)])\ninteraction = sum(\n    [tensor([Z if j in (i, (i + 1) % n) else I for j in range(n)]) for i in range(n)]\n)\n\nhamiltonian = AnalogGate(hamiltonian=field + interaction)\n\ncircuit = AnalogCircuit()\ncircuit.evolve(duration=1, gate=hamiltonian)\ncircuit.measure()\n</pre> field = sum([tensor([X if i == j else I for i in range(n)]) for j in range(n)]) interaction = sum(     [tensor([Z if j in (i, (i + 1) % n) else I for j in range(n)]) for i in range(n)] )  hamiltonian = AnalogGate(hamiltonian=field + interaction)  circuit = AnalogCircuit() circuit.evolve(duration=1, gate=hamiltonian) circuit.measure() In\u00a0[5]: Copied! <pre># define task args\nargs = TaskArgsAnalog(\n    n_shots=1000,\n    fock_cutoff=4,\n    metrics={\n        f\"Z_{i}\": Expectation(operator=tensor([Z if j == i else I for j in range(n)]))\n        for i in range(n)\n    },\n    dt=1e-2,\n)\ntask = Task(program=circuit, args=args)\n</pre> # define task args args = TaskArgsAnalog(     n_shots=1000,     fock_cutoff=4,     metrics={         f\"Z_{i}\": Expectation(operator=tensor([Z if j == i else I for j in range(n)]))         for i in range(n)     },     dt=1e-2, ) task = Task(program=circuit, args=args) In\u00a0[6]: Copied! <pre>backend = QutipBackend()\nresults = backend.run(task=task)\n</pre> backend = QutipBackend() results = backend.run(task=task) In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"crest\", n_colors=max([4, n]))\n\nfor k, (name, metric) in enumerate(results.metrics.items()):\n    ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\nax.legend()\nax.set(xlabel=\"Time\", ylabel=\"Expectation value\");\n</pre> fig, ax = plt.subplots(1, 1, figsize=[6, 3]) colors = sns.color_palette(palette=\"crest\", n_colors=max([4, n]))  for k, (name, metric) in enumerate(results.metrics.items()):     ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k]) ax.legend() ax.set(xlabel=\"Time\", ylabel=\"Expectation value\"); In\u00a0[8]: Copied! <pre>fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])\n\nstate = np.array([basis.real + 1j * basis.imag for basis in results.state])\nbases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)]\ncounts = {basis: results.counts.get(basis, 0) for basis in bases}\n\nax = axs[0]\nax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0])\nax.set(ylabel=\"Probability\")\n\n\nax = axs[1]\nax.bar(x=bases, height=list(counts.values()), color=colors[1])\nax.set(ylabel=\"Count\")\n\n\nax = axs[2]\nax.bar(x=bases, height=state.real, color=colors[2])\nax.set(ylabel=\"Amplitude (real)\")\n\nax = axs[3]\nax.bar(x=bases, height=state.imag, color=colors[3])\nax.set_xticks([bases[0], bases[-1]])\nax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);\n</pre> fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])  state = np.array([basis.real + 1j * basis.imag for basis in results.state]) bases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)] counts = {basis: results.counts.get(basis, 0) for basis in bases}  ax = axs[0] ax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0]) ax.set(ylabel=\"Probability\")   ax = axs[1] ax.bar(x=bases, height=list(counts.values()), color=colors[1]) ax.set(ylabel=\"Count\")   ax = axs[2] ax.bar(x=bases, height=state.real, color=colors[2]) ax.set(ylabel=\"Amplitude (real)\")  ax = axs[3] ax.bar(x=bases, height=state.imag, color=colors[3]) ax.set_xticks([bases[0], bases[-1]]) ax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);"},{"location":"examples/ising_model.html#transverse-field-ising-model-tfim","title":"Transverse Field Ising Model (TFIM)\u00b6","text":"<p>The Transverse Field Ising Model (TFIM) is a foundational model in quantum mechanics, especially useful for studying phase transitions and quantum magnetism. It consists of qubits arranged in a line, with each qubit influenced by a transverse magnetic field and interacting with its neighbors. This combination of field and interaction terms creates a rich ground state structure and enables exploration of quantum phenomena such as entanglement and coherence.</p> <p>In this example, the Hamiltonian for the TFIM on $ n = 6 $ qubits includes two main terms:</p> <ol> <li><p>Field Term: Each qubit is influenced by a transverse field along the $ Z $-axis, represented by:</p> <p>$$ H_{\\text{field}} = \\sum_{j=0}^{n-1} Z_j $$</p> </li> </ol> <p>Here, each $ Z_j $ acts only on qubit $ j $, while identity matrices $ I $ act on the remaining qubits.</p> <ol> <li><p>Interaction Term: Each qubit interacts with its nearest neighbor in the $ X $-basis, defined as:</p> <p>$$ H_{\\text{interaction}} = \\sum_{j=0}^{n-1} X_j X_{(j+1) \\ \\text{mod} \\ n} $$</p> <p>This term creates interactions between each qubit $ j $ and its neighbor $(j+1) \\ \\text{mod} \\ n$, introducing correlations in the system.</p> </li> </ol> <p>The total Hamiltonian for the TFIM is:</p> <p>$$ H = H_{\\text{field}} + H_{\\text{interaction}} $$</p> <p>This is implemented as an <code>AnalogGate</code> object, which the circuit evolves under for a duration of 1 unit. By measuring the qubits after this evolution, we obtain information about the system\u2019s ground state, which encodes properties of the transverse field and interaction effects in the Ising model.</p>"},{"location":"examples/one_qubit_rabi_flopping.html","title":"Rabi Flopping","text":"In\u00a0[1]: Copied! <pre>import warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.interface.analog.operator import PauliX, PauliZ\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import warnings  import matplotlib.pyplot as plt import numpy as np import seaborn as sns from oqd_analog_emulator.qutip_backend import QutipBackend from oqd_core.backend.metric import Expectation from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.interface.analog.operator import PauliX, PauliZ  warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>X = PauliX()\nZ = PauliZ()\n\nHx = AnalogGate(hamiltonian=X)\n\ncircuit = AnalogCircuit()\ncircuit.evolve(duration=10, gate=Hx)\ncircuit.measure()\n</pre> X = PauliX() Z = PauliZ()  Hx = AnalogGate(hamiltonian=X)  circuit = AnalogCircuit() circuit.evolve(duration=10, gate=Hx) circuit.measure() In\u00a0[3]: Copied! <pre># define task args\nargs = TaskArgsAnalog(\n    n_shots=1000,\n    fock_cutoff=4,\n    metrics={\n        \"Z\": Expectation(operator=Z),\n    },\n    dt=1e-3,\n)\n\ntask = Task(program=circuit, args=args)\n</pre> # define task args args = TaskArgsAnalog(     n_shots=1000,     fock_cutoff=4,     metrics={         \"Z\": Expectation(operator=Z),     },     dt=1e-3, )  task = Task(program=circuit, args=args) In\u00a0[4]: Copied! <pre>backend = QutipBackend()\nresults = backend.run(task=task)\n</pre> backend = QutipBackend() results = backend.run(task=task) In\u00a0[5]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"crest\", n_colors=4)\n\nfor k, (name, metric) in enumerate(results.metrics.items()):\n    ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\nax.legend();\n</pre> fig, ax = plt.subplots(1, 1, figsize=[6, 3]) colors = sns.color_palette(palette=\"crest\", n_colors=4)  for k, (name, metric) in enumerate(results.metrics.items()):     ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k]) ax.legend(); In\u00a0[6]: Copied! <pre>fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])\n\nstate = np.array([basis.real + 1j * basis.imag for basis in results.state])\nbases = [\"0\", \"1\"]\ncounts = {basis: results.counts.get(basis, 0) for basis in bases}\n\nax = axs[0]\nax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0])\nax.set(ylabel=\"Probability\")\n\nax = axs[1]\nax.bar(x=bases, height=list(counts.values()), color=colors[1])\nax.set(ylabel=\"Count\")\n\nax = axs[2]\nax.bar(x=bases, height=state.real, color=colors[2])\nax.set(ylabel=\"Amplitude (real)\")\n\nax = axs[3]\nax.bar(x=bases, height=state.imag, color=colors[3])\nax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);\n</pre> fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])  state = np.array([basis.real + 1j * basis.imag for basis in results.state]) bases = [\"0\", \"1\"] counts = {basis: results.counts.get(basis, 0) for basis in bases}  ax = axs[0] ax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0]) ax.set(ylabel=\"Probability\")  ax = axs[1] ax.bar(x=bases, height=list(counts.values()), color=colors[1]) ax.set(ylabel=\"Count\")  ax = axs[2] ax.bar(x=bases, height=state.real, color=colors[2]) ax.set(ylabel=\"Amplitude (real)\")  ax = axs[3] ax.bar(x=bases, height=state.imag, color=colors[3]) ax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);"},{"location":"examples/one_qubit_rabi_flopping.html#one-qubit-rabi-flopping","title":"One qubit Rabi flopping\u00b6","text":"<p>Rabi flopping is the oscillation of a qubit in the presence of a driving field. The qubit, initialized in the $|0\\rangle$ state, will precess around the XY-plane of the Bloch sphere.</p> <p>The driving Hamiltonian here is simply the Pauli $X$ operator,</p> <p>$$ X = \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} $$</p> <p>In this example, we implement a single-qubit Rabi flopping and emulate the qubit oscillation using the classical backend.</p>"},{"location":"examples/qaoa.html","title":"QAOA","text":"In\u00a0[1]: Copied! <pre>import itertools\nimport warnings\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\nfrom oqd_core.backend.metric import Expectation\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ\n\nwarnings.filterwarnings(\"ignore\")\n</pre> import itertools import warnings  import matplotlib.pyplot as plt import numpy as np import seaborn as sns from oqd_analog_emulator.qutip_backend import QutipBackend from oqd_core.backend.metric import Expectation from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.interface.analog.operator import PauliI, PauliX, PauliY, PauliZ  warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre>X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741\n</pre> X, Y, Z, I = PauliX(), PauliY(), PauliZ(), PauliI()  # noqa: E741 In\u00a0[3]: Copied! <pre>Hxx = X @ X\nHz = I @ Z + Z @ I\n\nGxx = AnalogGate(hamiltonian=Hxx)\nGz = AnalogGate(hamiltonian=Hz)\n</pre> Hxx = X @ X Hz = I @ Z + Z @ I  Gxx = AnalogGate(hamiltonian=Hxx) Gz = AnalogGate(hamiltonian=Hz) In\u00a0[4]: Copied! <pre>n = 2  # number of qubits\ncircuit = AnalogCircuit()\nfor _ in range(10):\n    circuit.evolve(gate=Gz, duration=np.random.rand())\n    circuit.evolve(gate=Gxx, duration=np.random.rand())\ncircuit.measure()\n</pre> n = 2  # number of qubits circuit = AnalogCircuit() for _ in range(10):     circuit.evolve(gate=Gz, duration=np.random.rand())     circuit.evolve(gate=Gxx, duration=np.random.rand()) circuit.measure() In\u00a0[5]: Copied! <pre>args = TaskArgsAnalog(\n    n_shots=1000,\n    fock_cutoff=4,\n    metrics={\n        \"Z\": Expectation(operator=((I @ Z + Z @ I) * -0.5)),\n        \"XX\": Expectation(operator=(X @ X) * -1),\n    },\n    dt=1e-2,\n)\n\ntask = Task(program=circuit, args=args)\n</pre> args = TaskArgsAnalog(     n_shots=1000,     fock_cutoff=4,     metrics={         \"Z\": Expectation(operator=((I @ Z + Z @ I) * -0.5)),         \"XX\": Expectation(operator=(X @ X) * -1),     },     dt=1e-2, )  task = Task(program=circuit, args=args) In\u00a0[6]: Copied! <pre>backend = QutipBackend()\nresults = backend.run(task=task)\n</pre> backend = QutipBackend() results = backend.run(task=task) In\u00a0[7]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"crest\", n_colors=4)\n\nfor k, (name, metric) in enumerate(results.metrics.items()):\n    ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\nax.legend();\n</pre> fig, ax = plt.subplots(1, 1, figsize=[6, 3]) colors = sns.color_palette(palette=\"crest\", n_colors=4)  for k, (name, metric) in enumerate(results.metrics.items()):     ax.plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k]) ax.legend(); In\u00a0[8]: Copied! <pre>fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])\n\nstate = np.array([basis.real + 1j * basis.imag for basis in results.state])\nbases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)]\ncounts = {basis: results.counts.get(basis, 0) for basis in bases}\n\nax = axs[0]\nax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0])\nax.set(ylabel=\"Probability\")\n\nax = axs[1]\nax.bar(x=bases, height=list(counts.values()), color=colors[1])\nax.set(ylabel=\"Count\")\n\nax = axs[2]\nax.bar(x=bases, height=state.real, color=colors[2])\nax.set(ylabel=\"Amplitude (real)\")\n\nax = axs[3]\nax.bar(x=bases, height=state.imag, color=colors[3])\nax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);\n</pre> fig, axs = plt.subplots(4, 1, sharex=True, figsize=[5, 9])  state = np.array([basis.real + 1j * basis.imag for basis in results.state]) bases = [\"\".join(bits) for bits in itertools.product(\"01\", repeat=n)] counts = {basis: results.counts.get(basis, 0) for basis in bases}  ax = axs[0] ax.bar(x=bases, height=np.abs(state) ** 2, color=colors[0]) ax.set(ylabel=\"Probability\")  ax = axs[1] ax.bar(x=bases, height=list(counts.values()), color=colors[1]) ax.set(ylabel=\"Count\")  ax = axs[2] ax.bar(x=bases, height=state.real, color=colors[2]) ax.set(ylabel=\"Amplitude (real)\")  ax = axs[3] ax.bar(x=bases, height=state.imag, color=colors[3]) ax.set(xlabel=\"Basis state\", ylabel=\"Amplitude (imag)\", ylim=[-np.pi, np.pi]);"},{"location":"examples/qaoa.html#quantum-approximate-optimization-algorithm-qaoa","title":"Quantum Approximate Optimization Algorithm (QAOA)\u00b6","text":"<p>The Quantum Approximate Optimization Algorithm (QAOA) is a variational algorithm designed to solve combinatorial optimization problems using quantum circuits. QAOA leverages alternating Hamiltonian evolutions to approximate the ground state of a given problem, where low energy states correspond to good solutions for the optimization task.</p> <p>In QAOA, two types of Hamiltonians are alternately applied:</p> <ol> <li>Problem Hamiltonian, $ H_z $: Encodes the problem's constraints and objective. Here, $ H_z = I \\otimes Z + Z \\otimes I $, which introduces interactions that depend on the (Z)-basis states of the qubits.</li> <li>Mixer Hamiltonian, $ H\\_{xx} $: Creates transitions between basis states to explore the solution space. $ H\\_{xx} = X \\otimes X $, which flips pairs of qubits, helping the system escape local minima.</li> </ol> <p>These Hamiltonians are implemented as <code>AnalogGate</code> objects, which are applied sequentially to evolve the quantum state. The circuit starts with an initial state and alternates between $ H*z $ and $ H*{xx} $ gates for a series of steps, with random durations to represent the parameters. After a chosen number of steps, the qubits are measured, which ideally yields an approximate solution to the optimization problem.</p> <p>In this example, we set up a two-qubit system and use the <code>AnalogCircuit</code> class to evolve the state under $ H*z $ and $ H*{xx} $ ten times. The <code>measure()</code> method at the end captures the resulting state, which corresponds to a candidate solution.</p>"},{"location":"examples/quantum_scars.html","title":"Quantum scars","text":"<p>The Hamiltonian describes an interacting quantum system with constrained dynamics. It is given by:</p> <p>$$ H = \\sum_{i} P^z_{i} X_{i+1} P^z_{i+2} $$</p> <p>where:</p> <ul> <li>$X_{i}$ is the Pauli-X operator acting on site $i$, which flips the state of a qubit.</li> <li>$P^z_{i} = \\frac{1 + Z_i}{2}$ is a projector that enforces a constraint on site $i$, involving the Pauli-Z operator (note a sign difference from the paper due to different basis state conventions)</li> </ul> <p>This Hamiltonian describes a system where spins (qubits) interact in a constrained way, meaning that spin flips ((X) terms) only occur when specific neighboring conditions are met (enforced by the $P^z$ projectors).</p> In\u00a0[2]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport functools\nimport itertools\nimport operator\nfrom rich.pretty import pprint\n\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliZ\nfrom oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate\nfrom oqd_core.backend.metric import Expectation, EntanglementEntropyVN\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_compiler_infrastructure.rule import PrettyPrint\nfrom oqd_compiler_infrastructure.walk import Post\nfrom oqd_core.compiler.analog.utils import PrintOperator\nfrom oqd_core.compiler.analog.passes.canonicalize import analog_operator_canonicalization \n\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\n</pre> import numpy as np import matplotlib.pyplot as plt import seaborn as sns import functools import itertools import operator from rich.pretty import pprint  import warnings warnings.filterwarnings(\"ignore\")  from oqd_core.interface.analog.operator import PauliI, PauliX, PauliZ from oqd_core.interface.analog.operation import AnalogCircuit, AnalogGate from oqd_core.backend.metric import Expectation, EntanglementEntropyVN from oqd_core.backend.task import Task, TaskArgsAnalog from oqd_compiler_infrastructure.rule import PrettyPrint from oqd_compiler_infrastructure.walk import Post from oqd_core.compiler.analog.utils import PrintOperator from oqd_core.compiler.analog.passes.canonicalize import analog_operator_canonicalization   from oqd_analog_emulator.qutip_backend import QutipBackend In\u00a0[3]: Copied! <pre>def sum(args):\n    return functools.reduce(operator.add, args)\n\ndef prod(args):\n    return functools.reduce(operator.mul, args)\n\ndef tensor(args):\n    return functools.reduce(operator.matmul, args)\n</pre> def sum(args):     return functools.reduce(operator.add, args)  def prod(args):     return functools.reduce(operator.mul, args)  def tensor(args):     return functools.reduce(operator.matmul, args) In\u00a0[4]: Copied! <pre>def site(i: int, L: int):\n    term = [PauliI() for j in range(L)]\n    term[i] = (PauliI() + PauliZ()) * 0.5\n    term[(i + 1) % L] = PauliX()\n    term[(i + 2) % L] = (PauliI() + PauliZ()) * 0.5\n    return tensor(term)\n</pre> def site(i: int, L: int):     term = [PauliI() for j in range(L)]     term[i] = (PauliI() + PauliZ()) * 0.5     term[(i + 1) % L] = PauliX()     term[(i + 2) % L] = (PauliI() + PauliZ()) * 0.5     return tensor(term) In\u00a0[5]: Copied! <pre>n = 12\nk = 2\nzk_gate = sum([tensor([PauliX() if j%k == 0 else PauliI() for j in range(n)])])\n\nhamiltonian = sum([site(i, n) for i in range(n)])\nfstring = Post(PrintOperator())\nprint(f\"Zk gate: {fstring(zk_gate)}\\nHamlitonian: {fstring(hamiltonian)}\")\n</pre> n = 12 k = 2 zk_gate = sum([tensor([PauliX() if j%k == 0 else PauliI() for j in range(n)])])  hamiltonian = sum([site(i, n) for i in range(n)]) fstring = Post(PrintOperator()) print(f\"Zk gate: {fstring(zk_gate)}\\nHamlitonian: {fstring(hamiltonian)}\") <pre>Zk gate: PauliX() @ PauliI() @ PauliX() @ PauliI() @ PauliX() @ PauliI() @ PauliX() @ PauliI() @ PauliX() @ PauliI() @ PauliX() @ PauliI()\nHamlitonian: ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() + PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() + PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() + PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() + PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() + PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() + PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() + PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() + PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() + PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() @ ((0.5) * (PauliI() + PauliZ())) + ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ())) @ PauliX() + PauliX() @ ((0.5) * (PauliI() + PauliZ())) @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ PauliI() @ ((0.5) * (PauliI() + PauliZ()))\n</pre> In\u00a0[7]: Copied! <pre>circuit = AnalogCircuit()\ncircuit.evolve(duration=np.pi/2, gate=AnalogGate(hamiltonian=zk_gate))\ncircuit.evolve(duration=10, gate=AnalogGate(hamiltonian=hamiltonian))\ncircuit.measure()\n</pre> circuit = AnalogCircuit() circuit.evolve(duration=np.pi/2, gate=AnalogGate(hamiltonian=zk_gate)) circuit.evolve(duration=10, gate=AnalogGate(hamiltonian=hamiltonian)) circuit.measure() In\u00a0[8]: Copied! <pre>args = TaskArgsAnalog(\n    n_shots=1000,\n    fock_cutoff=1,\n    metrics={\n        f\"Z_{i}\": Expectation(operator=tensor([PauliZ() if j in (i, (i+1)%n) else PauliI() for j in range(n)]))\n        for i in range(n)\n    } | {\"S\": EntanglementEntropyVN(qreg=list(range(n//2)))},\n    dt=1e-2,\n)\ntask = Task(program=circuit, args=args)\n\nbackend = QutipBackend()\nresults = backend.run(task=task)\n</pre> args = TaskArgsAnalog(     n_shots=1000,     fock_cutoff=1,     metrics={         f\"Z_{i}\": Expectation(operator=tensor([PauliZ() if j in (i, (i+1)%n) else PauliI() for j in range(n)]))         for i in range(n)     } | {\"S\": EntanglementEntropyVN(qreg=list(range(n//2)))},     dt=1e-2, ) task = Task(program=circuit, args=args)  backend = QutipBackend() results = backend.run(task=task) In\u00a0[9]: Copied! <pre>fig, axs = plt.subplots(ncols=1, nrows=3, sharex=True, figsize=[6, 3])\ncolors = sns.color_palette(palette=\"muted\", n_colors=max([20, n]))\n\naxs[0].plot(results.times, results.metrics['S'], label=f\"$S$\", color=colors[0])\naxs[1].plot(results.times, np.diff(results.metrics['S'], prepend=0.0), label=f\"$S$\", color=colors[1])\n\nexpectations = {metric: value for (metric, value) in results.metrics.items() if 'Z' in metric}\nfor k, (name, metric) in enumerate(expectations.items()):\n    axs[2].plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])\n\nfor ax in axs:\n    ax.axvspan(0, np.pi/2, color=\"gray\", alpha=0.4)\n\naxs[0].set(ylabel=r\"$S$\")\naxs[1].set(ylabel=r\"$\\Delta S$\")\naxs[2].set(ylabel=r\"$\\langle Z_i Z_{i+1} \\rangle$\")\naxs[-1].set(xlabel=\"Time\");\n</pre> fig, axs = plt.subplots(ncols=1, nrows=3, sharex=True, figsize=[6, 3]) colors = sns.color_palette(palette=\"muted\", n_colors=max([20, n]))  axs[0].plot(results.times, results.metrics['S'], label=f\"$S$\", color=colors[0]) axs[1].plot(results.times, np.diff(results.metrics['S'], prepend=0.0), label=f\"$S$\", color=colors[1])  expectations = {metric: value for (metric, value) in results.metrics.items() if 'Z' in metric} for k, (name, metric) in enumerate(expectations.items()):     axs[2].plot(results.times, metric, label=f\"$\\\\langle {name} \\\\rangle$\", color=colors[k])  for ax in axs:     ax.axvspan(0, np.pi/2, color=\"gray\", alpha=0.4)  axs[0].set(ylabel=r\"$S$\") axs[1].set(ylabel=r\"$\\Delta S$\") axs[2].set(ylabel=r\"$\\langle Z_i Z_{i+1} \\rangle$\") axs[-1].set(xlabel=\"Time\"); In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/quantum_scars.html#quantum-many-body-scars-and-non-ergodic-dynamics","title":"Quantum Many-Body Scars and Non-Ergodic Dynamics\u00b6","text":"<p>See: Turner, C.J., Michailidis, A.A., Abanin, D.A. et al. Weak ergodicity breaking from quantum many-body scars. Nature Phys 14, 745\u2013749 (2018). https://doi.org/10.1038/s41567-018-0137-5 https://www.nature.com/articles/s41567-018-0137-5</p> <p>This notebook will reconstruct the behaviour demonstrated in Fig. 2.</p> <p>Quantum many-body scars are a phenomenon where a small set of atypical eigenstates within an otherwise thermalizing system lead to long-lived oscillations in dynamics, defying conventional ergodicity. Unlike many-body localization, which relies on disorder to prevent thermalization, these scars emerge in translation-invariant systems and cause the system to retain memory of its initial state for unexpectedly long times.</p> <p>This notebook implements a key early result in the study of quantum many-body scars, where a specific interacting Hamiltonian exhibits long-time oscillations when initialized in a period-2 charge density wave state. The recurrence of local observables and entanglement entropy oscillations suggest the presence of special eigenstates embedded in the spectrum.</p>"},{"location":"examples/quantum_scars.html#initial-states-and-the-scarred-dynamics","title":"Initial States and the Scarred Dynamics\u00b6","text":"<p>A key observation in the study of quantum many-body scars is that certain initial states exhibit long-time oscillations instead of thermalizing. One such state is the period-2 charge density wave (CDW), defined as:</p> <p>$$ \\left| \\mathbb{Z}_2 \\right\\rangle = \\left| 101010\\cdots \\right\\rangle $$</p> <p>where \"1\" represents an excited atom (spin-up) and \"0\" represents the ground state (spin-down). When evolving this state under the Hamiltonian, we observe periodic revivals in local observables and entanglement entropy, instead of the system fully thermalizing as expected in most quantum chaotic systems.</p>"},{"location":"examples/quantum_scars.html#why-this-happens-many-body-scars","title":"Why This Happens: Many-Body Scars\u00b6","text":"<p>Instead of having all eigenstates behave chaotically (ergodically), this system contains special eigenstates that are evenly spaced in energy and have an anomalously low entanglement entropy. These states lead to non-ergodic dynamics where the system oscillates between specific configurations instead of reaching thermal equilibrium.</p>"},{"location":"examples/quantum_scars.html#implementation-in-code","title":"Implementation in Code\u00b6","text":"<ul> <li>The function <code>site(i, L)</code> constructs the local interaction term $P^z_{i} X_{i+1} P^z_{i+2}$.</li> <li>The term <code>zk_gate</code> initializes the system in a charge density wave state.</li> <li>The Hamiltonian <code>hamiltonian</code> is built as a sum over all sites.</li> <li>The circuit then simulates time evolution using quantum gates based on the Hamiltonian.</li> </ul> <p>This implementation numerically reproduces the long-lived oscillations observed in quantum many-body scars.</p>"},{"location":"hardware/about-oqd.html","title":"About OQD Hardware","text":""},{"location":"hardware/about-oqd.html#components-of-a-trapped-ion-quantum-computer","title":"Components of a Trapped Ion Quantum Computer","text":"<ul> <li>Vacuum chamber: ultra-high vacuum environment isolates the ions from the environment.</li> <li>Trapping electrodes: uses electromagnetic potentials to trap ions within an area of the chamber.</li> <li>Lasers: an array of lasers at different wavelengths and powers initialize, manipulate, and measure the ions in the trap.</li> <li>Optical elements: many optical components around the lasers control the beams\u2019 frequency, polarization, phase, and intensity.</li> <li>Control electronics: real-time control electronics orchestrate all of the components, utilizing field programmable gate array (FPGA) cards and radiofrequency components.</li> <li>User interface: software lets users access and run the quantum computer in order to test ideas, run algorithms, and develop use-cases.</li> </ul>"},{"location":"hardware/about-oqd.html#whats-unique-about-oqds-quantum-computer","title":"What's unique about OQD's quantum computer?","text":"<ul> <li>All-to-all connectivity of qubits, high fidelity operations, and long-coherence times.</li> <li>Agile and ultra-low crosstalk addressing of ions via a novel optical addressing scheme.</li> <li>Ion trap and control systems that are designed from the ground up for mid-circuit measurements.</li> <li>Modular real-time control hardware, building on top of the Sinara open-hardware ecosystem.</li> <li>Reusable and extensible control software, aimed at replicating control elements across different trapped ion systems.</li> <li>Ability to program the computers at multiple levels of abstraction, depending on users\u2019 needs and expertise. This includes defining and running quantum programs as digital circuits, analog circuits, and atomic protocols.</li> <li>Suite of state-of-the-art classical emulator backends for testing, prototyping, and validating quantum programs.</li> </ul>"},{"location":"hardware/about-oqd.html#references","title":"References","text":"<ol> <li>Maslov, D., Nam, Y. &amp; Kim, J. An Outlook for Quantum Computing [Point of View]. Proc. IEEE 107, 5\u201310 (2019).</li> <li>Pogorelov, I. et al. Compact Ion-Trap Quantum Computing Demonstrator. PRX Quantum 2, 020343 (2021).</li> <li>Blatt, R. &amp; Wineland, D. Entangled states of trapped atomic ions. Nature 453, 1008\u20131015 (2008).</li> <li>Shammah, N. et al. Open Hardware in Quantum Technology. Preprint at https://doi.org/10.48550/arXiv.2309.17233 (2023).</li> </ol>"},{"location":"hardware/devices.html","title":"Open Hardware Devices","text":"Open Quantum Design: Quantum Processor Hardware      <p>Note</p> <p>Welcome to the Open Quantum Design. This documentation is still under development, we welcome contributions! \u00a9 Open Quantum Design</p>"},{"location":"hardware/devices.html#whats-here","title":"What's Here","text":"<p>The heart of Open Quantum Design's mission and vision is to build open-source, full-stack quantum computers. The second generation of trapped-ion devices, coined Bloodstone and Beryl, are currently under construction and testing. Designs, including electrical, photonic, and mechanical, will be opened sourced for community use and contribution. The real-time control stack builds on top of the open-hardware Sinara ecosystem, including ARTIQ and DAX</p> <pre><code>block-beta\n   columns 3\n\n   block:Interface\n       columns 1\n       InterfaceTitle(\"&lt;i&gt;&lt;b&gt;Interfaces&lt;/b&gt;&lt;i/&gt;\")\n       InterfaceDigital[\"&lt;b&gt;Digital Interface&lt;/b&gt;\\nQuantum circuits with discrete gates\"]\n       space\n       InterfaceAnalog[\"&lt;b&gt;Analog Interface&lt;/b&gt;\\n Continuous-time evolution with Hamiltonians\"]\n       space\n       InterfaceAtomic[\"&lt;b&gt;Atomic Interface&lt;/b&gt;\\nLight-matter interactions between lasers and ions\"]\n       space\n    end\n\n    block:IR\n       columns 1\n       IRTitle(\"&lt;i&gt;&lt;b&gt;IRs&lt;/b&gt;&lt;i/&gt;\")\n       IRDigital[\"Quantum circuit IR\\nopenQASM, LLVM+QIR\"]\n       space\n       IRAnalog[\"openQSIM\"]\n       space\n       IRAtomic[\"openAPL\"]\n       space\n    end\n\n    block:Emulator\n       columns 1\n       EmulatorsTitle(\"&lt;i&gt;&lt;b&gt;Classical Emulators&lt;/b&gt;&lt;i/&gt;\")\n\n       EmulatorDigital[\"Pennylane, Qiskit\"]\n       space\n       EmulatorAnalog[\"QuTiP, QuantumOptics.jl\"]\n       space\n       EmulatorAtomic[\"TrICal, QuantumIon.jl\"]\n       space\n    end\n\n    space\n    block:RealTime\n       columns 1\n       RealTimeTitle(\"&lt;i&gt;&lt;b&gt;Real-Time&lt;/b&gt;&lt;i/&gt;\")\n       space\n       RTSoftware[\"ARTIQ, DAX, OQDAX\"]\n       space\n       RTGateware[\"Sinara Real-Time Control\"]\n       space\n       RTHardware[\"Lasers, Modulators, Photodetection, Ion Trap\"]\n       space\n       RTApparatus[\"Trapped-Ion QPU (&lt;sup&gt;171&lt;/sup&gt;Yt&lt;sup&gt;+&lt;/sup&gt;, &lt;sup&gt;133&lt;/sup&gt;Ba&lt;sup&gt;+&lt;/sup&gt;)\"]\n       space\n    end\n    space\n\n   InterfaceDigital --&gt; IRDigital\n   InterfaceAnalog --&gt; IRAnalog\n   InterfaceAtomic --&gt; IRAtomic\n\n   IRDigital --&gt; IRAnalog\n   IRAnalog --&gt; IRAtomic\n\n   IRDigital --&gt; EmulatorDigital\n   IRAnalog --&gt; EmulatorAnalog\n   IRAtomic --&gt; EmulatorAtomic\n\n   IRAtomic --&gt; RealTimeTitle\n\n   RTSoftware --&gt; RTGateware\n   RTGateware --&gt; RTHardware\n   RTHardware --&gt; RTApparatus\n\n   classDef title fill:#d6d4d4,stroke:#333,color:#333;\n   classDef digital fill:#E7E08B,stroke:#333,color:#333;\n   classDef analog fill:#E4E9B2,stroke:#333,color:#333;\n   classDef atomic fill:#D2E4C4,stroke:#333,color:#333;\n   classDef realtime fill:#B5CBB7,stroke:#333,color:#333;\n\n    classDef highlight fill:#f2bbbb,stroke:#333,color:#333,stroke-dasharray: 5 5;\n\n    class InterfaceTitle,IRTitle,EmulatorsTitle,RealTimeTitle title\n    class InterfaceDigital,IRDigital,EmulatorDigital digital\n    class InterfaceAnalog,IRAnalog,EmulatorAnalog analog\n    class InterfaceAtomic,IRAtomic,EmulatorAtomic atomic\n    class RTSoftware,RTGateware,RTHardware,RTApparatus realtime\n\n    class RealTime highlight</code></pre>"},{"location":"hardware/devices.html#bloodstone","title":"Bloodstone","text":"<ul> <li>Ion species: <sup>171</sup>Yb<sup>+</sup></li> <li>Target number of qubits: 30 \u2013 50</li> <li>Trap architecture: Segmented Blade Trap</li> <li>SPAM individual addressing: DMD</li> <li>Coherent individual addressing with: Double-pass AOM + AOD</li> </ul>"},{"location":"hardware/devices.html#beryl","title":"Beryl","text":"<ul> <li>Ion species: <sup>133</sup>Ba<sup>+</sup>, <sup>137</sup>Ba<sup>+</sup>, <sup>138</sup>Ba<sup>+</sup></li> <li>Target number of qubits: 16</li> <li>Trap architecture: Sandia National Laboratories Phoenix Trap (HOA 2.0 platform)</li> <li>SPAM individual addressing: AOMs</li> <li>Coherent individual addressing: Laser written waveguide + AOMs</li> </ul>"},{"location":"hardware/devices.html#real-time-control-system","title":"Real-time Control System","text":"<p>The OQD stack builds on the Sinara and ARTIQ ecosystems for real-time control.</p>"},{"location":"hardware/devices.html#sinara","title":"Sinara","text":"<p>Sinara is an open-source hardware ecosystem originally designed for use in quantum physics experiments running the ARTIQ control software. The hardware is also suitable for a broad range of laboratory and test &amp; measurement applications. It is licensed under CERN OHL v1.2.</p>"},{"location":"hardware/devices.html#artiq-advanced-real-time-infrastructure-for-quantum","title":"ARTIQ (Advanced Real-Time Infrastructure for Quantum)","text":"<p>The Advanced Real-Time Infrastructure for Quantum physics framework is a software framework developed by M-Labs that provides Python bindings to the Sinara real-time signal generation and detection apparatus at the core of the electrical apparatus. ARTIQ functions by exposing control of the individual channels of custom-specified Sinara hardware in the Python programming language. The system maintains an internal clock and timeline. Events specified programmatically by the user are applied to the timeline and sent to the Sinara hardware with a series of queues. The Sinara hardware then executes the instructions with nanosecond precision on a series of FPGAs.</p>"},{"location":"hardware/devices.html#dax-duke-artiq-extensions","title":"DAX (Duke ARTIQ Extensions)","text":"<p>The Duke ARTIQ Extensions (DAX) are additional tools and capabilities drawn from traditional software design principles for the ARTIQ framework. ARTIQ allows low-level access to individual channels on the Sinara hardware. DAX provides a framework for grouping channels into logical modules representing appropriate experimental apparatus abstractions and services that use those modules to perform regular, repeatable tasks.</p>"},{"location":"open-quantum-design-analog-emulator/index.html","title":"Get Started","text":"Open Quantum Design: Analog Emulators      <p>Note</p> <p>Welcome to Open Quantum Design. This documentation is still under development, we welcome contributions! \u00a9 Open Quantum Design</p> <p><pre><code>block-beta\n   columns 3\n\n   block:Interface\n       columns 1\n       InterfaceTitle(\"&lt;i&gt;&lt;b&gt;Interfaces&lt;/b&gt;&lt;i/&gt;\")\n       InterfaceDigital[\"&lt;b&gt;Digital Interface&lt;/b&gt;\\nQuantum circuits with discrete gates\"] \n       space\n       InterfaceAnalog[\"&lt;b&gt;Analog Interface&lt;/b&gt;\\n Continuous-time evolution with Hamiltonians\"] \n       space\n       InterfaceAtomic[\"&lt;b&gt;Atomic Interface&lt;/b&gt;\\nLight-matter interactions between lasers and ions\"]\n       space\n    end\n\n    block:IR\n       columns 1\n       IRTitle(\"&lt;i&gt;&lt;b&gt;IRs&lt;/b&gt;&lt;i/&gt;\")\n       IRDigital[\"Quantum circuit IR\\nopenQASM, LLVM+QIR\"] \n       space\n       IRAnalog[\"openQSIM\"]\n       space\n       IRAtomic[\"openAPL\"]\n       space\n    end\n\n    block:Emulator\n       columns 1\n       EmulatorsTitle(\"&lt;i&gt;&lt;b&gt;Classical Emulators&lt;/b&gt;&lt;i/&gt;\")\n\n       EmulatorDigital[\"Pennylane, Qiskit\"] \n       space\n       EmulatorAnalog[\"QuTiP, QuantumOptics.jl\"]\n       space\n       EmulatorAtomic[\"TrICal, QuantumIon.jl\"]\n       space\n    end\n\n    space\n    block:RealTime\n       columns 1\n       RealTimeTitle(\"&lt;i&gt;&lt;b&gt;Real-Time&lt;/b&gt;&lt;i/&gt;\")\n       space\n       RTSoftware[\"ARTIQ, DAX, OQDAX\"] \n       space\n       RTGateware[\"Sinara Real-Time Control\"]\n       space\n       RTHardware[\"Lasers, Modulators, Photodetection, Ion Trap\"]\n       space\n       RTApparatus[\"Trapped-Ion QPU (&lt;sup&gt;171&lt;/sup&gt;Yt&lt;sup&gt;+&lt;/sup&gt;, &lt;sup&gt;133&lt;/sup&gt;Ba&lt;sup&gt;+&lt;/sup&gt;)\"]\n       space\n    end\n    space\n\n   InterfaceDigital --&gt; IRDigital\n   InterfaceAnalog --&gt; IRAnalog\n   InterfaceAtomic --&gt; IRAtomic\n\n   IRDigital --&gt; IRAnalog\n   IRAnalog --&gt; IRAtomic\n\n   IRDigital --&gt; EmulatorDigital\n   IRAnalog --&gt; EmulatorAnalog\n   IRAtomic --&gt; EmulatorAtomic\n\n   IRAtomic --&gt; RealTimeTitle\n\n   RTSoftware --&gt; RTGateware\n   RTGateware --&gt; RTHardware\n   RTHardware --&gt; RTApparatus\n\n    classDef title fill:#d6d4d4,stroke:#333,color:#333;\n    classDef digital fill:#E7E08B,stroke:#333,color:#333;\n    classDef analog fill:#E4E9B2,stroke:#333,color:#333;\n    classDef atomic fill:#D2E4C4,stroke:#333,color:#333;\n    classDef realtime fill:#B5CBB7,stroke:#333,color:#333;\n\n    classDef highlight fill:#f2bbbb,stroke:#333,color:#333,stroke-dasharray: 5 5;\n\n    class InterfaceTitle,IRTitle,EmulatorsTitle,RealTimeTitle title\n    class InterfaceDigital,IRDigital,EmulatorDigital digital\n    class InterfaceAnalog,IRAnalog,EmulatorAnalog analog\n    class InterfaceAtomic,IRAtomic,EmulatorAtomic atomic\n    class RTSoftware,RTGateware,RTHardware,RTApparatus realtime\n\n   class EmulatorAnalog highlight</code></pre> The stack components highlighted in red are contained in this repository.</p>"},{"location":"open-quantum-design-analog-emulator/installation.html","title":"Installation","text":"<p>To install via <code>pip</code>,</p> <pre><code>pip install git+https://github.com/OpenQuantumDesign/oqd-analog-emulator.git\n</code></pre> <p>To clone the repository locally:</p> <pre><code>git clone https://github.com/OpenQuantumDesign/oqd-analog-emulator.git\n</code></pre> <p>Install the folder locally with <code>pip</code> and add to the</p> <pre><code>pip install .\nexport PYTHONPATH=$PYTHONPATH:PATH-TO-PACKAGE\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/explanation/qutip-simulation.html","title":"QuTip Simulation","text":""},{"location":"open-quantum-design-analog-emulator/explanation/qutip-simulation.html#compilation","title":"Compilation","text":"<p>We first compile <code>AnalogCircuit</code> to a <code>QutipExperiment</code>  using the ConversionRule <code>QutipBackendCompiler</code>. We also then separately convert the args of Analog layer to a corresponding representation of the args which can be processed by QuTip. The <code>compile</code> functions is used to compile <code>AnalogCircuit</code> to a  <code>QutipExperiment</code> and also used to convert the args.</p>"},{"location":"open-quantum-design-analog-emulator/explanation/qutip-simulation.html#simulation","title":"Simulation","text":"<p>After compilation, the time dynamical evolution is emulated using the Qutip implementation of the Schr\u00f6dinger equation, <code>qutip.sesolve</code>.</p> <pre><code>    stateDiagram-v2\n    User_Input --&gt; OpenQSIM: The user inputs are put in the OpenQSIM AST's Task object\n    OpenQSIM --&gt; OpenQSIM(canonicalized): RewriteRule (Canonicalization of Operators)\n    OpenQSIM(canonicalized) --&gt; QutipExperiment: compile the program of Task to QutipExperiment. And also convert the analog\n    QutipExperiment --&gt; TaskResultAnalog: Run the experiment using the QutipExperimentVM Virtual Machine.</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html","title":"Qutip","text":""},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.qutip_backend","title":"<code>oqd_analog_emulator.qutip_backend</code>","text":""},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.qutip_backend.QutipBackend","title":"<code>QutipBackend</code>","text":"<p>               Bases: <code>BackendBase</code></p> <p>Class representing the Qutip backend</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/qutip_backend.py</code> <pre><code>class QutipBackend(BackendBase):\n    \"\"\"\n    Class representing the Qutip backend\n    \"\"\"\n\n    def compile(self, task: Task):\n        \"\"\"\n        Method for compiling program of task to a [`QutipExperiment`][oqd_analog_emulator.interface.QutipExperiment] and converting\n        args of task to [`TaskArgsAnalog`][oqd_core.backend.task.TaskArgsAnalog].\n\n        Args:\n            task (Task): Quantum experiment to compile\n\n        Returns:\n            converted_circuit (QutipExperiment): QutipExperiment containing the compiled experiment for Qutip\n            converted_args (TaskArgsQutip): args of analog layer are converted to args for QuTip.\n\n        \"\"\"\n        # pass to canonicaliza the operators in the AnalogCircuit\n        canonicalized_circuit = analog_operator_canonicalization(task.program)\n\n        # This just canonicalizes the operators inside the TaskArgsAnalog\n        # i.e. operators for Expectation\n        canonicalized_args = analog_operator_canonicalization(task.args)\n\n        # another pass which assigns the n_qreg and n_qmode of the\n        # AnalogCircuit IR\n        assigned_circuit = assign_analog_circuit_dim(canonicalized_circuit)\n\n        # This just verifies that the operators in the args have the same\n        # dimension as the operators in the AnalogCircuit\n        verify_analog_args_dim(\n            canonicalized_args,\n            n_qreg=assigned_circuit.n_qreg,\n            n_qmode=assigned_circuit.n_qmode,\n        )\n\n        # another pass which compiles AnalogCircuit to a QutipExperiment\n        converted_circuit = compiler_analog_circuit_to_qutipIR(\n            assigned_circuit, fock_cutoff=task.args.fock_cutoff\n        )\n\n        # This just converts the args so that the operators of the args are\n        # converted to qutip objects\n        converted_args = compiler_analog_args_to_qutipIR(canonicalized_args)\n\n        return (\n            converted_circuit,\n            converted_args,\n        )\n\n    def run(\n        self,\n        task: Task,\n    ):\n        \"\"\"\n        Method to simulate an experiment using the QuTip backend\n\n        Args:\n            task (Optional[Task]): Run experiment from a [`Task`][oqd_core.backend.task.Task] object\n\n        Returns:\n            TaskResultAnalog object containing the simulation results.\n\n        Note:\n            only one of task or experiment must be provided.\n        \"\"\"\n\n        # if experiment is None and args is not None:\n        #     raise TypeError(\"args provided without QuTip experiment\")\n        # if experiment is not None and args is None:\n        #     raise TypeError(\"QuTip experiment provided without args\")\n        #\n        # if task is not None and experiment is not None:\n        #     raise TypeError(\"Both task and experiment are given as inputs to run\")\n        # if experiment is None:\n        #     experiment, args = self.compile(task=task)\n\n        experiment, args = self.compile(task=task)\n\n        return run_qutip_experiment(model=experiment, args=args)\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.qutip_backend.QutipBackend.compile","title":"<code>compile(task: Task)</code>","text":"<p>Method for compiling program of task to a <code>QutipExperiment</code> and converting args of task to [<code>TaskArgsAnalog</code>][oqd_core.backend.task.TaskArgsAnalog].</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>Quantum experiment to compile</p> required <p>Returns:</p> Name Type Description <code>converted_circuit</code> <code>QutipExperiment</code> <p>QutipExperiment containing the compiled experiment for Qutip</p> <code>converted_args</code> <code>TaskArgsQutip</code> <p>args of analog layer are converted to args for QuTip.</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/qutip_backend.py</code> <pre><code>def compile(self, task: Task):\n    \"\"\"\n    Method for compiling program of task to a [`QutipExperiment`][oqd_analog_emulator.interface.QutipExperiment] and converting\n    args of task to [`TaskArgsAnalog`][oqd_core.backend.task.TaskArgsAnalog].\n\n    Args:\n        task (Task): Quantum experiment to compile\n\n    Returns:\n        converted_circuit (QutipExperiment): QutipExperiment containing the compiled experiment for Qutip\n        converted_args (TaskArgsQutip): args of analog layer are converted to args for QuTip.\n\n    \"\"\"\n    # pass to canonicaliza the operators in the AnalogCircuit\n    canonicalized_circuit = analog_operator_canonicalization(task.program)\n\n    # This just canonicalizes the operators inside the TaskArgsAnalog\n    # i.e. operators for Expectation\n    canonicalized_args = analog_operator_canonicalization(task.args)\n\n    # another pass which assigns the n_qreg and n_qmode of the\n    # AnalogCircuit IR\n    assigned_circuit = assign_analog_circuit_dim(canonicalized_circuit)\n\n    # This just verifies that the operators in the args have the same\n    # dimension as the operators in the AnalogCircuit\n    verify_analog_args_dim(\n        canonicalized_args,\n        n_qreg=assigned_circuit.n_qreg,\n        n_qmode=assigned_circuit.n_qmode,\n    )\n\n    # another pass which compiles AnalogCircuit to a QutipExperiment\n    converted_circuit = compiler_analog_circuit_to_qutipIR(\n        assigned_circuit, fock_cutoff=task.args.fock_cutoff\n    )\n\n    # This just converts the args so that the operators of the args are\n    # converted to qutip objects\n    converted_args = compiler_analog_args_to_qutipIR(canonicalized_args)\n\n    return (\n        converted_circuit,\n        converted_args,\n    )\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.qutip_backend.QutipBackend.run","title":"<code>run(task: Task)</code>","text":"<p>Method to simulate an experiment using the QuTip backend</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Optional[Task]</code> <p>Run experiment from a [<code>Task</code>][oqd_core.backend.task.Task] object</p> required <p>Returns:</p> Type Description <p>TaskResultAnalog object containing the simulation results.</p> Note <p>only one of task or experiment must be provided.</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/qutip_backend.py</code> <pre><code>def run(\n    self,\n    task: Task,\n):\n    \"\"\"\n    Method to simulate an experiment using the QuTip backend\n\n    Args:\n        task (Optional[Task]): Run experiment from a [`Task`][oqd_core.backend.task.Task] object\n\n    Returns:\n        TaskResultAnalog object containing the simulation results.\n\n    Note:\n        only one of task or experiment must be provided.\n    \"\"\"\n\n    # if experiment is None and args is not None:\n    #     raise TypeError(\"args provided without QuTip experiment\")\n    # if experiment is not None and args is None:\n    #     raise TypeError(\"QuTip experiment provided without args\")\n    #\n    # if task is not None and experiment is not None:\n    #     raise TypeError(\"Both task and experiment are given as inputs to run\")\n    # if experiment is None:\n    #     experiment, args = self.compile(task=task)\n\n    experiment, args = self.compile(task=task)\n\n    return run_qutip_experiment(model=experiment, args=args)\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.interface","title":"<code>oqd_analog_emulator.interface</code>","text":""},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.interface.TaskArgsQutip","title":"<code>TaskArgsQutip</code>","text":"<p>               Bases: <code>VisitableBaseModel</code></p> <p>Class representing args for QuTip</p> <p>Attributes:</p> Name Type Description <code>layer</code> <code>str</code> <p>the layer of the experiment (analog, atomic)</p> <code>n_shots</code> <code>Union[int, None]</code> <p>number of shots requested</p> <code>fock_cutof</code> <code>int</code> <p>fock_cutoff for QuTip simulation</p> <code>dt</code> <code>float</code> <p>timesteps for discrete time</p> <code>metrics</code> <code>dict</code> <p>metrics which should be computed for the experiment. This does not require any Measure instruction in the analog layer.</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/interface.py</code> <pre><code>class TaskArgsQutip(VisitableBaseModel):\n    \"\"\"\n    Class representing args for QuTip\n\n    Attributes:\n        layer (str): the layer of the experiment (analog, atomic)\n        n_shots (Union[int, None]): number of shots requested\n        fock_cutof (int): fock_cutoff for QuTip simulation\n        dt (float): timesteps for discrete time\n        metrics (dict): metrics which should be computed for the experiment. This does not require any Measure instruction in the analog layer.\n    \"\"\"\n\n    layer: Literal[\"analog\"] = \"analog\"\n    n_shots: Union[int, None] = 10\n    fock_cutoff: int = 4\n    dt: float = 0.1\n    metrics: Dict[\n        str, Union[EntanglementEntropyReyni, EntanglementEntropyVN, QutipExpectation]\n    ] = {}\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.interface.QutipOperation","title":"<code>QutipOperation</code>","text":"<p>               Bases: <code>VisitableBaseModel</code></p> <p>Class representing a quantum operation in QuTip</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>List[Qobj, str]</code> <p>Hamiltonian to evolve by</p> <code>duration</code> <code>float</code> <p>Duration of the evolution</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/interface.py</code> <pre><code>class QutipOperation(VisitableBaseModel):\n    \"\"\"\n    Class representing a quantum operation in QuTip\n\n    Attributes:\n        hamiltonian (List[qt.Qobj, str]): Hamiltonian to evolve by\n        duration (float): Duration of the evolution\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n    hamiltonian: List[Tuple[qt.Qobj, MathExpr]]\n    duration: float\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_backend.html#oqd_analog_emulator.interface.QutipExperiment","title":"<code>QutipExperiment</code>","text":"<p>               Bases: <code>VisitableBaseModel</code></p> <p>Class representing a quantum experiment in qutip</p> <p>Attributes:</p> Name Type Description <code>instructions</code> <code>List[QutipOperation]</code> <p>List of quantum operations to apply</p> <code>n_qreg</code> <code>NonNegativeInt</code> <p>Number of qubit quantum registers</p> <code>n_qmode</code> <code>NonNegativeInt</code> <p>Number of modal quantum registers</p> <code>args</code> <code>TaskArgsQutip</code> <p>Arguments for the experiment</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/interface.py</code> <pre><code>class QutipExperiment(VisitableBaseModel):\n    \"\"\"\n    Class representing a quantum experiment in qutip\n\n    Attributes:\n        instructions (List[QutipOperation]): List of quantum operations to apply\n        n_qreg (NonNegativeInt): Number of qubit quantum registers\n        n_qmode (NonNegativeInt): Number of modal quantum registers\n        args (TaskArgsQutip): Arguments for the experiment\n    \"\"\"\n\n    instructions: list[Union[QutipOperation, QutipMeasurement]]\n    n_qreg: NonNegativeInt\n    n_qmode: NonNegativeInt\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html","title":"Compilation","text":""},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.passes","title":"<code>oqd_analog_emulator.passes</code>","text":""},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.passes.compiler_analog_circuit_to_qutipIR","title":"<code>compiler_analog_circuit_to_qutipIR(model, fock_cutoff)</code>","text":"<p>This compiles (<code>AnalogCircuit</code> to a list of  <code>QutipOperation</code> objects</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AnalogCircuit</code> required <code>fock_cutoff</code> <code>int</code> <p>fock_cutoff for Ladder Operators</p> required <p>Returns:</p> Type Description <code>list(QutipOperation)</code> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/passes.py</code> <pre><code>def compiler_analog_circuit_to_qutipIR(model, fock_cutoff):\n    \"\"\"\n    This compiles ([`AnalogCircuit`][oqd_core.interface.analog.operation.AnalogCircuit] to a list of  [`QutipOperation`][oqd_analog_emulator.interface.QutipOperation] objects\n\n    Args:\n        model (AnalogCircuit):\n        fock_cutoff (int): fock_cutoff for Ladder Operators\n\n    Returns:\n        (list(QutipOperation)):\n\n    \"\"\"\n    return Post(QutipBackendCompiler(fock_cutoff=fock_cutoff))(model=model)\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.passes.compiler_analog_args_to_qutipIR","title":"<code>compiler_analog_args_to_qutipIR(model)</code>","text":"<p>This compiles TaskArgsAnalog to a list of TaskArgsQutip</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>TaskArgsAnalog</code> required <p>Returns:</p> Type Description <code>TaskArgsQutip</code> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/passes.py</code> <pre><code>def compiler_analog_args_to_qutipIR(model):\n    \"\"\"\n    This compiles TaskArgsAnalog to a list of TaskArgsQutip\n\n\n    Args:\n        model (TaskArgsAnalog):\n\n    Returns:\n        (TaskArgsQutip):\n\n    \"\"\"\n    return Post(QutipBackendCompiler(fock_cutoff=model.fock_cutoff))(model=model)\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.passes.run_qutip_experiment","title":"<code>run_qutip_experiment(model: QutipExperimentVM, args)</code>","text":"<p>This takes in a <code>QutipExperiment</code> and produces a TaskResultAnalog object</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>QutipExperiment</code> required <code>args</code> <p>(Qutip</p> required <p>Returns:</p> Type Description <code>TaskResultAnalog</code> <p>Contains results of the simulation</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/passes.py</code> <pre><code>def run_qutip_experiment(model: QutipExperimentVM, args):\n    \"\"\"\n    This takes in a [`QutipExperiment`][oqd_analog_emulator.interface.QutipExperiment] and produces a TaskResultAnalog object\n\n    Args:\n        model (QutipExperiment):\n        args: (Qutip\n\n    Returns:\n        (TaskResultAnalog): Contains results of the simulation\n\n    \"\"\"\n    n_qreg = model.n_qreg\n    n_qmode = model.n_qmode\n    metrics = Post(QutipMetricConversion(n_qreg=n_qreg, n_qmode=n_qmode))(args.metrics)\n    interpreter = Pre(\n        QutipExperimentVM(\n            qt_metrics=metrics,\n            n_shots=args.n_shots,\n            fock_cutoff=args.fock_cutoff,\n            dt=args.dt,\n        )\n    )\n    interpreter(model=model)\n\n    return interpreter.children[0].results\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.conversion","title":"<code>oqd_analog_emulator.conversion</code>","text":""},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.conversion.QutipMetricConversion","title":"<code>QutipMetricConversion</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>This takes in a a dictionary containing Metrics, which get converted to lambda functions for QuTip</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>dict</code> <p>The values are Analog layer Operators</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>dict</code> <p>The values are lambda functions</p> Note <p>n_qreg and n_qmode are given as compiler parameters</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/conversion.py</code> <pre><code>class QutipMetricConversion(ConversionRule):\n    \"\"\"\n    This takes in a a dictionary containing Metrics, which get converted to lambda functions for QuTip\n\n    Args:\n        model (dict): The values are Analog layer Operators\n\n    Returns:\n        model (dict): The values are lambda functions\n\n    Note:\n        n_qreg and n_qmode are given as compiler parameters\n    \"\"\"\n\n    def __init__(self, n_qreg, n_qmode):\n        super().__init__()\n        self._n_qreg = n_qreg\n        self._n_qmode = n_qmode\n\n    def map_QutipExpectation(self, model, operands):\n        assert len(model.operator) &gt; 0, \"List of operator terms must be non-empty\"\n\n        op_exp = None\n        for idx, operator in enumerate(model.operator):\n            coefficient = evaluate_math_expr(operator[1])\n            if idx == 0:\n                op_exp = coefficient * operator[0]\n            else:\n                op_exp + coefficient * operator[0]\n\n        return lambda t, psi: qt.expect(op_exp, psi)\n\n    def map_EntanglementEntropyVN(self, model, operands):\n        return lambda t, psi: entanglement_entropy_vn(\n            t, psi, model.qreg, model.qmode, self._n_qreg, self._n_qmode\n        )\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.conversion.QutipExperimentVM","title":"<code>QutipExperimentVM</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>This is a Virtual Machine which takes in a QutipExperiment object, simulates the experiment and then produces the results</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>QutipExperiment</code> <p>This is the compiled  [<code>QutipExperiment</code>][oqd_analog_emulator.qutip_backend.QutipExperiment] object</p> required <p>Returns:</p> Name Type Description <code>task</code> <code>TaskResultAnalog</code> Note <p>n_qreg and n_qmode are given as compiler parameters</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/conversion.py</code> <pre><code>class QutipExperimentVM(RewriteRule):\n    \"\"\"\n    This is a Virtual Machine which takes in a QutipExperiment object, simulates the experiment and then produces the results\n\n    Args:\n        model (QutipExperiment): This is the compiled  [`QutipExperiment`][oqd_analog_emulator.qutip_backend.QutipExperiment] object\n\n    Returns:\n        task (TaskResultAnalog):\n\n    Note:\n        n_qreg and n_qmode are given as compiler parameters\n    \"\"\"\n\n    def __init__(self, qt_metrics, n_shots, fock_cutoff, dt):\n        super().__init__()\n        self.results = TaskResultAnalog(runtime=0)\n        self._qt_metrics = qt_metrics\n        self._n_shots = n_shots\n        self._fock_cutoff = fock_cutoff\n        self._dt = dt\n\n    def map_QutipExperiment(self, model):\n        dims = model.n_qreg * [2] + model.n_qmode * [self._fock_cutoff]\n        self.n_qreg = model.n_qreg\n        self.n_qmode = model.n_qmode\n        self.current_state = qt.tensor([qt.basis(d, 0) for d in dims])\n\n        self.results.times.append(0.0)\n        self.results.state = list(\n            self.current_state.full().squeeze(),\n        )\n        self.results.metrics.update(\n            {\n                key: [self._qt_metrics[key](0.0, self.current_state)]\n                for key in self._qt_metrics.keys()\n            }\n        )\n\n    def map_QutipMeasurement(self, model):\n        if self._n_shots is None:\n            self.results.counts = {}\n        else:\n            probs = np.power(np.abs(self.current_state.full()), 2).squeeze()\n            n_shots = self._n_shots\n            inds = np.random.choice(len(probs), size=n_shots, p=probs)\n            opts = self.n_qreg * [[0, 1]] + self.n_qmode * [\n                list(range(self._fock_cutoff))\n            ]\n            bases = list(itertools.product(*opts))\n            shots = np.array([bases[ind] for ind in inds])\n            bitstrings = [\"\".join(map(str, shot)) for shot in shots]\n            self.results.counts = {\n                bitstring: bitstrings.count(bitstring) for bitstring in bitstrings\n            }\n\n        self.results.state = list(\n            self.current_state.full().squeeze(),\n        )\n\n    def map_QutipOperation(self, model):\n        duration = model.duration\n        tspan = np.linspace(0, duration, round(duration / self._dt)).tolist()\n\n        qutip_hamiltonian = []\n        for op, coeff in model.hamiltonian:\n            qutip_hamiltonian.append(\n                [op, Chain(simplify_math_expr, print_math_expr)(coeff)]\n            )\n\n        start_runtime = time.time()\n        result_qobj = qt.sesolve(\n            qutip_hamiltonian,\n            self.current_state,\n            tspan,\n            e_ops=self._qt_metrics,\n            options={\"store_states\": True},\n        )\n        self.results.runtime = time.time() - start_runtime + self.results.runtime\n\n        self.results.times.extend([t + self.results.times[-1] for t in tspan][1:])\n\n        for idx, key in enumerate(self.results.metrics.keys()):\n            self.results.metrics[key].extend(result_qobj.expect[idx].tolist()[1:])\n\n        self.current_state = result_qobj.final_state\n\n        self.results.state = list(\n            result_qobj.final_state.full().squeeze(),\n        )\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/reference/qutip_compiler.html#oqd_analog_emulator.conversion.QutipBackendCompiler","title":"<code>QutipBackendCompiler</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>This is a ConversionRule which compiles analog layer objects to QutipExperiment objects</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>This takes in objects in Analog level and converts them to representations which can be used to run QuTip simulations.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>Union[VisitableBaseModel, Any]</code> <p>QuTip objects and representations which can be used to run QuTip simulations</p> Source code in <code>oqd-analog-emulator/src/oqd_analog_emulator/conversion.py</code> <pre><code>class QutipBackendCompiler(ConversionRule):\n    \"\"\"\n    This is a ConversionRule which compiles analog layer objects to QutipExperiment objects\n\n    Args:\n        model (VisitableBaseModel): This takes in objects in Analog level and converts them to representations which can be used to run QuTip simulations.\n\n    Returns:\n        model (Union[VisitableBaseModel, Any]): QuTip objects and representations which can be used to run QuTip simulations\n\n    \"\"\"\n\n    def __init__(self, fock_cutoff=None):\n        super().__init__()\n        self._fock_cutoff = fock_cutoff\n\n    def map_AnalogCircuit(self, model, operands):\n        return QutipExperiment(\n            instructions=operands[\"sequence\"],\n            n_qreg=operands[\"n_qreg\"],\n            n_qmode=operands[\"n_qmode\"],\n        )\n\n    def map_TaskArgsAnalog(self, model, operands):\n        return TaskArgsQutip(\n            layer=model.layer,\n            n_shots=model.n_shots,\n            fock_cutoff=model.fock_cutoff,\n            dt=model.dt,\n            metrics=operands[\"metrics\"],\n        )\n\n    def map_Expectation(self, model, operands):\n        return QutipExpectation(operator=operands[\"operator\"])\n\n    def map_Evolve(self, model, operands):\n        return QutipOperation(\n            hamiltonian=operands[\"gate\"],\n            duration=model.duration,\n        )\n\n    def map_Measure(self, model, operands):\n        return QutipMeasurement()\n\n    def map_AnalogGate(self, model, operands):\n        return operands[\"hamiltonian\"]\n\n    def map_OperatorAdd(self, model, operands):\n        op = operands[\"op1\"]\n        op.append(operands[\"op2\"][0])\n        return op\n\n    def map_OperatorScalarMul(self, model, operands):\n        return [(operands[\"op\"], model.expr)]\n\n    def map_PauliI(self, model, operands):\n        return qt.qeye(2)\n\n    def map_PauliX(self, model, operands):\n        return qt.sigmax()\n\n    def map_PauliY(self, model, operands):\n        return qt.sigmay()\n\n    def map_PauliZ(self, model, operands):\n        return qt.sigmaz()\n\n    def map_Identity(self, model, operands):\n        return qt.qeye(self._fock_cutoff)\n\n    def map_Creation(self, model, operands):\n        return qt.create(self._fock_cutoff)\n\n    def map_Annihilation(self, model, operands):\n        return qt.destroy(self._fock_cutoff)\n\n    def map_OperatorMul(self, model, operands):\n        return operands[\"op1\"] * operands[\"op2\"]\n\n    def map_OperatorKron(self, model, operands):\n        return qt.tensor(operands[\"op1\"], operands[\"op2\"])\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/tutorials/analog.html","title":"Analog","text":""},{"location":"open-quantum-design-analog-emulator/tutorials/analog.html#analog-mode","title":"Analog mode","text":"<p>In analog mode, the central object is an <code>AnalogCircuit</code>.  An instance of <code>AnalogCircuit</code> can be evolved for duration <code>t</code> according to an <code>AnalogGate</code>.  The <code>AnalogGate</code> contains a hamiltonian <code>H</code> which is an instance of <code>Operator</code>. As an example, we will perform a Rabi flopping experiment, where one qubit evolves under a driving field. The (time-independent) Hamiltonian, which governs the quantum evolution, is,</p> \\[ H = \\sigma^x \\] <p>The unitary evolution of the circuit is described by the Hamiltonian, \\(H\\), and the time duration \\(t\\).</p> \\[ U = e^{i t H} \\]"},{"location":"open-quantum-design-analog-emulator/tutorials/analog.html#creating-an-analog-quantum-circuit","title":"Creating an analog quantum circuit","text":"<p>In <code>core</code>, time evolution is specified as an analog gate (<code>AnalogGate</code>). For example, to implement the one-qubit Rabi flopping from above,</p> <pre><code>import numpy as np\nfrom oqd_core.interface.analog.operator import PauliX\nfrom oqd_core.interface.analog.operation import AnalogGate, AnalogCircuit\n\ncircuit = AnalogCircuit()\ngate = AnalogGate(hamiltonian=-(np.pi / 4) * PauliX())\ncircuit.evolve(\n    duration=1.0,\n    gate=gate\n)\n</code></pre> <p>In the first lines, we import the relevant objects for analog mode -- the circuit, gate, and operator objects. The circuit object is composed of analog gates, which requires the <code>duration</code> and <code>hamiltonian</code> to be specified.</p> <p>Hamiltonians are represented using Pauli and ladder operators, which act on the qubit registers and boson modes, respectively.</p>"},{"location":"open-quantum-design-analog-emulator/tutorials/analog.html#defining-analog-gates","title":"Defining analog gates","text":"<p>Let's start by creating a more complex Hamiltonian, composed of Pauli operators on the qubit registers.</p> <pre><code>from oqd_core.interface.analog.operator import PauliX\n\ninteraction = PauliX() @ PauliX()\n</code></pre> <p>Here, an interaction operator, \\(\\sigma_x \\otimes \\sigma_x\\), is defined as the tensor product using the <code>@</code> method in Python. Operator objects <code>Operator</code> can (largely) be manipulated like normal Python objects.</p> <p>Optional</p> <p>In our language we represent all operators as abstract syntax trees. this the operator <code>PauliX() @ PauliX()</code> would be represented as the tree:</p> <pre><code>graph TD;\n    A[@] --&gt; B[\"PauliX()\"]\n    A --&gt; C[\"PauliX()\"]</code></pre>"},{"location":"open-quantum-design-analog-emulator/tutorials/ising.html","title":"Transverse field Ising model (TFIM)","text":"<p>Let's implement our favourite Hamiltonian -- the transverse-field Ising model. The general Hamiltonian looks like,</p> \\[ H = \\sum_{\\langle ij \\rangle} \\sigma^x_i \\sigma^x_j + h \\sum_i \\sigma^z_i \\] <p>Let's implement it with two qubits and with \\(h=1\\).</p> \\[ H = \\sigma^x_1 \\sigma^x_2 + \\sigma^z_1 + \\sigma^z_2 \\]"},{"location":"open-quantum-design-analog-emulator/tutorials/ising.html#implementation","title":"Implementation","text":"<p>We will go through this step by step. First we get the necessary imports:</p> Imports <pre><code>from oqd_core.interface.analog.operator import *\nfrom oqd_core.interface.analog.operation import *\nfrom oqd_core.backend.metric import *\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\n</code></pre> <p>Then we define the [<code>AnalogGate</code>][core.interface.analog.operations.AnalogGate] object</p> <pre><code>\"\"\"For simplicity we initialize some Operators\"\"\"\nX, Z, I = PauliX(), PauliZ(), PauliI()\n\nH = AnalogGate(\n    hamiltonian= (X @ X) + (Z @ I) + (I @ Z),\n    dissipation=Dissipation(),\n)\n</code></pre> <p>Then we define the [<code>AnalogCircuit</code>][core.interface.analog.operations.AnalogCircuit] object and evolve it according to the hamiltonian defined above</p> <pre><code>circuit = AnalogCircuit()\ncircuit.evolve(duration = 5, gate = H)\n</code></pre> <p>For QuTip simulation we need to define the arguements which contain the number of shots and the metrics we want to evaluate.</p> <pre><code>args = TaskArgsAnalog(\n    n_shots=100,\n    fock_cutoff=4,\n    metrics={\n        'entanglement_entropy': EntanglementEntropyVN(qreg = [1]),\n    },\n    dt=1e-2,\n)\n</code></pre> <p>We can then wrap the [<code>AnalogCircuit</code>][core.interface.analog.operations.AnalogCircuit] and the args to a [<code>Task</code>][core.backend.task.Task] object and run using the QuTip backend. Note that there are 2 ways to run and the 2 ways are explained.</p>"},{"location":"open-quantum-design-analog-emulator/tutorials/ising.html#running-the-simulation","title":"Running the simulation","text":"<p>First initialize the [<code>QutipBackend</code>][core.backend.qutip.base.QutipBackend] object. === \"Compile &amp; Simulate\" The [<code>Task</code>][core.backend.task.Task] can be compiled first to a [<code>QutipExperiment</code>][core.backend.qutip.interface.QutipExperiment] object and then this [<code>QutipExperiment</code>][core.backend.qutip.interface.QutipExperiment] object can be run. This is to allow you to see what parameters are used to specify the particular QuTip experiment.</p> <pre><code>``` py\nbackend = QutipBackend()\nexperiment, args = backend.compile(task = task)\n```\n</code></pre> <p>=== \"Directly Simulate\" The [<code>Task</code>][core.backend.task.Task] object can be directly simulated by the <code>run()</code> method.</p> <pre><code>``` py\nbackend = QutipBackend()\nresults = backend.run(task = task)\n```\n</code></pre>"},{"location":"open-quantum-design-analog-emulator/tutorials/rabi-flopping.html","title":"Single qubit Rabi flopping","text":"<p>Let's implement the single qubit Rabi Flopping,</p> \\[ H = -\\frac{\\pi}{4}\\sigma^x \\]"},{"location":"open-quantum-design-analog-emulator/tutorials/rabi-flopping.html#implementation","title":"Implementation","text":"<p>We will go through this step by step. First we get the necessary imports:</p> Imports <pre><code>from rich import print as pprint\n\nimport numpy as np\n\nfrom oqd_core.interface.analog.operator import *\nfrom oqd_core.interface.analog.operation import *\nfrom oqd_core.backend.metric import *\nfrom oqd_core.backend.task import Task, TaskArgsAnalog\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\n</code></pre> <p>Then we define the [<code>AnalogGate</code>][core.interface.analog.operations.AnalogGate] object</p> <pre><code>\"\"\"For simplicity we initialize the X Operator\"\"\"\nX = PauliX()\n\nH = AnalogGate(hamiltonian= -(np.pi / 4) * X)\n</code></pre> <p>Then we define the [<code>AnalogCircuit</code>][core.interface.analog.operations.AnalogCircuit] object and evolve it according to the hamiltonian defined above</p> <pre><code>ac = AnalogCircuit()\nac.evolve(duration=3, gate=H)\n</code></pre> <p>For QuTip simulation we need to define the arguements which contain the number of shots and the metrics we want to evaluate.</p> <pre><code>args = TaskArgsAnalog(\n    n_shots=100,\n    fock_cutoff=4,\n    metrics={\n        \"Z\": Expectation(operator = Z),\n    },\n    dt=1e-3,\n)\n</code></pre> <p>We can then wrap the [<code>AnalogCircuit</code>][core.interface.analog.operations.AnalogCircuit] and the args to a [<code>Task</code>][core.backend.task.Task] object and run using the QuTip backend. Note that there are 2 ways to run and the 2 ways are explained.</p>"},{"location":"open-quantum-design-analog-emulator/tutorials/rabi-flopping.html#running-the-simulation","title":"Running the simulation","text":"<p>First initialize the [<code>QutipBackend</code>][core.backend.qutip.base.QutipBackend] object. === \"Compile &amp; Simulate\" The [<code>Task</code>][core.backend.task.Task] can be compiled first to a [<code>QutipExperiment</code>][core.backend.qutip.interface.QutipExperiment] object and then this [<code>QutipExperiment</code>][core.backend.qutip.interface.QutipExperiment] object can be run. This is to allow you to see what parameters are used to specify the particular QuTip experiment.</p> <pre><code>``` py\nbackend = QutipBackend()\nexperiment = backend.compile(task = task)\nresults = backend.run(experiment = experiment)\n```\n</code></pre> <p>=== \"Directly Simulate\" The [<code>Task</code>][core.backend.task.Task] object can be directly simulated by the <code>run()</code> method.</p> <pre><code>``` py\nbackend = QutipBackend()\nresults = backend.run(task = task)\n```\n</code></pre>"},{"location":"open-quantum-design-cloud/index.html","title":"Get Started","text":"Open Quantum Design: Cloud      <p>Note</p> <p>Welcome to the Open Quantum Design. This documentation is still under development, we welcome contributions! \u00a9 Open Quantum Design</p>"},{"location":"open-quantum-design-cloud/index.html#whats-here","title":"What's Here","text":"<p>This repository contains the software needed to submit jobs to a remote, cloud server for classical simulations of quantum programs. In addition, it provides a Docker script to self-host a simulation server of the OQD emulator backends.</p> <p><pre><code>block-beta\n   columns 3\n\n   block:Interface\n       columns 1\n       InterfaceTitle(\"&lt;i&gt;&lt;b&gt;Interfaces&lt;/b&gt;&lt;i/&gt;\")\n       InterfaceDigital[\"&lt;b&gt;Digital Interface&lt;/b&gt;\\nQuantum circuits with discrete gates\"] \n       space\n       InterfaceAnalog[\"&lt;b&gt;Analog Interface&lt;/b&gt;\\n Continuous-time evolution with Hamiltonians\"] \n       space\n       InterfaceAtomic[\"&lt;b&gt;Atomic Interface&lt;/b&gt;\\nLight-matter interactions between lasers and ions\"]\n       space\n    end\n\n    block:IR\n       columns 1\n       IRTitle(\"&lt;i&gt;&lt;b&gt;IRs&lt;/b&gt;&lt;i/&gt;\")\n       IRDigital[\"Quantum circuit IR\\nopenQASM, LLVM+QIR\"] \n       space\n       IRAnalog[\"openQSIM\"]\n       space\n       IRAtomic[\"openAPL\"]\n       space\n    end\n\n    block:Emulator\n       columns 1\n       EmulatorsTitle(\"&lt;i&gt;&lt;b&gt;Classical Emulators&lt;/b&gt;&lt;i/&gt;\")\n\n       EmulatorDigital[\"Pennylane, Qiskit\"] \n       space\n       EmulatorAnalog[\"QuTiP, QuantumOptics.jl\"]\n       space\n       EmulatorAtomic[\"TrICal, QuantumIon.jl\"]\n       space\n    end\n\n    space\n    block:RealTime\n       columns 1\n       RealTimeTitle(\"&lt;i&gt;&lt;b&gt;Real-Time&lt;/b&gt;&lt;i/&gt;\")\n       space\n       RTSoftware[\"ARTIQ, DAX, OQDAX\"] \n       space\n       RTGateware[\"Sinara Real-Time Control\"]\n       space\n       RTHardware[\"Lasers, Modulators, Photodetection, Ion Trap\"]\n       space\n       RTApparatus[\"Trapped-Ion QPU (&lt;sup&gt;171&lt;/sup&gt;Yt&lt;sup&gt;+&lt;/sup&gt;, &lt;sup&gt;133&lt;/sup&gt;Ba&lt;sup&gt;+&lt;/sup&gt;)\"]\n       space\n    end\n    space\n\n   InterfaceDigital --&gt; IRDigital\n   InterfaceAnalog --&gt; IRAnalog\n   InterfaceAtomic --&gt; IRAtomic\n\n   IRDigital --&gt; IRAnalog\n   IRAnalog --&gt; IRAtomic\n\n   IRDigital --&gt; EmulatorDigital\n   IRAnalog --&gt; EmulatorAnalog\n   IRAtomic --&gt; EmulatorAtomic\n\n   IRAtomic --&gt; RealTimeTitle\n\n   RTSoftware --&gt; RTGateware\n   RTGateware --&gt; RTHardware\n   RTHardware --&gt; RTApparatus\n\n    classDef title fill:#d6d4d4,stroke:#333,color:#333;\n    classDef digital fill:#E7E08B,stroke:#333,color:#333;\n    classDef analog fill:#E4E9B2,stroke:#333,color:#333;\n    classDef atomic fill:#D2E4C4,stroke:#333,color:#333;\n    classDef realtime fill:#B5CBB7,stroke:#333,color:#333;\n\n    classDef highlight fill:#f2bbbb,stroke:#333,color:#333,stroke-dasharray: 5 5;\n\n    class InterfaceTitle,IRTitle,EmulatorsTitle,RealTimeTitle title\n    class InterfaceDigital,IRDigital,EmulatorDigital digital\n    class InterfaceAnalog,IRAnalog,EmulatorAnalog analog\n    class InterfaceAtomic,IRAtomic,EmulatorAtomic atomic\n    class RTSoftware,RTGateware,RTHardware,RTApparatus realtime\n\n    class Emulator highlight</code></pre> The tools in this repository allow for self-hosting a server to run quantum programs on classical emulators, highlighted in the stack diagram in red.  A client can specify a quantum program, submit it as a job to the self-hosted server, and retrieve the emulation results.</p> <p>Currently, the analog layer backend is supported.</p>"},{"location":"open-quantum-design-cloud/installation.html","title":"Installation","text":""},{"location":"open-quantum-design-cloud/installation.html#installation","title":"Installation","text":"<p>To install locally for development or launching a Docker container server:</p> <pre><code>git clone https://github.com/OpenQuantumDesign/oqd-cloud.git\npip install .\n</code></pre> <p>To start the simulation server, ensure Docker is installed on the machine, navigate to the <code>docker</code> folder, and run, <pre><code>docker compose up\n</code></pre></p> <p>To serve the documentation,  <pre><code>pip install .[docs]\nmkdocs serve\n</code></pre></p>"},{"location":"open-quantum-design-cloud/explanation/docker-compose.html","title":"Docker","text":""},{"location":"open-quantum-design-cloud/explanation/docker-compose.html#emulation-server-docker-compose","title":"Emulation Server - Docker Compose","text":"<p>The Docker compose script (<code>docker/docker-compose.yaml</code>) runs a backend emulation server.  Once initialized, users can run jobs on the cloud server to emulate any quantum program, expressed as  an <code>AnalogCircuit</code>, <code>DigitalCircuit</code>, or <code>AtomicCircuit</code>, on the supported the backend emulators. Currently, the <code>Analog</code> layer <code>QutipBackend</code> is supported. </p> <p>The server uses Redis to queue submitted jobs and a PostgreSQL database for storing and retrieving  users and jobs.</p> <p>To initialize the server, install Docker following  the installation instructions. Then, it should be as simple as navigating to the <code>docker/</code> path, <pre><code>cd /docker/\n</code></pre> and running, <pre><code>docker compose up\n</code></pre> If all services are initialized and correctly, the outputs should be displayed in the terminal.  To run in the background, use the <code>--detach</code> or <code>-d</code> flag: <pre><code>docker compose up -d\n</code></pre></p>"},{"location":"open-quantum-design-cloud/reference/client.html","title":"Client","text":""},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client","title":"<code>oqd_cloud.client</code>","text":""},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Job","title":"<code>Job</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Job model which is stored in the SQL database</p> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>class Job(BaseModel):\n    \"\"\"\n    Job model which is stored in the SQL database\n    \"\"\"\n\n    model_config = ConfigDict(from_attributes=True)\n\n    job_id: str\n    task: str\n    backend: str\n    status: str\n    result: Optional[str] = None\n    user_id: str\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Client","title":"<code>Client</code>","text":"<p>Client interface for submitting, requesting, and monitoring jobs running on the server.</p> <p>Examples:</p> <pre><code>provider = Provider(url=\"http://localhost:8000\")\nclient = Client()\nclient.connect(\n    provider=provider,\n    user=\"user\",\n    password=\"password\"\n)\njob = client.submit_job(task=task, backend=\"analog-qutip\")\n</code></pre> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>class Client:\n    \"\"\"\n    Client interface for submitting, requesting, and monitoring jobs running on the server.\n\n    Examples:\n        ```\n        provider = Provider(url=\"http://localhost:8000\")\n        client = Client()\n        client.connect(\n            provider=provider,\n            user=\"user\",\n            password=\"password\"\n        )\n        job = client.submit_job(task=task, backend=\"analog-qutip\")\n\n        ```\n    \"\"\"\n\n    def __init__(self):\n        self._jobs = {}\n\n    @property\n    def jobs(self):\n        return self._jobs\n\n    def __len__(self):\n        return len(self.jobs)\n\n    @property\n    def pending(self):\n        return self.status_report[\"queued\"][\"count\"] &gt; 0\n\n    @property\n    def status_report(self):\n        _status_report = dict(\n            queued=dict(count=0, jobs=[]),\n            finished=dict(count=0, jobs=[]),\n            failed=dict(count=0, jobs=[]),\n            stopped=dict(count=0, jobs=[]),\n            canceled=dict(count=0, jobs=[]),\n        )\n        for job in self.jobs.values():\n            _status_report[job.status][\"count\"] += 1\n            _status_report[job.status][\"jobs\"].append(job)\n        return _status_report\n\n    @property\n    def provider(self):\n        if hasattr(self, \"_provider\"):\n            return self._provider\n        raise ConnectionError(\"Missing provider\")\n\n    @property\n    def token(self):\n        if hasattr(self, \"_token\"):\n            return self._token\n        raise ConnectionError(\"Missing token\")\n\n    @property\n    def authorization_header(self):\n        return dict(\n            Authorization=\"{} {}\".format(\n                self.token[\"token_type\"], self.token[\"access_token\"]\n            )\n        )\n\n    def connect(self, provider: Provider, username: str, password: str):\n        \"\"\"Connect to a provider URL with `username` and `password`\"\"\"\n        self._provider = provider\n\n        # username = input(\"Enter username: \")\n        # password = input(\"Enter password: \")\n        login = dict(username=username, password=password)\n\n        response = requests.post(\n            provider.login_url,\n            data=login,\n            headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n        )\n\n        if response.status_code == 200:\n            self._token = response.json()\n            return\n\n        raise response.raise_for_status()\n\n    # def reconnect(self):\n    #     self.connect(self, self.provider)\n    #     pass\n\n    def submit_job(self, task: Task, backend: Literal[\"analog-qutip\",]):\n        \"\"\"Submit a Task as an AnalogCircuit, DigitalCircuit, or AtomicCircuit to a backend.\"\"\"\n        response = requests.post(\n            self.provider.job_submission_url(backend=backend),\n            json=task.model_dump(),\n            headers=self.authorization_header,\n        )\n        job = Job.model_validate(response.json())\n\n        if response.status_code == 200:\n            self._jobs[job.job_id] = job\n            return self.jobs[job.job_id]\n\n        raise response.raise_for_status()\n\n    def retrieve_job(self, job_id):\n        \"\"\"Retrieve the results object of a finished job.\"\"\"\n\n        response = requests.get(\n            self.provider.job_retrieval_url(job_id=job_id),\n            headers=self.authorization_header,\n        )\n        job = Job.model_validate(response.json())\n\n        if response.status_code == 200:\n            self._jobs[job_id] = job\n            return self.jobs[job_id]\n\n        raise response.raise_for_status()\n\n    def status_update(self):\n        \"\"\"Request status update for all jobs.\"\"\"\n\n        for job_id in self.jobs.keys():\n            self.retrieve_job(job_id)\n        pass\n\n    def resubmit_job(self, job_id):\n        \"\"\"Resubmit failed job.\"\"\"\n\n        return self.submit_job(\n            task=Task.model_validate_json(self.jobs[job_id].task),\n            backend=self.jobs[job_id].backend,\n        )\n\n    def cancel_job(self, job_id):\n        \"\"\"Cancel a job.\"\"\"\n\n        response = requests.delete(\n            self.provider.job_cancellation_url(job_id=job_id),\n            headers=self.authorization_header,\n        )\n        job = Job.model_validate(response.json())\n        print(job.status)\n\n        if response.status_code == 200:\n            self._jobs[job_id] = job\n            return self.jobs[job_id]\n\n        raise response.raise_for_status()\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Client.connect","title":"<code>connect(provider: Provider, username: str, password: str)</code>","text":"<p>Connect to a provider URL with <code>username</code> and <code>password</code></p> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>def connect(self, provider: Provider, username: str, password: str):\n    \"\"\"Connect to a provider URL with `username` and `password`\"\"\"\n    self._provider = provider\n\n    # username = input(\"Enter username: \")\n    # password = input(\"Enter password: \")\n    login = dict(username=username, password=password)\n\n    response = requests.post(\n        provider.login_url,\n        data=login,\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"},\n    )\n\n    if response.status_code == 200:\n        self._token = response.json()\n        return\n\n    raise response.raise_for_status()\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Client.submit_job","title":"<code>submit_job(task: Task, backend: Literal['analog-qutip',])</code>","text":"<p>Submit a Task as an AnalogCircuit, DigitalCircuit, or AtomicCircuit to a backend.</p> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>def submit_job(self, task: Task, backend: Literal[\"analog-qutip\",]):\n    \"\"\"Submit a Task as an AnalogCircuit, DigitalCircuit, or AtomicCircuit to a backend.\"\"\"\n    response = requests.post(\n        self.provider.job_submission_url(backend=backend),\n        json=task.model_dump(),\n        headers=self.authorization_header,\n    )\n    job = Job.model_validate(response.json())\n\n    if response.status_code == 200:\n        self._jobs[job.job_id] = job\n        return self.jobs[job.job_id]\n\n    raise response.raise_for_status()\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Client.retrieve_job","title":"<code>retrieve_job(job_id)</code>","text":"<p>Retrieve the results object of a finished job.</p> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>def retrieve_job(self, job_id):\n    \"\"\"Retrieve the results object of a finished job.\"\"\"\n\n    response = requests.get(\n        self.provider.job_retrieval_url(job_id=job_id),\n        headers=self.authorization_header,\n    )\n    job = Job.model_validate(response.json())\n\n    if response.status_code == 200:\n        self._jobs[job_id] = job\n        return self.jobs[job_id]\n\n    raise response.raise_for_status()\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Client.status_update","title":"<code>status_update()</code>","text":"<p>Request status update for all jobs.</p> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>def status_update(self):\n    \"\"\"Request status update for all jobs.\"\"\"\n\n    for job_id in self.jobs.keys():\n        self.retrieve_job(job_id)\n    pass\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Client.resubmit_job","title":"<code>resubmit_job(job_id)</code>","text":"<p>Resubmit failed job.</p> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>def resubmit_job(self, job_id):\n    \"\"\"Resubmit failed job.\"\"\"\n\n    return self.submit_job(\n        task=Task.model_validate_json(self.jobs[job_id].task),\n        backend=self.jobs[job_id].backend,\n    )\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/client.html#oqd_cloud.client.Client.cancel_job","title":"<code>cancel_job(job_id)</code>","text":"<p>Cancel a job.</p> Source code in <code>oqd-cloud/src/oqd_cloud/client.py</code> <pre><code>def cancel_job(self, job_id):\n    \"\"\"Cancel a job.\"\"\"\n\n    response = requests.delete(\n        self.provider.job_cancellation_url(job_id=job_id),\n        headers=self.authorization_header,\n    )\n    job = Job.model_validate(response.json())\n    print(job.status)\n\n    if response.status_code == 200:\n        self._jobs[job_id] = job\n        return self.jobs[job_id]\n\n    raise response.raise_for_status()\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/provider.html","title":"Provider","text":""},{"location":"open-quantum-design-cloud/reference/provider.html#oqd_cloud.provider","title":"<code>oqd_cloud.provider</code>","text":""},{"location":"open-quantum-design-cloud/reference/provider.html#oqd_cloud.provider.Provider","title":"<code>Provider</code>","text":"Source code in <code>oqd-cloud/src/oqd_cloud/provider.py</code> <pre><code>class Provider:\n    def __init__(self, url: str = \"http://localhost:8000\"):\n        \"\"\"\n\n        Args:\n            url: URL for the server\n        \"\"\"\n        self.url = url\n\n    @property\n    def available_backends(self):\n        # todo: get available backends from url\n        if hasattr(self, \"_available_backends\"):\n            return self._available_backends\n        else:\n            return [\n                \"analog-qutip\",\n            ]\n\n    @property\n    def registration_url(self):\n        return self.url + \"/auth/register\"\n\n    @property\n    def login_url(self):\n        return self.url + \"/auth/token\"\n\n    def job_submission_url(self, backend):\n        assert backend in self.available_backends, \"Unavailable backend\"\n        return self.url + f\"/submit/{backend}\"\n\n    def job_retrieval_url(self, job_id):\n        return self.url + f\"/retrieve/{job_id}\"\n\n    def job_cancellation_url(self, job_id):\n        return self.url + f\"/cancel/{job_id}\"\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/provider.html#oqd_cloud.provider.Provider.__init__","title":"<code>__init__(url: str = 'http://localhost:8000')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL for the server</p> <code>'http://localhost:8000'</code> Source code in <code>oqd-cloud/src/oqd_cloud/provider.py</code> <pre><code>def __init__(self, url: str = \"http://localhost:8000\"):\n    \"\"\"\n\n    Args:\n        url: URL for the server\n    \"\"\"\n    self.url = url\n</code></pre>"},{"location":"open-quantum-design-cloud/reference/server.html","title":"Server","text":""},{"location":"open-quantum-design-cloud/reference/server.html#oqd_cloud.server","title":"<code>oqd_cloud.server</code>","text":""},{"location":"open-quantum-design-compiler-infrastructure/index.html","title":"Introduction","text":"Open Quantum Design: Compiler Infrastructure      <p>Note</p> <p>Welcome to Open Quantum Design. This documentation is still under development, we welcome contributions! \u00a9 Open Quantum Design</p>"},{"location":"open-quantum-design-compiler-infrastructure/index.html#whats-here","title":"What's here:","text":"<p>This repository contains the supporting infrastructure, base classes, and abstractions  for creating custom compiler analysis, verification, and transformation passes. The modules in the repository are utilized for, e.g., lowering from the analog to atomic intermediate representations, and the atomic representation to base metal descriptions of quantum programs.</p> <p><pre><code>block-beta\n   columns 3\n\n   block:Interface\n       columns 1\n       InterfaceTitle(\"&lt;i&gt;&lt;b&gt;Interfaces&lt;/b&gt;&lt;i/&gt;\")\n       InterfaceDigital[\"&lt;b&gt;Digital Interface&lt;/b&gt;\\nQuantum circuits with discrete gates\"] \n       space\n       InterfaceAnalog[\"&lt;b&gt;Analog Interface&lt;/b&gt;\\n Continuous-time evolution with Hamiltonians\"] \n       space\n       InterfaceAtomic[\"&lt;b&gt;Atomic Interface&lt;/b&gt;\\nLight-matter interactions between lasers and ions\"]\n       space\n    end\n\n    block:IR\n       columns 1\n       IRTitle(\"&lt;i&gt;&lt;b&gt;IRs&lt;/b&gt;&lt;i/&gt;\")\n       IRDigital[\"Quantum circuit IR\\nopenQASM, LLVM+QIR\"] \n       space\n       IRAnalog[\"openQSIM\"]\n       space\n       IRAtomic[\"openAPL\"]\n       space\n    end\n\n    block:Emulator\n       columns 1\n       EmulatorsTitle(\"&lt;i&gt;&lt;b&gt;Classical Emulators&lt;/b&gt;&lt;i/&gt;\")\n\n       EmulatorDigital[\"Pennylane, Qiskit\"] \n       space\n       EmulatorAnalog[\"QuTiP, QuantumOptics.jl\"]\n       space\n       EmulatorAtomic[\"TrICal, QuantumIon.jl\"]\n       space\n    end\n\n    space\n    block:RealTime\n       columns 1\n       RealTimeTitle(\"&lt;i&gt;&lt;b&gt;Real-Time&lt;/b&gt;&lt;i/&gt;\")\n       space\n       RTSoftware[\"ARTIQ, DAX, OQDAX\"] \n       space\n       RTGateware[\"Sinara Real-Time Control\"]\n       space\n       RTHardware[\"Lasers, Modulators, Photodetection, Ion Trap\"]\n       space\n       RTApparatus[\"Trapped-Ion QPU (&lt;sup&gt;171&lt;/sup&gt;Yt&lt;sup&gt;+&lt;/sup&gt;, &lt;sup&gt;133&lt;/sup&gt;Ba&lt;sup&gt;+&lt;/sup&gt;)\"]\n       space\n    end\n    space\n\n   InterfaceDigital --&gt; IRDigital\n   InterfaceAnalog --&gt; IRAnalog\n   InterfaceAtomic --&gt; IRAtomic\n\n   IRDigital --&gt; IRAnalog\n   IRAnalog --&gt; IRAtomic\n\n   IRDigital --&gt; EmulatorDigital\n   IRAnalog --&gt; EmulatorAnalog\n   IRAtomic --&gt; EmulatorAtomic\n\n   IRAtomic --&gt; RealTimeTitle\n\n   RTSoftware --&gt; RTGateware\n   RTGateware --&gt; RTHardware\n   RTHardware --&gt; RTApparatus\n\n    classDef title fill:#d6d4d4,stroke:#333,color:#333;\n    classDef digital fill:#E7E08B,stroke:#333,color:#333;\n    classDef analog fill:#E4E9B2,stroke:#333,color:#333;\n    classDef atomic fill:#D2E4C4,stroke:#333,color:#333;\n    classDef realtime fill:#B5CBB7,stroke:#333,color:#333;\n\n    classDef highlight fill:#f2bbbb,stroke:#333,color:#333,stroke-dasharray: 5 5;\n\n    class InterfaceTitle,IRTitle,EmulatorsTitle,RealTimeTitle title\n    class InterfaceDigital,IRDigital,EmulatorDigital digital\n    class InterfaceAnalog,IRAnalog,EmulatorAnalog analog\n    class InterfaceAtomic,IRAtomic,EmulatorAtomic atomic\n    class RTSoftware,RTGateware,RTHardware,RTApparatus realtime\n</code></pre> The lowering and compilation passes, used in the vertical lines connecting abstraction layers, are based on the compiler infrastructure components contained  in this repository.</p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/infrastructure.html","title":"Compiler Infrastructure","text":"<p>Compilers are composed of passes, each of which performs a specific operation on the abstract syntax tree (AST). A <code>Pass</code> makes use of the visitor pattern to traverse and manipulate an abstract syntax tree (AST). In our infrastructure, we separated the logic (<code>Rule</code>) and traversal (<code>Walk</code>) of the visitor pattern for better modularity. Passes can be composed, such as with a <code>Rewriter</code>, to form more complex passes.</p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/infrastructure.html#rule","title":"Rule","text":"<p>Rules are used in compilers to specify a scheme for matching and manipulating nodes in an AST. The nodes may be manipulated in several ways:</p> <ul> <li>Unchanged</li> <li>Mapped to a node of the current AST (Rewrite)</li> <li>Mapped to a node of a different AST (Conversion)</li> </ul> Rewrite RuleConversion Rule <p>The rewrite rule is the most basic rule that either leaves the AST unchanged or converts AST nodes between compatible nodes of the AST.</p> <p></p> <p>The conversion rule handles the specific case where the AST nodes need to be transformed to nodes of a different AST.</p> <p>Note</p> <p>Conversion requires that the AST is traversed in a topological order (children nodes converted before parent nodes) limiting the possible walks to only the <code>Post</code> walk.</p> <p></p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/infrastructure.html#walk","title":"Walk","text":"<p>Walks are the different algorithms for traversing the AST, demonstrated with the following tree:</p> <pre><code>    graph TD\n    element0(\"B0\"):::L2\n    element1(\"C2\"):::L3\n    element2(\"C3\"):::L3\n    element3(\"B1\"):::L2\n    element4(\"A0\"):::L1\n    element5(\"C0\"):::L3\n    element6(\"C1\"):::L3\n\n    element3 --&gt; element1 &amp; element2\n    element4 --&gt; element0 &amp; element3\n    element0 --&gt; element5 &amp; element6\n\n    classDef L1 stroke:#FFFFFF00,fill:#009688,color:#ffffff\n    classDef L2 stroke:#FFFFFF00,fill:#00BCD4,color:#ffffff\n    classDef L3 stroke:#FFFFFF00,fill:#03A9F4,color:#ffffff\n</code></pre> PrePostInLevel RegularReverse \\[ A0\\rightarrow B0 \\rightarrow C0 \\rightarrow C1 \\rightarrow B1 \\rightarrow C2 \\rightarrow C3 \\] <p>Note</p> <p>The reverse flag triggers right to left traversal in the walk instead of the regular left to right.</p> \\[ A0\\rightarrow B1 \\rightarrow C3 \\rightarrow C2 \\rightarrow B0 \\rightarrow C1 \\rightarrow C0 \\] <p></p> RegularReverse \\[ C0\\rightarrow C1 \\rightarrow B0 \\rightarrow C2 \\rightarrow C3 \\rightarrow B1 \\rightarrow A0 \\] <p>Note</p> <p>The reverse flag triggers right to left traversal in the walk instead of the regular left to right.</p> \\[ C3\\rightarrow C2 \\rightarrow B1 \\rightarrow C1 \\rightarrow C0 \\rightarrow B0 \\rightarrow A0 \\] <p></p> RegularReverse \\[ C0\\rightarrow B0 \\rightarrow C1 \\rightarrow A0 \\rightarrow C2 \\rightarrow B1 \\rightarrow C3 \\] <p>Note</p> <p>The reverse flag triggers right to left traversal in the walk instead of the regular left to right.</p> \\[ C3\\rightarrow B1 \\rightarrow C2 \\rightarrow A0 \\rightarrow C1 \\rightarrow B0 \\rightarrow C0 \\] <p>Note</p> <p>Due to the traversal order in the In walk, this walk is only compatible with rules that leave the AST unchanged (e.g. analysis and verification)</p> <p></p> RegularReverse \\[ A0\\rightarrow B0 \\rightarrow B1 \\rightarrow C0 \\rightarrow C1 \\rightarrow C2 \\rightarrow C3 \\] <p>Note</p> <p>The reverse flag triggers right to left traversal in the walk instead of the regular left to right.</p> \\[ A0\\rightarrow B1 \\rightarrow B0 \\rightarrow C3 \\rightarrow C2 \\rightarrow C1 \\rightarrow C0 \\] <p>Note</p> <p>Due to the traversal order in the Level walk, this walk is only compatible with rules that leave the AST unchanged (e.g. analysis and verification)</p> <p></p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/infrastructure.html#pass","title":"Pass","text":"<p>A pass is an operation that processes the entire AST. Passes perform several purposes:</p> CanonicalizationAnalysisVerificationOptimizationConversionExecution <p>The canonicalization pass puts the AST into a canonical form eliminating redundancy in the AST.</p> <p>The analysis pass extracts information from the AST.</p> <p>The verification pass checks the validity of the AST.</p> <p>The optimization pass improves the performance of the program represented by the AST.</p> <p>The lowering pass converts the AST to a different AST.</p> <p>The execution pass implements and executes the instructions of the AST to produce results (i.e. defines an interpreter for the AST).</p> <p>The simplest form for a pass is just a <code>rule</code> and <code>walk</code> pair. These simple passes can be combined to form a more complicated pass (e.g. with a <code>rewriter</code>).</p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/infrastructure.html#rewriter","title":"Rewriter","text":"<p>A rewriter implements logic for composing and transforming passes.</p> ChainFixed Point <p>The chain rewriter sequentially applies passes to form complex passs.</p> <p></p> <p>The fixed point rewriter transforms a pass by iteratively applying the pass till convergence of the AST.</p> <p></p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/language.html","title":"Language","text":"<p>Programming languages are defined by generating the specification for the grammar of the language.</p> <p>A program of the language takes the form of a text file and a lexer and parser are combined to process the text file into an abstract syntax tree (AST) for the language.</p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/language.html#abstract-syntax-tree","title":"Abstract Syntax Tree","text":"<p>Provides a tree representation for a program of the language as an algebraic data type (ADT) that can be algorithmically processed.</p> <p>We implement the specification of the ADTs for the AST with custom <code>Pydantic</code> models.  </p>"},{"location":"open-quantum-design-compiler-infrastructure/explanation/language.html#text-representation","title":"Text Representation","text":"<p>The text representation for the program is a JSON schema inherited from <code>Pydantic</code>. Allowing us to make use of the serialization and parsing/deserialization already implemented by <code>Pydantic</code>.</p> <p>Warning</p> <p>To use the serialization and deserialization implementation in <code>Pydantic</code>, subclasses should not be used in the type hints.</p> <p>A work around for when subclasses are needed is to use a separate variable assigned to be the union of the subclasses.</p> Example <pre><code>from typing import Union\nfrom oqd_compiler_infrastructure import TypeReflectBaseModel\n\n\nclass MySuperClass(TypeReflectBaseModel):\n    pass\n\nclass MySubClassA(MySuperClass):\n    pass\n\nclass MySubClassB(MySuperClass):\n    pass\n\nMySuperClassSubtypes = Union[MySubClassA, MySubClassB]\n\nclass MyClass(TypeReflectBaseModel):\n    arg: MySuperClassSubtypes\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/get-started/acknowledgement.html","title":"Acknowledgement","text":"<p>This package was heavily inspired by the following packages:</p>"},{"location":"open-quantum-design-compiler-infrastructure/get-started/acknowledgement.html#liangjl","title":"Liang.jl","text":""},{"location":"open-quantum-design-compiler-infrastructure/get-started/acknowledgement.html#symbolicutilsjl","title":"SymbolicUtils.jl","text":""},{"location":"open-quantum-design-compiler-infrastructure/get-started/acknowledgement.html#mlir","title":"MLIR","text":"<pre><code>@inproceedings{mlir,\n  author    = {Lattner, Chris and Amini, Mehdi and Bondhugula, Uday and Cohen, Albert and Davis, Andy and Pienaar, Jacques and Riddle, River and Shpeisman, Tatiana and Vasilache, Nicolas and Zinenko, Oleksandr},\n  booktitle = {2021 {{IEEE/ACM}} International Symposium on Code Generation and Optimization (CGO)},\n  title     = {{{MLIR}}: Scaling Compiler Infrastructure for Domain Specific Computation},\n  year      = {2021},\n  volume    = {},\n  number    = {},\n  pages     = {2-14},\n  doi       = {10.1109/CGO51591.2021.9370308}\n}\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/get-started/acknowledgement.html#bloqade-python","title":"Bloqade-python","text":"<pre><code>@software{bloqade_2024_11114110,\n  author    = {Weinberg, Phillip and Wu, Kai-Hsin and John Long and Luo, Xiu-zhe (Roger)},\n  title     = {QuEraComputing/bloqade-python: v0.15.11},\n  month     = may,\n  year      = 2024,\n  publisher = {Zenodo},\n  version   = {v0.15.11},\n  doi       = {10.5281/zenodo.11114110},\n  url       = {https://doi.org/10.5281/zenodo.11114110}\n}\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/get-started/acknowledgement.html#additional-acknowledgements","title":"Additional acknowledgements","text":"<p>We would also like to acknowledge the following resources:</p> <ul> <li>MLIR tutorial</li> </ul>"},{"location":"open-quantum-design-compiler-infrastructure/get-started/installation.html","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install git+https://github.com/OpenQuantumDesign/oqd-compiler-infrastructure\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/base.html","title":"Base","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/base.html#oqd_compiler_infrastructure.base","title":"<code>oqd_compiler_infrastructure.base</code>","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/base.html#oqd_compiler_infrastructure.base.PassBase","title":"<code>PassBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for passes.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/base.py</code> <pre><code>class PassBase(ABC):\n    \"\"\"\n    Abstract base class for passes.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @property\n    @abstractmethod\n    def children(self):\n        pass\n\n    def __call__(self, model):\n        self._model = model\n\n        model = self.map(model)\n        if model is None:\n            model = self._model\n        return model\n\n    @abstractmethod\n    def map(self, model):\n        pass\n\n    def __repr__(self):\n        return \"{}({})\".format(\n            self.__class__.__name__,\n            \", \".join(\n                f\"{k}={v}\" for k, v in self.__dict__.items() if not k.startswith(\"_\")\n            ),\n        )\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/interface.html","title":"Interface","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/interface.html#oqd_compiler_infrastructure.interface","title":"<code>oqd_compiler_infrastructure.interface</code>","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/interface.html#oqd_compiler_infrastructure.interface.VisitableBaseModel","title":"<code>VisitableBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Class representing a visitable datastruct</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/interface.py</code> <pre><code>class VisitableBaseModel(BaseModel):\n    \"\"\"\n    Class representing a visitable datastruct\n    \"\"\"\n\n    model_config = ConfigDict(validate_assignment=True)\n\n    def accept(self, pass_):\n        return pass_(self)\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/interface.html#oqd_compiler_infrastructure.interface.TypeReflectBaseModel","title":"<code>TypeReflectBaseModel</code>","text":"<p>               Bases: <code>VisitableBaseModel</code></p> <p>Class representing a datastruct with type reflection</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/interface.py</code> <pre><code>class TypeReflectBaseModel(VisitableBaseModel):\n    \"\"\"\n    Class representing a datastruct with type reflection\n    \"\"\"\n\n    class_: Optional[str]\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def reflect(cls, data):\n        if isinstance(data, BaseModel):\n            return data\n        if \"class_\" in data.keys():\n            if data[\"class_\"] != cls.__name__:\n                raise ValueError('discrepency between \"class_\" field and model type')\n\n        data[\"class_\"] = cls.__name__\n\n        return data\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/rewriter.html","title":"Rewriter","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/rewriter.html#oqd_compiler_infrastructure.rewriter","title":"<code>oqd_compiler_infrastructure.rewriter</code>","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/rewriter.html#oqd_compiler_infrastructure.rewriter.RewriterBase","title":"<code>RewriterBase</code>","text":"<p>               Bases: <code>PassBase</code></p> <p>This class represents a wrapper for passes to compose and modify their logic without affecting the internals of a pass.</p> Acknowledgement <p>This code was inspired by SynbolicUtils.jl, Liang.jl.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/rewriter.py</code> <pre><code>class RewriterBase(PassBase):\n    \"\"\"\n    This class represents a wrapper for passes to compose and modify their logic without\n    affecting the internals of a pass.\n\n    Acknowledgement:\n        This code was inspired by [SynbolicUtils.jl](https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/rewriters.jl), [Liang.jl](https://github.com/Roger-luo/Liang.jl/tree/main/src/rewrite).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/rewriter.html#oqd_compiler_infrastructure.rewriter.Chain","title":"<code>Chain</code>","text":"<p>               Bases: <code>RewriterBase</code></p> <p>This class represents a composite pass where the passes are applied sequentially.</p> Acknowledgement <p>This code was inspired by SymbolicUtils.jl, Liang.jl.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/rewriter.py</code> <pre><code>class Chain(RewriterBase):\n    \"\"\"\n    This class represents a composite pass where the passes are applied sequentially.\n\n    Acknowledgement:\n        This code was inspired by [SymbolicUtils.jl](https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/rewriters.jl#L64C8-L64C13), [Liang.jl](https://github.com/Roger-luo/Liang.jl/blob/main/src/rewrite/chain.jl).\n    \"\"\"\n\n    def __init__(self, *rules):\n        super().__init__()\n\n        self.rules = list(rules)\n        pass\n\n    @property\n    def children(self):\n        return self.rules\n\n    def map(self, model):\n        new_model = model\n        for rule in self.rules:\n            new_model = rule(new_model)\n        return new_model\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/rewriter.html#oqd_compiler_infrastructure.rewriter.FixedPoint","title":"<code>FixedPoint</code>","text":"<p>               Bases: <code>RewriterBase</code></p> <p>This class represents a wrapped pass that is applied until the object/IR converges to a fixed point or reaches a maximum iteration count.</p> Acknowledgement <p>This code was inspired by SymbolicUtils.jl, Liang.jl.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/rewriter.py</code> <pre><code>class FixedPoint(RewriterBase):\n    \"\"\"\n    This class represents a wrapped pass that is applied until the object/IR converges to a fixed point\n    or reaches a maximum iteration count.\n\n    Acknowledgement:\n        This code was inspired by [SymbolicUtils.jl](https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/rewriters.jl#L117C8-L117C16), [Liang.jl](https://github.com/Roger-luo/Liang.jl/blob/main/src/rewrite/fixpoint.jl).\n    \"\"\"\n\n    def __init__(self, rule, *, max_iter=1000):\n        super().__init__()\n\n        self.rule = rule\n        self.max_iter = max_iter\n        pass\n\n    @property\n    def children(self):\n        return [self.rule]\n\n    def map(self, model):\n        i = 0\n        new_model = model\n        while True:\n            _model = self.rule(new_model)\n\n            if _model == new_model or i &gt;= self.max_iter:\n                return new_model\n\n            new_model = _model\n            i += 1\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/rule.html","title":"Rule","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/rule.html#oqd_compiler_infrastructure.rule","title":"<code>oqd_compiler_infrastructure.rule</code>","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/rule.html#oqd_compiler_infrastructure.rule.RuleBase","title":"<code>RuleBase</code>","text":"<p>               Bases: <code>PassBase</code></p> <p>This class represents a rule applied to an IR.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/rule.py</code> <pre><code>class RuleBase(PassBase):\n    \"\"\"\n    This class represents a rule applied to an IR.\n    \"\"\"\n\n    @property\n    def children(self):\n        return []\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/rule.html#oqd_compiler_infrastructure.rule.RewriteRule","title":"<code>RewriteRule</code>","text":"<p>               Bases: <code>RuleBase</code></p> <p>This class represents a rule used to rewrite a type or IR. The result of the same type or IR.</p> Acknowledgement <p>This code was inspired by MLIR, Bloqade-python</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/rule.py</code> <pre><code>class RewriteRule(RuleBase):\n    \"\"\"\n    This class represents a rule used to rewrite a type or IR. The result of the same type\n    or IR.\n\n    Acknowledgement:\n        This code was inspired by [MLIR](https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/PatternMatch.h#L246), [Bloqade-python](https://github.com/QuEraComputing/bloqade-python/blob/main/src/bloqade/ir/visitor.py#L34)\n    \"\"\"\n\n    def map(self, model):\n        for cls in model.__class__.__mro__:\n            map_func = getattr(self, \"map_{}\".format(cls.__name__), None)\n            if map_func:\n                break\n\n        if not map_func:\n            map_func = self.generic_map\n\n        return map_func(model)\n\n    def generic_map(self, model):\n        return model\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/rule.html#oqd_compiler_infrastructure.rule.ConversionRule","title":"<code>ConversionRule</code>","text":"<p>               Bases: <code>RuleBase</code></p> <p>This class represents a rule used to convert between different types and IRs.</p> Acknowledgement <p>This code was inspired by MLIR</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/rule.py</code> <pre><code>class ConversionRule(RuleBase):\n    \"\"\"\n    This class represents a rule used to convert between different types and IRs.\n\n    Acknowledgement:\n        This code was inspired by [MLIR]()\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.operands = None\n\n    def map(self, model):\n        operands = self.operands\n\n        for cls in model.__class__.__mro__:\n            map_func = getattr(self, \"map_{}\".format(cls.__name__), None)\n            if map_func:\n                break\n\n        if not map_func:\n            map_func = self.generic_map\n\n        return map_func(model, operands=operands)\n\n    def generic_map(self, model, operands):\n        return model\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/rule.html#oqd_compiler_infrastructure.rule.PrettyPrint","title":"<code>PrettyPrint</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>This class represents a rewrite rule that constructs a string to represent an AST.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/rule.py</code> <pre><code>class PrettyPrint(ConversionRule):\n    \"\"\"\n    This class represents a rewrite rule that constructs a string to represent an AST.\n    \"\"\"\n\n    def __init__(self, *, indent=\"  \"):\n        super().__init__()\n\n        self.indent = indent\n\n    def generic_map(self, model, operands):\n        return f\"{model.__class__.__name__}({model})\"\n\n    def map_list(self, model, operands):\n        s = f\"{model.__class__.__name__}\"\n\n        _s = \"\"\n        for n, o in enumerate(operands):\n            _s += f\"\\n{self.indent}- {n}: \" + f\"\\n{self.indent}\".join(o.split(\"\\n\"))\n\n        s = s + _s\n\n        return s\n\n    def map_tuple(self, model, operands):\n        s = f\"{model.__class__.__name__}\"\n\n        _s = \"\"\n        for n, o in enumerate(operands):\n            _s += f\"\\n{self.indent}- {n}: \" + f\"\\n{self.indent}\".join(o.split(\"\\n\"))\n\n        s = s + _s\n\n        return s\n\n    def map_dict(self, model, operands):\n        s = f\"{model.__class__.__name__}\"\n\n        _s = \"\"\n        for k, v in operands.items():\n            _s += f\"\\n{self.indent}- {k}: \" + f\"\\n{self.indent}\".join(v.split(\"\\n\"))\n\n        s = s + _s\n\n        return s\n\n    def map_VisitableBaseModel(self, model, operands):\n        s = f\"{model.__class__.__name__}\"\n\n        _s = \"\"\n        for k, v in operands.items():\n            _s += f\"\\n{self.indent}- {k}: \" + f\"\\n{self.indent}\".join(v.split(\"\\n\"))\n\n        s = s + _s\n\n        return s\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/walk.html","title":"Walk","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/walk.html#oqd_compiler_infrastructure.walk","title":"<code>oqd_compiler_infrastructure.walk</code>","text":""},{"location":"open-quantum-design-compiler-infrastructure/reference/walk.html#oqd_compiler_infrastructure.walk.WalkBase","title":"<code>WalkBase</code>","text":"<p>               Bases: <code>PassBase</code></p> <p>This class represents a tree traversal algorithm to walk through an AST.</p> Acknowledgement <p>This code was inspired by SymbolicUtils.jl, Liang.jl</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/walk.py</code> <pre><code>class WalkBase(PassBase):\n    \"\"\"\n    This class represents a tree traversal algorithm to walk through an AST.\n\n    Acknowledgement:\n        This code was inspired by [SymbolicUtils.jl](https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/rewriters.jl#L167), [Liang.jl](https://github.com/Roger-luo/Liang.jl/blob/main/src/rewrite/walk.jl#L1)\n    \"\"\"\n\n    def __init__(self, rule: PassBase, *, reverse: bool = False):\n        super().__init__()\n\n        self.rule = rule\n        self.reverse = reverse\n        pass\n\n    @staticmethod\n    def controlled_reverse(iterable, reverse, *, restore_type=False):\n        new_iterable = reversed(iterable) if reverse else iterable\n        new_iterable = (\n            iterable.__class__(new_iterable) if restore_type else new_iterable\n        )\n        return new_iterable\n\n    @property\n    def children(self):\n        return [self.rule]\n\n    def map(self, model):\n        return self.walk(model)\n\n    def walk(self, model):\n        for cls in model.__class__.__mro__:\n            walk_func = getattr(self, \"walk_{}\".format(cls.__name__), None)\n            if walk_func:\n                break\n\n        if not walk_func:\n            walk_func = self.generic_walk\n\n        return walk_func(model)\n\n    def generic_walk(self, model):\n        return self.rule(model)\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/walk.html#oqd_compiler_infrastructure.walk.Pre","title":"<code>Pre</code>","text":"<p>               Bases: <code>WalkBase</code></p> <p>This class represents the pre order tree traversal algorithm that walks through an AST and applies the rule from top to bottom.</p> Acknowledgement <p>This code was inspired by SymbolicUtils.jl, Liang.jl</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/walk.py</code> <pre><code>class Pre(WalkBase):\n    \"\"\"\n    This class represents the pre order tree traversal algorithm that walks through an AST\n    and applies the rule from top to bottom.\n\n    Acknowledgement:\n        This code was inspired by [SymbolicUtils.jl](https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/rewriters.jl#L187), [Liang.jl](https://github.com/Roger-luo/Liang.jl/blob/main/src/rewrite/walk.jl#L3)\n    \"\"\"\n\n    def walk_dict(self, model):\n        new_model = self.rule(model)\n\n        new_model = {\n            k: self(v)\n            for k, v in self.controlled_reverse(new_model.items(), self.reverse)\n        }\n\n        return {\n            k: v for k, v in self.controlled_reverse(new_model.items(), self.reverse)\n        }\n\n    def walk_list(self, model):\n        new_model = self.rule(model)\n\n        new_model = [self(e) for e in self.controlled_reverse(new_model, self.reverse)]\n\n        return self.controlled_reverse(new_model, self.reverse, restore_type=True)\n\n    def walk_tuple(self, model):\n        new_model = self.rule(model)\n\n        new_model = tuple(\n            [self(e) for e in self.controlled_reverse(new_model, self.reverse)]\n        )\n\n        return self.controlled_reverse(new_model, self.reverse, restore_type=True)\n\n    def walk_VisitableBaseModel(self, model):\n        new_model = self.rule(model)\n\n        new_fields = {}\n        for key in self.controlled_reverse(new_model.model_fields.keys(), self.reverse):\n            if key == \"class_\":\n                continue\n            new_fields[key] = self(getattr(new_model, key))\n        new_model = new_model.__class__(**new_fields)\n\n        return new_model\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/walk.html#oqd_compiler_infrastructure.walk.Post","title":"<code>Post</code>","text":"<p>               Bases: <code>WalkBase</code></p> <p>This class represents the post order tree traversal algorithm that walks through an AST and applies the rule from bottom to top.</p> Acknowledgement <p>This code was inspired by SymbolicUtils.jl, Liang.jl</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/walk.py</code> <pre><code>class Post(WalkBase):\n    \"\"\"\n    This class represents the post order tree traversal algorithm that walks through an AST\n    and applies the rule from bottom to top.\n\n    Acknowledgement:\n        This code was inspired by [SymbolicUtils.jl](https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/rewriters.jl#L183), [Liang.jl](https://github.com/Roger-luo/Liang.jl/blob/main/src/rewrite/walk.jl#L9)\n    \"\"\"\n\n    def walk_dict(self, model):\n        new_model = {\n            k: self(v) for k, v in self.controlled_reverse(model.items(), self.reverse)\n        }\n        new_model = {\n            k: v for k, v in self.controlled_reverse(new_model.items(), self.reverse)\n        }\n\n        if isinstance(self.rule, ConversionRule):\n            self.rule.operands = new_model\n\n        new_model = self.rule(new_model)\n\n        return new_model\n\n    def walk_list(self, model):\n        new_model = [self(e) for e in self.controlled_reverse(model, self.reverse)]\n        new_model = self.controlled_reverse(new_model, self.reverse, restore_type=True)\n\n        if isinstance(self.rule, ConversionRule):\n            self.rule.operands = new_model\n\n        new_model = self.rule(new_model)\n        return new_model\n\n    def walk_tuple(self, model):\n        new_model = tuple(\n            [self(e) for e in self.controlled_reverse(model, self.reverse)]\n        )\n        new_model = self.controlled_reverse(new_model, self.reverse, restore_type=True)\n\n        if isinstance(self.rule, ConversionRule):\n            self.rule.operands = new_model\n\n        new_model = self.rule(new_model)\n        return new_model\n\n    def walk_VisitableBaseModel(self, model):\n        new_fields = {}\n        for key in self.controlled_reverse(model.model_fields.keys(), self.reverse):\n            if key == \"class_\":\n                continue\n            new_fields[key] = self(getattr(model, key))\n\n        if isinstance(self.rule, ConversionRule):\n            self.rule.operands = new_fields\n            new_model = self.rule(model)\n        else:\n            new_model = model.__class__(**new_fields)\n            new_model = self.rule(new_model)\n\n        return new_model\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/walk.html#oqd_compiler_infrastructure.walk.Level","title":"<code>Level</code>","text":"<p>               Bases: <code>WalkBase</code></p> <p>This class represents the level/breadth first order tree traversal algorithm that walks through an AST.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/walk.py</code> <pre><code>class Level(WalkBase):\n    \"\"\"\n    This class represents the level/breadth first order tree traversal algorithm that walks through an AST.\n    \"\"\"\n\n    def __init__(self, rule, *, reverse=False):\n        super().__init__(rule, reverse=reverse)\n\n        self.stack = []\n        self.initial = True\n\n    def generic_walk(self, model):\n        if self.initial:\n            self.stack.append(model)\n            self.initial = False\n\n        self.rule(self.stack.pop(0))\n        if self.stack:\n            self(self.stack[0])\n        return model\n\n    def walk_list(self, model):\n        if self.initial:\n            self.stack.append(model)\n            self.initial = False\n\n        self.stack.extend(self.controlled_reverse(model, self.reverse))\n\n        self.rule(self.stack.pop(0))\n        if self.stack:\n            self(self.stack[0])\n        return model\n\n    def walk_tuple(self, model):\n        if self.initial:\n            self.stack.append(model)\n            self.initial = False\n\n        self.stack.extend(self.controlled_reverse(model, self.reverse))\n\n        self.rule(self.stack.pop(0))\n        if self.stack:\n            self(self.stack[0])\n        return model\n\n    def walk_dict(self, model):\n        if self.initial:\n            self.stack.append(model)\n            self.initial = False\n\n        self.stack.extend(self.controlled_reverse(model.values(), self.reverse))\n\n        self.rule(self.stack.pop(0))\n        if self.stack:\n            self(self.stack[0])\n        return model\n\n    def walk_VisitableBaseModel(self, model):\n        if self.initial:\n            self.stack.append(model)\n            self.initial = False\n\n        self.stack.extend(\n            self.controlled_reverse(\n                [getattr(model, k) for k in model.model_fields.keys() if k != \"class_\"],\n                self.reverse,\n            )\n        )\n\n        self.rule(self.stack.pop(0))\n        if self.stack:\n            self(self.stack[0])\n        return model\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/reference/walk.html#oqd_compiler_infrastructure.walk.In","title":"<code>In</code>","text":"<p>               Bases: <code>WalkBase</code></p> <p>This class represents the in order tree traversal algorithm that walks through an AST.</p> Source code in <code>oqd-compiler-infrastructure/src/oqd_compiler_infrastructure/walk.py</code> <pre><code>class In(WalkBase):\n    \"\"\"\n    This class represents the in order tree traversal algorithm that walks through an AST.\n    \"\"\"\n\n    def generic_walk(self, model):\n        self.rule(model)\n        return model\n\n    def walk_list(self, model):\n        for e in self.controlled_reverse(model, self.reverse, restore_type=True)[:-1]:\n            self(e)\n\n        self.rule(model)\n        if model:\n            self(self.controlled_reverse(model, self.reverse, restore_type=True)[-1])\n        return model\n\n    def walk_tuple(self, model):\n        for e in self.controlled_reverse(model, self.reverse, restore_type=True)[:-1]:\n            self(e)\n\n        self.rule(model)\n        if model:\n            self(self.controlled_reverse(model, self.reverse, restore_type=True)[-1])\n        return model\n\n    def walk_dict(self, model):\n        for v in list(self.controlled_reverse(model.values(), self.reverse))[:-1]:\n            self(v)\n\n        self.rule(model)\n        if model:\n            self(list(self.controlled_reverse(model.values(), self.reverse))[-1])\n        return model\n\n    def walk_VisitableBaseModel(self, model):\n        keys = [k for k in model.model_fields.keys() if k != \"class_\"]\n        keys = self.controlled_reverse(keys, self.reverse, restore_type=True)\n        for k in keys[:-1]:\n            self(getattr(model, k))\n\n        self.rule(model)\n        if keys:\n            self(getattr(model, keys[-1]))\n        return model\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html","title":"Calculator","text":"In\u00a0[1]: Copied! <pre>from __future__ import annotations\n\nfrom oqd_compiler_infrastructure import TypeReflectBaseModel\n</pre> from __future__ import annotations  from oqd_compiler_infrastructure import TypeReflectBaseModel In\u00a0[2]: Copied! <pre>class MyProgram(TypeReflectBaseModel):\n    expr: MyExpr\n</pre> class MyProgram(TypeReflectBaseModel):     expr: MyExpr In\u00a0[3]: Copied! <pre>class MyExpr(TypeReflectBaseModel):\n\n    def __add__(self, other):\n        return MyAdd(left=self, right=other)\n\n    def __mul__(self, other):\n        return MyMul(left=self, right=other)\n\n    def __pow__(self, other):\n        return MyPow(left=self, right=other)\n</pre> class MyExpr(TypeReflectBaseModel):      def __add__(self, other):         return MyAdd(left=self, right=other)      def __mul__(self, other):         return MyMul(left=self, right=other)      def __pow__(self, other):         return MyPow(left=self, right=other) In\u00a0[4]: Copied! <pre>class MyInt(MyExpr):\n    value: int\n</pre> class MyInt(MyExpr):     value: int In\u00a0[5]: Copied! <pre>class MyAdd(MyExpr):\n    left: MyExpr\n    right: MyExpr\n</pre> class MyAdd(MyExpr):     left: MyExpr     right: MyExpr In\u00a0[6]: Copied! <pre>class MyMul(MyExpr):\n    left: MyExpr\n    right: MyExpr\n</pre> class MyMul(MyExpr):     left: MyExpr     right: MyExpr In\u00a0[7]: Copied! <pre>class MyPow(MyExpr):\n    left: MyExpr\n    right: MyExpr\n</pre> class MyPow(MyExpr):     left: MyExpr     right: MyExpr In\u00a0[8]: Copied! <pre>prog = MyInt(value=1) + MyInt(value=2)\n\nprog\n</pre> prog = MyInt(value=1) + MyInt(value=2)  prog Out[8]: <pre>MyAdd(class_='MyAdd', left=MyInt(class_='MyInt', value=1), right=MyInt(class_='MyInt', value=2))</pre> In\u00a0[9]: Copied! <pre>from oqd_compiler_infrastructure import (\n    Chain,\n    ConversionRule,\n    FixedPoint,\n    Post,\n    PrettyPrint,\n    RewriteRule,\n)\n</pre> from oqd_compiler_infrastructure import (     Chain,     ConversionRule,     FixedPoint,     Post,     PrettyPrint,     RewriteRule, ) In\u00a0[10]: Copied! <pre>class Associativity(RewriteRule):\n    def map_MyAdd(self, model):\n        if isinstance(model.right, MyAdd):\n            return MyAdd(\n                left=MyAdd(left=model.left, right=model.right.left),\n                right=model.right.right,\n            )\n\n    def map_MyMul(self, model):\n        if isinstance(model.right, MyMul):\n            return MyMul(\n                left=MyMul(left=model.left, right=model.right.left),\n                right=model.right.right,\n            )\n\n\nclass Distribution(RewriteRule):\n    def map_MyMul(self, model):\n        if isinstance(model.left, MyAdd):\n            return MyAdd(\n                left=MyMul(left=model.left.left, right=model.right),\n                right=MyMul(left=model.left.right, right=model.right),\n            )\n        if isinstance(model.right, MyAdd):\n            return MyAdd(\n                left=MyMul(left=model.left, right=model.right.left),\n                right=MyMul(left=model.left, right=model.right.right),\n            )\n\n\ncanonicalization_pass = Chain(\n    FixedPoint(Post(Associativity())),\n    FixedPoint(Post(Distribution())),\n)\n</pre> class Associativity(RewriteRule):     def map_MyAdd(self, model):         if isinstance(model.right, MyAdd):             return MyAdd(                 left=MyAdd(left=model.left, right=model.right.left),                 right=model.right.right,             )      def map_MyMul(self, model):         if isinstance(model.right, MyMul):             return MyMul(                 left=MyMul(left=model.left, right=model.right.left),                 right=model.right.right,             )   class Distribution(RewriteRule):     def map_MyMul(self, model):         if isinstance(model.left, MyAdd):             return MyAdd(                 left=MyMul(left=model.left.left, right=model.right),                 right=MyMul(left=model.left.right, right=model.right),             )         if isinstance(model.right, MyAdd):             return MyAdd(                 left=MyMul(left=model.left, right=model.right.left),                 right=MyMul(left=model.left, right=model.right.right),             )   canonicalization_pass = Chain(     FixedPoint(Post(Associativity())),     FixedPoint(Post(Distribution())), ) In\u00a0[11]: Copied! <pre>class Execution(ConversionRule):\n    def map_MyInt(self, model, operands):\n        return model.value\n\n    def map_MyAdd(self, model, operands):\n        return operands[\"left\"] + operands[\"right\"]\n\n    def map_MyMul(self, model, operands):\n        return operands[\"left\"] * operands[\"right\"]\n\n    def map_MyPow(self, model, operands):\n        if operands[\"right\"] &lt; 0:\n            raise ValueError(\"Negative exponents are not supported\")\n\n        return operands[\"left\"] ** operands[\"right\"]\n\n    def map_MyProgram(self, model, operands):\n        return operands[\"expr\"]\n\n\nexecution_pass = Post(Execution())\n</pre> class Execution(ConversionRule):     def map_MyInt(self, model, operands):         return model.value      def map_MyAdd(self, model, operands):         return operands[\"left\"] + operands[\"right\"]      def map_MyMul(self, model, operands):         return operands[\"left\"] * operands[\"right\"]      def map_MyPow(self, model, operands):         if operands[\"right\"] &lt; 0:             raise ValueError(\"Negative exponents are not supported\")          return operands[\"left\"] ** operands[\"right\"]      def map_MyProgram(self, model, operands):         return operands[\"expr\"]   execution_pass = Post(Execution()) In\u00a0[12]: Copied! <pre>interpreter = Chain(canonicalization_pass, execution_pass)\n</pre> interpreter = Chain(canonicalization_pass, execution_pass) In\u00a0[13]: Copied! <pre>printer = Post(PrettyPrint())\n\nprogram = MyProgram(\n    expr=MyInt(value=1) + MyInt(value=2) * MyInt(value=3) ** MyInt(value=4)\n)\n\nresult = interpreter(program)\n\nprint(printer(result))\n</pre> printer = Post(PrettyPrint())  program = MyProgram(     expr=MyInt(value=1) + MyInt(value=2) * MyInt(value=3) ** MyInt(value=4) )  result = interpreter(program)  print(printer(result)) <pre>int(163)\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html","title":"Calculator","text":"<p>In this tutorial, we will implement a programming language for a rudimentary calculator.</p>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#language-definition","title":"Language Definition","text":"<p>In this section, we will define the algebraic data types (ADT) for the abstract syntax tree (AST) of the rudimentary calculator.</p> <p>Imports</p> <pre><code>from __future__ import annotations\n\nfrom oqd_compiler_infrastructure import TypeReflectBaseModel\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#program","title":"Program","text":"<p>This is the ADT that represents a program, the highest level construct of the programming language.</p> <p>In this rudimentary calculator, the program only consist of a single expression.</p> <pre><code>class MyProgram(TypeReflectBaseModel):\n    expr: MyExpr\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#expression","title":"Expression","text":"<p>This is the super class for mathematical expressions and consist of the operator overloading for smooth definition of an expression.</p> <pre><code>class MyExpr(TypeReflectBaseModel):\n\n    def __add__(self, other):\n        return MyAdd(left=self, right=other)\n\n    def __mul__(self, other):\n        return MyMul(left=self, right=other)\n\n    def __pow__(self, other):\n        return MyPow(left=self, right=other)\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#integer","title":"Integer","text":"<p>This is the primitive type representing an integer for the rudimentary calculator.</p> <pre><code>class MyInt(MyExpr):\n    value: int\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#operations","title":"Operations","text":"<p>This is the list of supported operations for the rudimentary calculator.</p> AdditionMultiplicationExponentiation <pre><code>class MyAdd(MyExpr):\n    left: MyExpr\n    right: MyExpr\n</code></pre> <pre><code>class MyMul(MyExpr):\n    left: MyExpr\n    right: MyExpr\n</code></pre> <pre><code>class MyPow(MyExpr):\n    left: MyExpr\n    right: MyExpr\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#intepreter-definition","title":"Intepreter Definition","text":"<p>In this section, we will define a rudimentary walking tree intepreter.</p> <p>Imports</p> <pre><code>from oqd_compiler_infrastructure import (\n    RewriteRule,\n    ConversionRule,\n    Post,\n    Chain,\n    FixedPoint,\n)\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#canonicalization","title":"Canonicalization","text":"<p>Here, we define a pass to put the expression into a canonical(standard) form that removes redundancy in our representation.</p>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#rules","title":"Rules","text":"AssociativityDistributivity \\[ \\begin{align} a + (b + c) &amp;\\rightarrow (a + b) + c \\\\ a * (b * c) &amp;\\rightarrow (a * b) * c \\end{align} \\] <pre><code>class Associativity(RewriteRule):\n    def map_MyAdd(self, model):\n        if isinstance(model.right, MyAdd):\n            return MyAdd(\n                left=MyAdd(left=model.left, right=model.right.left),\n                right=model.right.right,\n            )\n\n    def map_MyMul(self, model):\n        if isinstance(model.right, MyMul):\n            return MyMul(\n                left=MyMul(left=model.left, right=model.right.left),\n                right=model.right.right,\n            )\n</code></pre> \\[ a * (b + c) \\rightarrow a * b + a * c \\] <pre><code>class Distributivity(RewriteRule):\n    def map_MyMul(self, model):\n        if isinstance(model.left, MyAdd)):\n            return MyAdd(\n                left=MyMul(left=model.left.left, right=model.right),\n                right=MyMul(left=model.left.right, right=model.right),\n            )\n        if isinstance(model.right, MyAdd):\n            return MyAdd(\n                left=MyMul(left=model.left, right=model.right.left),\n                right=MyMul(left=model.left, right=model.right.right),\n            )\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#pass","title":"Pass","text":"<pre><code>canonicalization_pass = Chain(\n    FixedPoint(Post(Associativity())),\n    FixedPoint(Post(Distribution())),\n)\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#execution","title":"Execution","text":"<p>Definition of the execution pass to evaluate the expression.</p> <pre><code>class Execution(ConversionRule):\n    def map_MyInt(self, model, operands):\n        return model.value\n\n    def map_MyAdd(self, model, operands):\n        return operands[\"left\"] + operands[\"right\"]\n\n    def map_MyMul(self, model, operands):\n        return operands[\"left\"] * operands[\"right\"]\n\n    def map_MyPow(self, model, operands):\n        if operands[\"right\"] &lt; 0:\n            raise ValueError(\"Negative exponents are not supported\")\n\n        return operands[\"left\"] ** operands[\"right\"]\n\n    def map_MyProgram(self, model, operands):\n        return operands[\"expr\"]\n\nexecution_pass = Post(Execution())\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#interpreter","title":"Interpreter","text":"<p>The canonicalization and execution passes together to form the interpreter.</p> <pre><code>interpreter = Chain(\n    canonicalization_pass,\n    execution_pass\n)\n</code></pre>"},{"location":"open-quantum-design-compiler-infrastructure/tutorial/calculator.html#usage","title":"Usage","text":"<p>An example for program definition and interpreter execution:</p> <p>Example</p> <pre><code>program = MyProgram(\n    expr=MyInt(value=1) + MyInt(value=2) * MyInt(value=3) ** MyInt(value=4)\n)\n\nresult = interpreter(program)\n</code></pre> Terminal<pre><code>&gt;&gt;&gt; 163\n</code></pre>"},{"location":"open-quantum-design-core/index.html","title":"The Stack","text":"Open Quantum Design: Core      <p>Note</p> <p>Welcome to Open Quantum Design. This documentation is still under development, we welcome contributions! \u00a9 Open Quantum Design</p>"},{"location":"open-quantum-design-core/index.html#where-in-the-stack","title":"Where in the stack","text":"<p><pre><code>block-beta\n   columns 3\n\n   block:Interface\n       columns 1\n       InterfaceTitle(\"&lt;i&gt;&lt;b&gt;Interfaces&lt;/b&gt;&lt;i/&gt;\")\n       InterfaceDigital[\"&lt;b&gt;Digital Interface&lt;/b&gt;\\nQuantum circuits with discrete gates\"] \n       space\n       InterfaceAnalog[\"&lt;b&gt;Analog Interface&lt;/b&gt;\\n Continuous-time evolution with Hamiltonians\"] \n       space\n       InterfaceAtomic[\"&lt;b&gt;Atomic Interface&lt;/b&gt;\\nLight-matter interactions between lasers and ions\"]\n       space\n    end\n\n    block:IR\n       columns 1\n       IRTitle(\"&lt;i&gt;&lt;b&gt;IRs&lt;/b&gt;&lt;i/&gt;\")\n       IRDigital[\"Quantum circuit IR\\nopenQASM, LLVM+QIR\"] \n       space\n       IRAnalog[\"openQSIM\"]\n       space\n       IRAtomic[\"openAPL\"]\n       space\n    end\n\n    block:Emulator\n       columns 1\n       EmulatorsTitle(\"&lt;i&gt;&lt;b&gt;Classical Emulators&lt;/b&gt;&lt;i/&gt;\")\n\n       EmulatorDigital[\"Pennylane, Qiskit\"] \n       space\n       EmulatorAnalog[\"QuTiP, QuantumOptics.jl\"]\n       space\n       EmulatorAtomic[\"TrICal, QuantumIon.jl\"]\n       space\n    end\n\n    space\n    block:RealTime\n       columns 1\n       RealTimeTitle(\"&lt;i&gt;&lt;b&gt;Real-Time&lt;/b&gt;&lt;i/&gt;\")\n       space\n       RTSoftware[\"ARTIQ, DAX, OQDAX\"] \n       space\n       RTGateware[\"Sinara Real-Time Control\"]\n       space\n       RTHardware[\"Lasers, Modulators, Photodetection, Ion Trap\"]\n       space\n       RTApparatus[\"Trapped-Ion QPU (&lt;sup&gt;171&lt;/sup&gt;Yt&lt;sup&gt;+&lt;/sup&gt;, &lt;sup&gt;133&lt;/sup&gt;Ba&lt;sup&gt;+&lt;/sup&gt;)\"]\n       space\n    end\n    space\n\n   InterfaceDigital --&gt; IRDigital\n   InterfaceAnalog --&gt; IRAnalog\n   InterfaceAtomic --&gt; IRAtomic\n\n   IRDigital --&gt; IRAnalog\n   IRAnalog --&gt; IRAtomic\n\n   IRDigital --&gt; EmulatorDigital\n   IRAnalog --&gt; EmulatorAnalog\n   IRAtomic --&gt; EmulatorAtomic\n\n   IRAtomic --&gt; RealTimeTitle\n\n   RTSoftware --&gt; RTGateware\n   RTGateware --&gt; RTHardware\n   RTHardware --&gt; RTApparatus\n\n    classDef title fill:#d6d4d4,stroke:#333,color:#333;\n    classDef digital fill:#E7E08B,stroke:#333,color:#333;\n    classDef analog fill:#E4E9B2,stroke:#333,color:#333;\n    classDef atomic fill:#D2E4C4,stroke:#333,color:#333;\n    classDef realtime fill:#B5CBB7,stroke:#333,color:#333;\n\n    classDef highlight fill:#f2bbbb,stroke:#333,color:#333,stroke-dasharray: 5 5;\n\n    class InterfaceTitle,IRTitle,EmulatorsTitle,RealTimeTitle title\n    class InterfaceDigital,IRDigital,EmulatorDigital digital\n    class InterfaceAnalog,IRAnalog,EmulatorAnalog analog\n    class InterfaceAtomic,IRAtomic,EmulatorAtomic atomic\n    class RTSoftware,RTGateware,RTHardware,RTApparatus realtime\n\n   class Interface,IRAnalog,IRAtomic highlight</code></pre> The stack components highlighted in red are contained in this repository.</p>"},{"location":"open-quantum-design-core/explanation/analog_interface.html","title":"Analog","text":"<p>The analog interface represents a quantum experiment in terms of time evolving Hamiltonians.</p>"},{"location":"open-quantum-design-core/explanation/analog_interface.html#quantum-degrees-of-freedom","title":"Quantum Degrees of Freedom","text":"<p>In this analog interface, we allow for 2 different quantum degrees of freedom:</p> QubitsBosonic <p>Qubits consist of a pair of states (spin \\(\\uparrow\\) and spin \\(\\downarrow\\)).</p> <p>Bosonic degrees of freedom form a fock space.</p>"},{"location":"open-quantum-design-core/explanation/analog_interface.html#operators","title":"Operators","text":"PauliLadder <p>The basis of operators for the qubits are the Pauli operators:</p> <ul> <li>\\(\\sigma^I\\) </li> <li>\\(\\sigma^x\\) </li> <li>\\(\\sigma^y\\) </li> <li>\\(\\sigma^z\\) </li> </ul> <p>The basis of operators for the bosonic degree of freedom are the ladder operators:</p> <ul> <li>\\(a\\) </li> <li>\\(a^{\\dagger}\\) </li> <li>\\(I\\) </li> </ul>"},{"location":"open-quantum-design-core/explanation/analog_interface.html#operator-operations","title":"Operator Operations","text":"<p>The basis operators can be combined with the operations:</p> <ul> <li>Addition  </li> </ul> <ul> <li>Multiplication  </li> </ul> <ul> <li>Tensor Product  </li> </ul> <ul> <li>Scalar Multiplication  </li> </ul>"},{"location":"open-quantum-design-core/explanation/analog_interface.html#hamiltonian","title":"Hamiltonian","text":"<p>The Hamiltonian is an operator that governs interactions between quantum degrees of freedom.</p> <p>The state of the system evolves under the unitary:</p> \\[ U = e^{i H t} \\] <p>Example</p> <p>Spin-dependent force Hamiltonian:</p> \\[ H = \\sigma^+ \\otimes a + \\sigma^- \\otimes a^{\\dagger} \\] <pre><code>H = PauliPlus() @ Annihilation() + PauliMinus() @ Creation()\n</code></pre>"},{"location":"open-quantum-design-core/explanation/analog_interface.html#analog-gate","title":"Analog Gate","text":"<p>The AnalogGate wraps the Hamiltonian.</p> <pre><code>gate = AnalogGate(hamiltonian=H)\n</code></pre> <p>Note</p> <p>The purpose of the AnalogGate is to accomodate dissipation during the time evolution in the future.</p>"},{"location":"open-quantum-design-core/explanation/analog_interface.html#analog-circuit","title":"Analog Circuit","text":"<p>The AnalogCircuit is the top level structure that describes a quantum experiment at the analog layer.</p> <p>An AnalogCircuit consist of different kinds of statements:</p> InitializeEvolveMeasure <p></p> <p>Initializes all quantum degrees of freedom in the experiment:</p> <ul> <li>Qubits \\(\\rightarrow\\) \\(| \\downarrow \\rangle\\)</li> <li>Bosons \\(\\rightarrow\\) \\(| 0 \\rangle\\)</li> </ul> <p>Not Implemented</p> <p>Initialize describes a global initialization. There is no support for individual initialization currently.</p> <p></p> <p>Evolve desribes the evolution of the system with an AnalogGate for a set duration.</p> <p></p> <p>Performs a projective measurement of all quantum degrees of freedom.</p> <p>Not Implemented</p> <p>Measure describes a global measurement. There is no support for individual measurement currently.</p>"},{"location":"open-quantum-design-core/explanation/analog_interface.html#usage","title":"Usage","text":"<p>Example</p> <pre><code>circuit = AnalogCircuit()\n\ncircuit.initialize()\ncircuit.evolve(gate, duration=1)\ncircuit.measure()\n</code></pre>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html","title":"Atomic","text":"<p>The atomic interface expresses quantum information experiments in terms of light-matter interactions.</p>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#system","title":"System","text":"<p>The system describes the properties of the trapped-ion quantum device.</p>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#ion","title":"Ion","text":"<p>An ion is described by its set of electronic energy levels. Each energy level has its associated quantum numbers:</p> <ul> <li>Principal quantum number</li> <li>Spin angular momentum, \\(S\\)</li> <li>Orbital angular momentum, \\(L\\)</li> <li>Spin-orbital angular momentum, \\(J = S + L\\)</li> <li>Nuclear angular momentum, \\(I\\)</li> <li>Spin-orbital-nuclear angular momentum, \\(F = J + I\\)</li> <li>Magnetization, \\(m_F\\)</li> <li>Energy, \\(E\\)</li> </ul> <p>with the set of electronic energy levels, we assign two states to be the qubit states.</p> <p>Manipulating the qubit states involves driving transitions between the qubit states of the ions, either directly or indirectly.</p> <p>Example</p> <p>Definiition of an <code>Ion</code> for \\(^{171}\\mathrm{Yb}^+\\):</p> <pre><code>downstate = Level(\n    label=\"q0\",\n    principal=6,\n    spin=1/2,\n    orbital=0,\n    nuclear=1/2,\n    spin_orbital=1/2,\n    spin_orbital_nuclear=0,\n    spin_orbital_nuclear_magnetization=0,\n    energy=0,\n)\nupstate = Level(\n    label=\"q1\",\n    principal=6,\n    spin=1/2,\n    orbital=0,\n    nuclear=1/2,\n    spin_orbital=1/2,\n    spin_orbital_nuclear=1,\n    spin_orbital_nuclear_magnetization=0,\n    energy=2*pi*12.643e9,\n)\nestate = Level(\n    label=\"e0\",\n    principal=5,\n    spin=1/2,\n    orbital=1,\n    nuclear=1/2,\n    spin_orbital=1/2,\n    spin_orbital_nuclear=0,\n    spin_orbital_nuclear_magnetization=0,\n    energy=2*pi*811.52e12,\n)\n\nYb171 = Ion(\n    mass=171,\n    charge=1,\n    position=[0,0,0],\n    levels=[\n        downstate,\n        upstate,\n        estate,\n    ],\n    transitions=[\n        Transition(\n            label=\"q0-&gt;q1\",\n            level1=downstate,\n            level2=upstate,\n            einsteinA=...,\n        ),\n        Transition(\n            label=\"q0-&gt;e0\",\n            level1=downstate,\n            level2=estate,\n            einsteinA=...,\n        ),\n        Transition(\n            label=\"q1-&gt;e0\",\n            level1=upstate,\n            level2=estate,\n            einsteinA=...,\n        ),\n    ],\n)\n</code></pre>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#phonon","title":"Phonon","text":"<p>In the trapped-ion system the system exhibits collective phonon modes, which are bosonic degrees of freedom.</p> <p>These phonon modes are characterized by:</p> <ul> <li>Energy (eigenfrequency)</li> <li>Profile of the collective phonon mode in terms of the ions' motion (eigenvector)</li> </ul> <p>Example</p> <p>Definition of the set of phonon modes for a trapped-ion system with a single ion:</p> <pre><code>COM_x = Phonon(\n    energy=2*pi*5e6,\n    eigenvector=[1,0,0]\n)\nCOM_y = Phonon(\n    energy=2*pi*5e6,\n    eigenvector=[0,1,0]\n)\nCOM_z = Phonon(\n    energy=2*pi*1e6,\n    eigenvector=[0,0,1]\n)\n</code></pre>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#other","title":"Other","text":"<p>Not Implemented</p> <p>The system is further described by a list of experimental parameters that require calibration to determine, e.g.:</p> <ul> <li>Maximum laser power</li> <li>Laser lock frequency</li> <li>etc.</li> </ul> <p>These parameters will in the future be included in the <code>System</code>.</p> <p>The <code>System</code> will be retrieved from a calibration database to determine the current state of the system and the status of all calibrations required to run quantum experiments.</p>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#pulse-program","title":"Pulse Program","text":"<p>The pulse program for a quantum experiment is described by a <code>Protocol</code>. The protocol defines the list of optical channels in the experiment and the real-time scheduling of pulses of the optical channels in order to perform the quantum experiment.</p>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#optical-channel","title":"Optical Channel","text":"<p>An optical channel is described by a <code>Beam</code> with the following parameters:</p> <ul> <li>Transition of the ion for which to reference the Beam to.</li> <li>Rabi frequency to drive the referenced transition with.</li> <li>Detuning from the resonance of the referenced transition.</li> <li>Phase of the beam relative to the clock of the ion.</li> <li>Polarization of the beam.</li> <li>Wavevector of the beam.</li> <li>Target ion addressed by the beam.</li> </ul> <p>Example</p> <p>Beam used to drive a microwave Rabi oscillation in the X-axis:</p> <pre><code>microwave_beam = Beam(\n    transition=Transition(level1=downstate,level2=upstate,...),\n    rabi= 2*pi*1e6,\n    detuning=0,\n    phase=0,\n    polarization=...\n    wavevector=...\n    target=0\n)\n</code></pre> <p>Note</p> <p>The following parameters may be specified with the math interface:</p> <ul> <li>Rabi frequency</li> <li>Detuning</li> <li>Phase</li> </ul>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#pulse","title":"Pulse","text":"<p>A pulse turns on an optical channel for a duration of time.</p> <p>Example</p> <p>Pulse that drives a microwave Rabi oscillation in the X-axis for a duration \\(T\\):</p> <pre><code>microwave_pulse = Pulse(\n    beam=microwave_beam,\n    duration=T,\n)\n</code></pre>"},{"location":"open-quantum-design-core/explanation/atomic_interface.html#composition-of-protocols","title":"Composition of Protocols","text":"<p>The pulse program for a quantum experiment is usually more complex than a pulse of a single beam. This is handled with <code>SequentialProtocol</code> and <code>ParallelProtocol</code>.</p> <code>SequentialProtocol</code><code>ParallelProtocol</code> <p></p> <p>Sequential protocol applies a set of pulses or subprotocols sequentially in time.</p> <p>Example</p> <p>The following protocol is for a Rabi flop and a measurement:</p> <pre><code>microwave_beam = Beam(\n    transition=Transition(level1=downstate,level2=upstate,...),\n    rabi= 2*pi*1e6,\n    detuning=0,\n    phase=0,\n    polarization=...\n    wavevector=...\n    target=0\n)\n\ndetection_beam = Beam(\n    transition=Transition(level1=upstate,level2=estate,...),\n    rabi= 2*pi*1e6,\n    detuning=0,\n    phase=0,\n    polarization=...\n    wavevector=...\n    target=0\n)\n\nprotocol = SequentialProtocol(\n    sequence=[\n        Pulse(beam=raman1_beam,duration=T),\n        Pulse(beam=raman2_beam,duration=100e-6)\n        ]\n    )\n</code></pre> <p></p> <p>Sequential protocol applies a set of pulses or subprotocols parallel in time.</p> <p>Example</p> <p>The following protocol is for a two-photon Raman transition:</p> <pre><code>raman1_beam = Beam(\n    transition=Transition(level1=downstate,level2=estate,...),\n    rabi= 2*pi*1e6,\n    detuning=2*pi*1e9,\n    phase=0,\n    polarization=...\n    wavevector=...\n    target=0\n)\nraman2_beam = Beam(\n    transition=Transition(level1=upstate,level2=estate,...),\n    rabi= 2*pi*1e6,\n    detuning=2*pi*1e9,\n    phase=0,\n    polarization=...\n    wavevector=...\n    target=0\n)\n\nprotocol = ParallelProtocol(\n    sequence=[\n        Pulse(beam=raman1_beam,duration=T),\n        Pulse(beam=raman2_beam,duration=T)\n        ]\n    )\n</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html","title":"Canonicalization","text":"<p>Canonicalization is used to remove redundancy in the representation.</p> <p>Consider the following two Hamiltonians:</p> \\[ H_{1} = X \\otimes I + I \\otimes X \\] \\[ H_{2} = I \\otimes X + X \\otimes I \\] <p>\\(H_{1}\\) is equivalent to \\(H_{2}\\). Hence we convert the operators to a canonical form and the canonical form of the above operator is:</p> \\[ H_{c} = 1\\cdot(I \\otimes X) + 1\\cdot(X \\otimes I) \\] <p>These canonicalization steps (e.g. distribution) are done by implementing a <code>RewriteRule</code> with the corresponding logic.</p>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#canonicalization-rules","title":"Canonicalization Rules","text":""},{"location":"open-quantum-design-core/explanation/canonicalization.html#distribution","title":"Distribution","text":"<p><code>Distribution</code> distributes the multiplication, scalar multiplication and tensor product of operators over the addition of operators.</p> <p>Example</p> \\[X \\otimes (Y + Z) \\longrightarrow X \\otimes Y + X \\otimes Z\\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"PauliX\"):::Pauli\n    element1(\"PauliY\"):::Pauli\n    element2(\"PauliZ\"):::Pauli\n    element3(\"OperatorAdd\"):::OperatorAdd\n    element3 --&gt; element1 &amp; element2\n    element4(\"OperatorKron\"):::OperatorKron\n    element4 --&gt; element0 &amp; element3\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>    graph TD\n    element0(\"PauliX\"):::Pauli\n    element1(\"PauliY\"):::Pauli\n    element2(\"OperatorKron\"):::OperatorKron\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliX\"):::Pauli\n    element4(\"PauliZ\"):::Pauli\n    element5(\"OperatorKron\"):::OperatorKron\n    element5 --&gt; element3 &amp; element4\n    element6(\"OperatorAdd\"):::OperatorAdd\n    element6 --&gt; element2 &amp; element5\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#gather-math-expression","title":"Gather Math Expression","text":"<p><code>GatherMath</code> centralizes the coefficients of the operators by gathering them.</p> <p>Example</p> \\[ X \\times 3 \\times I \\longrightarrow 3 \\times (X \\times I)\\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"MathExpr&lt;br/&gt;--------&lt;br/&gt;expr = #quot;3#quot;\"):::MathExpr\n    element1(\"PauliX\"):::Pauli\n    element2(\"OperatorScalarMul\"):::OperatorScalarMul\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliI\"):::Pauli\n    element4(\"OperatorMul\"):::OperatorMul\n    element4 --&gt; element2 &amp; element3\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>    graph TD\n    element0(\"MathExpr&lt;br/&gt;--------&lt;br/&gt;expr = #quot;3#quot;\"):::MathExpr\n    element1(\"PauliX\"):::Pauli\n    element2(\"PauliI\"):::Pauli\n    element3(\"OperatorMul\"):::OperatorMul\n    element3 --&gt; element1 &amp; element2\n    element4(\"OperatorScalarMul\"):::OperatorScalarMul\n    element4 --&gt; element0 &amp; element3\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#proper-order","title":"Proper Order","text":"<p><code>ProperOrder</code> uses the associative property to convert a chain of <code>OperatorAdd</code> or a chain of <code>OperatorMul</code> and reorder the operation order from left to right.</p> <p>Example</p> \\[ X \\otimes (Y + Z) \\longrightarrow (X + Y) + Z \\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"PauliX\"):::Pauli\n    element1(\"PauliY\"):::Pauli\n    element2(\"PauliZ\"):::Pauli\n    element3(\"OperatorAdd\"):::OperatorAdd\n    element3 --&gt; element1 &amp; element2\n    element4(\"OperatorAdd\"):::OperatorAdd\n    element4 --&gt; element0 &amp; element3\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>    graph TD\n    element0(\"PauliX\"):::Pauli\n    element1(\"PauliY\"):::Pauli\n    element2(\"OperatorAdd\"):::OperatorAdd\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliZ\"):::Pauli\n    element4(\"OperatorAdd\"):::OperatorAdd\n    element4 --&gt; element2 &amp; element3\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#pauli-algebra","title":"Pauli Algebra","text":"<p><code>PauliAlgebra</code> applies the Pauli algebra to simplify the operator.</p> <p>Example</p> \\[ X \\times Y + I \\times I \\longrightarrow iZ + I \\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"PauliX\"):::Pauli\n    element1(\"PauliY\"):::Pauli\n    element2(\"OperatorMul\"):::OperatorMul\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliI\"):::Pauli\n    element4(\"PauliI\"):::Pauli\n    element5(\"OperatorMul\"):::OperatorMul\n    element5 --&gt; element3 &amp; element4\n    element6(\"OperatorAdd\"):::OperatorAdd\n    element6 --&gt; element2 &amp; element5\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>    graph TD\n    element0(\"MathExpr&lt;br/&gt;--------&lt;br/&gt;expr = #quot;1j#quot;\"):::MathExpr\n    element1(\"PauliZ\"):::Pauli\n    element2(\"OperatorScalarMul\"):::OperatorScalarMul\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliI\"):::Pauli\n    element4(\"OperatorAdd\"):::OperatorAdd\n    element4 --&gt; element2 &amp; element3\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#normal-order","title":"Normal Order","text":"<p><code>NormalOrder</code> puts the ladder operators into normal order.</p> <p>Example</p> \\[ C \\times A + A \\times C \\longrightarrow C \\times A + C \\times A + J\\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"Creation\"):::Ladder\n    element1(\"Annihilation\"):::Ladder\n    element2(\"OperatorMul\"):::OperatorMul\n    element2 --&gt; element0 &amp; element1\n    element3(\"Annihilation\"):::Ladder\n    element4(\"Creation\"):::Ladder\n    element5(\"OperatorMul\"):::OperatorMul\n    element5 --&gt; element3 &amp; element4\n    element6(\"OperatorAdd\"):::OperatorAdd\n    element6 --&gt; element2 &amp; element5\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>    graph TD\n    element0(\"Creation\"):::Ladder\n    element1(\"Annihilation\"):::Ladder\n    element2(\"OperatorMul\"):::OperatorMul\n    element2 --&gt; element0 &amp; element1\n    element3(\"Creation\"):::Ladder\n    element4(\"Annihilation\"):::Ladder\n    element5(\"OperatorMul\"):::OperatorMul\n    element5 --&gt; element3 &amp; element4\n    element6(\"Identity\"):::Ladder\n    element7(\"OperatorAdd\"):::OperatorAdd\n    element7 --&gt; element5 &amp; element6\n    element8(\"OperatorAdd\"):::OperatorAdd\n    element8 --&gt; element2 &amp; element7\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#prune-identity","title":"Prune Identity","text":"<p><code>PruneIdentity</code> prunes the unnecessary ladder identities from the graph.</p> <p>Example</p> \\[ C\\times A \\times J\\longrightarrow C \\times A\\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"Creation\"):::Ladder\n    element1(\"Annihilation\"):::Ladder\n    element2(\"OperatorMul\"):::OperatorMul\n    element2 --&gt; element0 &amp; element1\n    element3(\"Identity\"):::Ladder\n    element4(\"OperatorMul\"):::OperatorMul\n    element4 --&gt; element2 &amp; element3\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>    graph TD\n    element0(\"Creation\"):::Ladder\n    element1(\"Annihilation\"):::Ladder\n    element2(\"OperatorMul\"):::OperatorMul\n    element2 --&gt; element0 &amp; element1\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#sorted-order","title":"Sorted Order","text":"<p><code>SortedOrder</code> sorts the addition terms in operators into a predefined order.</p> <p>Example</p> \\[ X \\otimes I + I \\otimes X \\longrightarrow I \\otimes X + X \\otimes I\\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"PauliX\"):::Pauli\n    element1(\"PauliI\"):::Pauli\n    element2(\"OperatorKron\"):::OperatorKron\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliI\"):::Pauli\n    element4(\"PauliX\"):::Pauli\n    element5(\"OperatorKron\"):::OperatorKron\n    element5 --&gt; element3 &amp; element4\n    element6(\"OperatorAdd\"):::OperatorAdd\n    element6 --&gt; element2 &amp; element5\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>    graph TD\n    element0(\"PauliI\"):::Pauli\n    element1(\"PauliX\"):::Pauli\n    element2(\"OperatorKron\"):::OperatorKron\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliX\"):::Pauli\n    element4(\"PauliI\"):::Pauli\n    element5(\"OperatorKron\"):::OperatorKron\n    element5 --&gt; element3 &amp; element4\n    element6(\"OperatorAdd\"):::OperatorAdd\n    element6 --&gt; element2 &amp; element5\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#scale-terms","title":"Scale Terms","text":"<p><code>ScaleTerms</code> introduces scalar multiplication to terms without a coefficient for a more consistent reprensentation.</p> <p>Example</p> \\[ I \\otimes X + X \\otimes I \\longrightarrow 1*(I \\otimes X) + 1*(X \\otimes I)\\] Original GraphTransformed Graph <pre><code>    graph TD\n    element0(\"PauliI\"):::Pauli\n    element1(\"PauliX\"):::Pauli\n    element2(\"OperatorKron\"):::OperatorKron\n    element2 --&gt; element0 &amp; element1\n    element3(\"PauliX\"):::Pauli\n    element4(\"PauliI\"):::Pauli\n    element5(\"OperatorKron\"):::OperatorKron\n    element5 --&gt; element3 &amp; element4\n    element6(\"OperatorAdd\"):::OperatorAdd\n    element6 --&gt; element2 &amp; element5\n    classDef Pauli stroke:#800000,stroke-width:3px\n    classDef Ladder stroke:#800000,stroke-width:3px\n    classDef OperatorAdd stroke:#800000,stroke-width:3px\n    classDef OperatorScalarMul stroke:#800000,stroke-width:3px\n    classDef OperatorKron stroke:#800000,stroke-width:3px\n    classDef OperatorMul stroke:#800000,stroke-width:3px\n    classDef MathExpr stroke:#800000,stroke-width:3px</code></pre> <pre><code>graph TD\nelement0(\"MathExpr&lt;br/&gt;--------&lt;br/&gt;expr = #quot;1#quot;\"):::MathExpr\nelement1(\"PauliI\"):::Pauli\nelement2(\"PauliX\"):::Pauli\nelement3(\"OperatorKron\"):::OperatorKron\nelement3 --&gt; element1 &amp; element2\nelement4(\"OperatorScalarMul\"):::OperatorScalarMul\nelement4 --&gt; element0 &amp; element3\nelement5(\"MathExpr&lt;br/&gt;--------&lt;br/&gt;expr = #quot;1#quot;\"):::MathExpr\nelement6(\"PauliX\"):::Pauli\nelement7(\"PauliI\"):::Pauli\nelement8(\"OperatorKron\"):::OperatorKron\nelement8 --&gt; element6 &amp; element7\nelement9(\"OperatorScalarMul\"):::OperatorScalarMul\nelement9 --&gt; element5 &amp; element8\nelement10(\"OperatorAdd\"):::OperatorAdd\nelement10 --&gt; element4 &amp; element9\nclassDef Pauli stroke:#800000,stroke-width:3px\nclassDef Ladder stroke:#800000,stroke-width:3px\nclassDef OperatorAdd stroke:#800000,stroke-width:3px\nclassDef OperatorScalarMul stroke:#800000,stroke-width:3px\nclassDef OperatorKron stroke:#800000,stroke-width:3px\nclassDef OperatorMul stroke:#800000,stroke-width:3px\nclassDef MathExpr stroke:#800000,stroke-width:3px</code></pre>"},{"location":"open-quantum-design-core/explanation/canonicalization.html#canonicalization-pass","title":"Canonicalization Pass","text":"<pre><code>stateDiagram-v2\n\n[*] --&gt; distribution_pass: done\ndistribution_pass --&gt; ProperOrder: done\nProperOrder --&gt; pauli_algebra_pass: done\npauli_algebra_pass --&gt; GatherPauli: done\nGatherPauli --&gt; VerifyHilbertSpaceDim: done\nVerifyHilbertSpaceDim --&gt; normal_order_pass: done\nnormal_order_pass --&gt; PruneIdentity: pass\nPruneIdentity --&gt; scale_terms_pass: done\nscale_terms_pass --&gt; SortedOrder: done\nSortedOrder --&gt; math_canonicalization_pass: done\nmath_canonicalization_pass --&gt; end: done</code></pre>"},{"location":"open-quantum-design-core/explanation/math_interface.html","title":"Math","text":"<p>The math interface is utilized to specify arbitrary profiles for operands in other interfaces.</p>"},{"location":"open-quantum-design-core/explanation/math_interface.html#math-expression","title":"Math Expression","text":"<p>MathExpr represents a mathematical expression.</p>"},{"location":"open-quantum-design-core/explanation/math_interface.html#primitives","title":"Primitives","text":"<p>The primitives of the math interface consist of:</p> <code>MathNum</code><code>MathImag</code><code>MathVar</code> <p></p> <p><code>MathNum</code> represents a number.</p> <p>Note</p> <p>Numbers are considered to belong to the real numbers, i.e. they can be positive or negative floats.</p> <p></p> <p><code>MathImag</code> represents the imaginary unit.</p> <p></p> <p><code>MathVar</code> represents a protected named variable to be substituted during compile time or runtime.</p>"},{"location":"open-quantum-design-core/explanation/math_interface.html#operators","title":"Operators","text":"<p>The compatible operators for the math interface consist of:</p> <code>MathAdd</code><code>MathMul</code><code>MathPow</code><code>MathSub</code><code>MathDiv</code><code>MathFunc</code> <p></p> <p><code>MathAdd</code> represents an addition of two expressions.</p> <p></p> <p><code>MathMul</code> represents an multiplication of two expressions.</p> <p></p> <p><code>MathPow</code> represents an exponentiation of an expression with the other expression.</p> <p></p> <p><code>MathSub</code> represents an subtraction of two expressions.</p> <p></p> <p><code>MathDiv</code> represents an division of two expressions.</p> <p></p> <p><code>MathFunc</code> represents the application of a named function on an expression.</p> <p>The compatible named functions include:</p> <ul> <li>trigonometric (<code>sin</code>, <code>cos</code>, <code>tan</code>)</li> <li>hyperbolic trigonometric (<code>sinh</code>, <code>cosh</code>, <code>tanh</code>)</li> <li>exponential (<code>exp</code>)</li> <li>logarithm (<code>log</code>)</li> </ul>"},{"location":"open-quantum-design-core/explanation/math_interface.html#usage","title":"Usage","text":"<p>Example</p> \\[ 10 \\sin^2(\\omega t + \\phi) \\] <pre><code>expr = (\n    10\n    * MathFunc(\n        func=\"sin\", expr=MathVar(name=\"omega\") * MathVar(name=\"t\") + MathVar(name=\"phi\")\n    )\n    ** 2\n)\n</code></pre>"},{"location":"open-quantum-design-core/get-started/acknowledgement.html","title":"Acknowledgement","text":"<p>This package was heavily inspired by the following packages:</p>"},{"location":"open-quantum-design-core/get-started/acknowledgement.html#liangjl","title":"Liang.jl","text":""},{"location":"open-quantum-design-core/get-started/acknowledgement.html#bloqade","title":"Bloqade","text":"<pre><code>@misc{bloqade2023quera,\n  url = {https://github.com/QuEraComputing/Bloqade.jl/},\n  title = {Bloqade.jl: {P}ackage for the quantum computation and quantum simulation based on the neutral-atom architecture.},\n  year = {2023}\n}\n</code></pre>"},{"location":"open-quantum-design-core/get-started/acknowledgement.html#bloqade-python","title":"Bloqade-python","text":"<pre><code>@software{bloqade_2024_11114110,\n  author    = {Weinberg, Phillip and Wu, Kai-Hsin and John Long and Luo, Xiu-zhe (Roger)},\n  title     = {QuEraComputing/bloqade-python: v0.15.11},\n  month     = may,\n  year      = 2024,\n  publisher = {Zenodo},\n  version   = {v0.15.11},\n  doi       = {10.5281/zenodo.11114110},\n  url       = {https://doi.org/10.5281/zenodo.11114110}\n}\n</code></pre>"},{"location":"open-quantum-design-core/get-started/installation.html","title":"Installation","text":"<p>Dependency</p> <p>First install the oqd-compiler-infrastructure package. <pre><code>pip install git+https://github.com/OpenQuantumDesign/oqd-compiler-infrastructure.git\n</code></pre></p> <p>To install via <code>pip</code>,</p> <pre><code>pip install git+https://github.com/OpenQuantumDesign/oqd-core.git\n</code></pre> <p>To clone the repository locally:</p> <pre><code>git clone https://github.com/OpenQuantumDesign/oqd-core.git\n</code></pre> <p>Install the folder locally with <code>pip</code> and add to the</p> <pre><code>pip install .\nexport PYTHONPATH=$PYTHONPATH:PATH-TO-PACKAGE\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html","title":"Canonicalization","text":""},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#passes","title":"Passes","text":""},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.passes.canonicalize","title":"<code>oqd_core.compiler.analog.passes.canonicalize</code>","text":""},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.passes.canonicalize.analog_operator_canonicalization","title":"<code>analog_operator_canonicalization(model)</code>","text":"<p>This pass runs canonicalization chain for Operators with a verifies for canonicalization.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> <p><code>Operator</code> of Analog level are in canonical form</p> Assumptions <p>None</p> Example <ul> <li>for model = X@(Y + Z), output is 1*(X@Y) + 1 * (X@Z)</li> <li>for model = [<code>AnalogGate</code>][oqd_core.interface.analog.operations.AnalogGate](hamiltonian = (A * J)@X), output is     [<code>AnalogGate</code>][oqd_core.interface.analog.operations.AnalogGate](hamiltonian = 1 * (X@A))     (where A = Annhiliation(), J = Identity() [Ladder])</li> </ul> Acknowledgement <p>This code was inspired by Liang.jl.</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/passes/canonicalize.py</code> <pre><code>def analog_operator_canonicalization(model):\n    \"\"\"\n    This pass runs canonicalization chain for Operators with a verifies for canonicalization.\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel):  [`Operator`][oqd_core.interface.analog.operator.Operator] of Analog level are in canonical form\n\n    Assumptions:\n        None\n\n    Example:\n        - for model = X@(Y + Z), output is 1*(X@Y) + 1 * (X@Z)\n        - for model = [`AnalogGate`][oqd_core.interface.analog.operations.AnalogGate](hamiltonian = (A * J)@X), output is\n            [`AnalogGate`][oqd_core.interface.analog.operations.AnalogGate](hamiltonian = 1 * (X@A))\n            (where A = Annhiliation(), J = Identity() [Ladder])\n\n    Acknowledgement:\n        This code was inspired by [Liang.jl](https://github.com/Roger-luo/Liang.jl/blob/main/src/canonicalize/entry.jl#L8).\n    \"\"\"\n    return Chain(\n        FixedPoint(dist_chain),\n        FixedPoint(Post(ProperOrder())),\n        FixedPoint(pauli_chain),\n        FixedPoint(Post(GatherPauli())),\n        In(VerifyHilberSpaceDim(), reverse=True),\n        FixedPoint(normal_order_chain),\n        FixedPoint(Post(PruneIdentity())),\n        FixedPoint(scale_terms_chain),\n        FixedPoint(Post(SortedOrder())),\n        math_chain,\n        verify_canonicalization,\n    )(model=model)\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#rewrite-rules","title":"Rewrite Rules","text":""},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize","title":"<code>oqd_core.compiler.analog.rewrite.canonicalize</code>","text":""},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute","title":"<code>OperatorDistribute</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>RewriteRule which distributes operators of hamiltonians</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>GatherMathExpr</code> (sometimes)</p> Example <p>X@(Y+Z) =&gt; X@Y + X@Z</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class OperatorDistribute(RewriteRule):\n    \"\"\"\n    RewriteRule which distributes operators of hamiltonians\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr] (sometimes)\n\n    Example:\n        X@(Y+Z) =&gt; X@Y + X@Z\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if isinstance(model.op1, (OperatorAdd, OperatorSub)):\n            return model.op1.__class__(\n                op1=OperatorMul(op1=model.op1.op1, op2=model.op2),\n                op2=OperatorMul(op1=model.op1.op2, op2=model.op2),\n            )\n        if isinstance(model.op2, (OperatorAdd, OperatorSub)):\n            return model.op2.__class__(\n                op1=OperatorMul(op1=model.op1, op2=model.op2.op1),\n                op2=OperatorMul(op1=model.op1, op2=model.op2.op2),\n            )\n        if isinstance(model.op1, (OperatorKron)) and isinstance(\n            model.op2, (OperatorKron)\n        ):\n            return OperatorKron(\n                op1=OperatorMul(op1=model.op1.op1, op2=model.op2.op1),\n                op2=OperatorMul(op1=model.op1.op2, op2=model.op2.op2),\n            )\n        return None\n\n    def map_OperatorKron(self, model: OperatorKron):\n        if isinstance(model.op1, (OperatorAdd, OperatorSub)):\n            return model.op1.__class__(\n                op1=OperatorKron(op1=model.op1.op1, op2=model.op2),\n                op2=OperatorKron(op1=model.op1.op2, op2=model.op2),\n            )\n        if isinstance(model.op2, (OperatorAdd, OperatorSub)):\n            return model.op2.__class__(\n                op1=OperatorKron(op1=model.op1, op2=model.op2.op1),\n                op2=OperatorKron(op1=model.op1, op2=model.op2.op2),\n            )\n        return None\n\n    def map_OperatorScalarMul(self, model: OperatorScalarMul):\n        if isinstance(model.op, (OperatorAdd, OperatorSub)):\n            return model.op.__class__(\n                op1=OperatorScalarMul(op=model.op.op1, expr=model.expr),\n                op2=OperatorScalarMul(op=model.op.op2, expr=model.expr),\n            )\n        return None\n\n    def map_OperatorSub(self, model: OperatorSub):\n        return OperatorAdd(\n            op1=model.op1,\n            op2=OperatorScalarMul(op=model.op2, expr=MathNum(value=-1)),\n        )\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr","title":"<code>GatherMathExpr</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Gathers the math expressions of  <code>Operator</code> so that we have math_expr * ( <code>Operator</code> without scalar multiplication)</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only modifies <code>Operator</code> in Analog level.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>OperatorDistribute</code> (sometimes)</p> Example <p>(1 * X) @ (2 * Y) =&gt; (1 * 2) =&gt; (1 * 2) * (X @ Y)</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class GatherMathExpr(RewriteRule):\n    \"\"\"\n    Gathers the math expressions of  [`Operator`][oqd_core.interface.analog.operator.Operator] so that we have math_expr * ( [`Operator`][oqd_core.interface.analog.operator.Operator] without scalar multiplication)\n\n    Args:\n        model (VisitableBaseModel):\n            The rule only modifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level.\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute] (sometimes)\n\n    Example:\n        (1 * X) @ (2 * Y) =&gt; (1 * 2) =&gt; (1 * 2) * (X @ Y)\n    \"\"\"\n\n    def map_OperatorScalarMul(self, model: OperatorScalarMul):\n        if isinstance(model.op, OperatorScalarMul):\n            return model.expr * model.op.expr * model.op.op\n\n        return None\n\n    def map_OperatorMul(self, model: OperatorMul):\n        return self._mulkron(model)\n\n    def map_OperatorKron(self, model: OperatorKron):\n        return self._mulkron(model)\n\n    def _mulkron(self, model: Union[OperatorMul, OperatorKron]):\n        if isinstance(model.op1, OperatorScalarMul) and isinstance(\n            model.op2, OperatorScalarMul\n        ):\n            return (\n                model.op1.expr\n                * model.op2.expr\n                * model.__class__(op1=model.op1.op, op2=model.op2.op)\n            )\n        if isinstance(model.op1, OperatorScalarMul):\n            return model.op1.expr * model.__class__(op1=model.op1.op, op2=model.op2)\n\n        if isinstance(model.op2, OperatorScalarMul):\n            return model.op2.expr * model.__class__(op1=model.op1, op2=model.op2.op)\n        return None\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.GatherPauli","title":"<code>GatherPauli</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Gathers ladders and paulis so that we have paulis and then ladders</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only modifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code> <code>Operator</code></p> Example <p>X@A@Y =&gt; X@Y@A</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class GatherPauli(RewriteRule):\n    \"\"\"\n    Gathers ladders and paulis so that we have paulis and then ladders\n\n    Args:\n        model (VisitableBaseModel):\n            The rule only modifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder]\n        [`Operator`][oqd_core.interface.analog.operator.Operator]\n\n    Example:\n        X@A@Y =&gt; X@Y@A\n    \"\"\"\n\n    def map_OperatorKron(self, model: OperatorKron):\n        if isinstance(model.op2, Pauli):\n            if isinstance(model.op1, Ladder):\n                return OperatorKron(\n                    op1=model.op2,\n                    op2=model.op1,\n                )\n            if isinstance(model.op1, OperatorMul) and isinstance(model.op1.op2, Ladder):\n                return OperatorKron(\n                    op1=model.op2,\n                    op2=model.op1,\n                )\n            if isinstance(model.op1, OperatorKron) and isinstance(\n                model.op1.op2, Union[Ladder, OperatorMul]\n            ):\n                return OperatorKron(\n                    op1=OperatorKron(op1=model.op1.op1, op2=model.op2),\n                    op2=model.op1.op2,\n                )\n        return None\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.PruneIdentity","title":"<code>PruneIdentity</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Removes unnecessary ladder Identities from operators</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>GatherPauli</code>, <code>NormalOrder</code></p> Example <p>A*J =&gt; A</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class PruneIdentity(RewriteRule):\n    \"\"\"\n    Removes unnecessary ladder Identities from operators\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`GatherPauli`][oqd_core.compiler.analog.rewrite.canonicalize.GatherPauli],\n        [`NormalOrder`][oqd_core.compiler.analog.rewrite.canonicalize.NormalOrder]\n\n    Example:\n        A*J =&gt; A\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if isinstance(model.op1, (Identity)):\n            return model.op2\n        if isinstance(model.op2, (Identity)):\n            return model.op1\n        return None\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.PauliAlgebra","title":"<code>PauliAlgebra</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>RewriteRule for Pauli algebra operations</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code></p> Example <p>X*Y =&gt; iZ</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class PauliAlgebra(RewriteRule):\n    \"\"\"\n    RewriteRule for Pauli algebra operations\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder]\n\n    Example:\n        X*Y =&gt; iZ\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if isinstance(model.op1, Pauli) and isinstance(model.op2, Pauli):\n            if isinstance(model.op1, PauliI):\n                return model.op2\n            if isinstance(model.op2, PauliI):\n                return model.op1\n            if model.op1 == model.op2:\n                return PauliI()\n            if isinstance(model.op1, PauliX) and isinstance(model.op2, PauliY):\n                return OperatorScalarMul(op=PauliZ(), expr=MathImag())\n            if isinstance(model.op1, PauliY) and isinstance(model.op2, PauliZ):\n                return OperatorScalarMul(op=PauliX(), expr=MathImag())\n            if isinstance(model.op1, PauliZ) and isinstance(model.op2, PauliX):\n                return OperatorScalarMul(op=PauliY(), expr=MathImag())\n            return OperatorScalarMul(\n                op=OperatorMul(op1=model.op2, op2=model.op1),\n                expr=MathNum(value=-1),\n            )\n        return None\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.NormalOrder","title":"<code>NormalOrder</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Arranges Ladder oeprators in normal order form</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>GatherPauli</code></p> Example <p>AC =&gt; CA + J</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class NormalOrder(RewriteRule):\n    \"\"\"\n    Arranges Ladder oeprators in normal order form\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`GatherPauli`][oqd_core.compiler.analog.rewrite.canonicalize.GatherPauli]\n\n    Example:\n        A*C =&gt; C*A + J\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if isinstance(model.op2, Creation):\n            if isinstance(model.op1, Annihilation):\n                return OperatorAdd(\n                    op1=OperatorMul(op1=model.op2, op2=model.op1), op2=Identity()\n                )\n            if isinstance(model.op1, Identity):\n                return OperatorMul(op1=model.op2, op2=model.op1)\n            if isinstance(model.op1, OperatorMul) and isinstance(\n                model.op1.op2, (Annihilation, Identity)\n            ):\n                return OperatorMul(\n                    op1=model.op1.op1,\n                    op2=OperatorMul(op1=model.op1.op2, op2=model.op2),\n                )\n        return model\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder","title":"<code>ProperOrder</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Converts expressions to proper order bracketing. Please see example for clarification.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code></p> Example <p>X @ (Y @ Z) =&gt;  (X @ Y) @ Z</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class ProperOrder(RewriteRule):\n    \"\"\"\n    Converts expressions to proper order bracketing. Please see example for clarification.\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute]\n\n    Example:\n        X @ (Y @ Z) =&gt;  (X @ Y) @ Z\n    \"\"\"\n\n    def map_OperatorAdd(self, model: OperatorAdd):\n        return self._addmullkron(model=model)\n\n    def map_OperatorMul(self, model: OperatorMul):\n        return self._addmullkron(model=model)\n\n    def map_OperatorKron(self, model: OperatorKron):\n        return self._addmullkron(model=model)\n\n    def _addmullkron(self, model: Union[OperatorAdd, OperatorMul, OperatorKron]):\n        if isinstance(model.op2, model.__class__):\n            return model.__class__(\n                op1=model.__class__(op1=model.op1, op2=model.op2.op1),\n                op2=model.op2.op2,\n            )\n        return model.__class__(op1=model.op1, op2=model.op2)\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.ScaleTerms","title":"<code>ScaleTerms</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Scales operators to ensure consistency</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseModel</code> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>GatherPauli</code>, <code>NormalOrder</code>, <code>PruneIdentity</code></p> Note <ul> <li>Requires <code>GatherMathExpr</code> right after application of <code>ScaleTerms</code>  for Post walk</li> <li><code>SortedOrder</code> and  <code>ScaleTerms</code> can be run in either order</li> </ul> Example <p>X + Y + 2Z =&gt; 1X + 1Y + 2Z X@Y =&gt; 1*(X@Y)</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class ScaleTerms(RewriteRule):\n    \"\"\"\n    Scales operators to ensure consistency\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel):\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`GatherPauli`][oqd_core.compiler.analog.rewrite.canonicalize.GatherPauli],\n        [`NormalOrder`][oqd_core.compiler.analog.rewrite.canonicalize.NormalOrder],\n        [`PruneIdentity`][oqd_core.compiler.analog.rewrite.canonicalize.PruneIdentity]\n\n    Note:\n        - Requires [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr] right after application of [`ScaleTerms`][oqd_core.compiler.analog.rewrite.canonicalize.ScaleTerms]  for Post walk\n        - [`SortedOrder`][oqd_core.compiler.analog.rewrite.canonicalize.SortedOrder] and  [`ScaleTerms`][oqd_core.compiler.analog.rewrite.canonicalize.ScaleTerms] can be run in either order\n\n    Example:\n        X + Y + 2*Z =&gt; 1*X + 1*Y + 2*Z\n        X@Y =&gt; 1*(X@Y)\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.op_add_root = False\n\n    def map_AnalogGate(self, model):\n        self.op_add_root = False\n\n    def map_Expectation(self, model):\n        self.op_add_root = False\n\n    def map_Operator(self, model: Operator):\n        if not self.op_add_root:\n            self.op_add_root = True\n            if not isinstance(model, Union[OperatorAdd, OperatorScalarMul]):\n                return OperatorScalarMul(expr=MathNum(value=1), op=model)\n\n    def map_OperatorAdd(self, model: OperatorAdd):\n        self.op_add_root = True\n        op1, op2 = model.op1, model.op2\n        if not isinstance(model.op1, Union[OperatorScalarMul, OperatorAdd]):\n            op1 = OperatorScalarMul(expr=MathNum(value=1), op=model.op1)\n        if not isinstance(model.op2, Union[OperatorScalarMul, OperatorAdd]):\n            op2 = OperatorScalarMul(expr=MathNum(value=1), op=model.op2)\n        return OperatorAdd(op1=op1, op2=op2)\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.rewrite.canonicalize.SortedOrder","title":"<code>SortedOrder</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Sorts operators based on TermIndex and collects duplicate terms. Please see example for clarification</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> required <p>Returns:</p> Type Description <p>model (VisitableBaseModel)</p> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>GatherPauli</code>, <code>NormalOrder</code>, <code>PruneIdentity</code></p> Note <ul> <li><code>SortedOrder</code> and  <code>ScaleTerms</code> can be run in either order</li> </ul> Example <p>(X@Y) + (X@I) =&gt; (X@I) + (X@Y) X + I + Z + Y =&gt; I + X + Y + Z</p> Source code in <code>oqd-core/src/oqd_core/compiler/analog/rewrite/canonicalize.py</code> <pre><code>class SortedOrder(RewriteRule):\n    \"\"\"\n    Sorts operators based on TermIndex and collects duplicate terms.\n    Please see example for clarification\n\n    Args:\n        model (VisitableBaseModel):\n\n    Returns:\n        model (VisitableBaseModel)\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`GatherPauli`][oqd_core.compiler.analog.rewrite.canonicalize.GatherPauli],\n        [`NormalOrder`][oqd_core.compiler.analog.rewrite.canonicalize.NormalOrder],\n        [`PruneIdentity`][oqd_core.compiler.analog.rewrite.canonicalize.PruneIdentity]\n\n    Note:\n        - [`SortedOrder`][oqd_core.compiler.analog.rewrite.canonicalize.SortedOrder] and  [`ScaleTerms`][oqd_core.compiler.analog.rewrite.canonicalize.ScaleTerms] can be run in either order\n\n    Example:\n        (X@Y) + (X@I) =&gt; (X@I) + (X@Y)\n        X + I + Z + Y =&gt; I + X + Y + Z\n    \"\"\"\n\n    def map_OperatorAdd(self, model: OperatorAdd):\n        if isinstance(model.op1, OperatorAdd):\n            term1 = analysis_term_index(model.op1.op2)\n            term2 = analysis_term_index(model.op2)\n\n            if term1 == term2:\n                expr1 = (\n                    model.op1.op2.expr\n                    if isinstance(model.op1.op2, OperatorScalarMul)\n                    else MathNum(value=1)\n                )\n                expr2 = (\n                    model.op2.expr\n                    if isinstance(model.op2, OperatorScalarMul)\n                    else MathNum(value=1)\n                )\n                op = (\n                    model.op2.op\n                    if isinstance(model.op2, OperatorScalarMul)\n                    else model.op2\n                )\n                return OperatorAdd(\n                    op1=model.op1.op1,\n                    op2=OperatorScalarMul(\n                        op=op, expr=MathAdd(expr1=expr1, expr2=expr2)\n                    ),\n                )\n\n            elif term1 &gt; term2:\n                return OperatorAdd(\n                    op1=OperatorAdd(op1=model.op1.op1, op2=model.op2),\n                    op2=model.op1.op2,\n                )\n\n            elif term1 &lt; term2:\n                return OperatorAdd(op1=model.op1, op2=model.op2)\n\n        else:\n            term1 = analysis_term_index(model.op1)\n            term2 = analysis_term_index(model.op2)\n\n            if term1 == term2:\n                expr1 = (\n                    model.op1.expr\n                    if isinstance(model.op1, OperatorScalarMul)\n                    else MathNum(value=1)\n                )\n                expr2 = (\n                    model.op2.expr\n                    if isinstance(model.op2, OperatorScalarMul)\n                    else MathNum(value=1)\n                )\n                op = (\n                    model.op2.op\n                    if isinstance(model.op2, OperatorScalarMul)\n                    else model.op2\n                )\n                return OperatorScalarMul(op=op, expr=MathAdd(expr1=expr1, expr2=expr2))\n\n            elif term1 &gt; term2:\n                return OperatorAdd(\n                    op1=model.op2,\n                    op2=model.op1,\n                )\n\n            elif term1 &lt; term2:\n                return OperatorAdd(op1=model.op1, op2=model.op2)\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#verification-rules","title":"Verification Rules","text":""},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize","title":"<code>oqd_core.compiler.analog.verify.canonicalize</code>","text":""},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerPauliAlgebra","title":"<code>CanVerPauliAlgebra</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks whether there is any incomplete Pauli Algebra computation</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code></p> Example <ul> <li>X@(Y*Z) =&gt; fail</li> <li>X@Y =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerPauliAlgebra(RewriteRule):\n    \"\"\"\n    Checks whether there is any incomplete Pauli Algebra computation\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder]\n\n    Example:\n        - X@(Y*Z) =&gt; fail\n        - X@Y =&gt; pass\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if isinstance(model.op1, Pauli) and isinstance(model.op2, Pauli):\n            raise CanonicalFormError(\"Incomplete Pauli Algebra\")\n        elif isinstance(model.op1, Pauli) and isinstance(model.op2, Ladder):\n            raise CanonicalFormError(\"Incorrect Ladder and Pauli multiplication\")\n        elif isinstance(model.op1, Ladder) and isinstance(model.op2, Pauli):\n            raise CanonicalFormError(\"Incorrect Ladder and Pauli multiplication\")\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerGatherMathExpr","title":"<code>CanVerGatherMathExpr</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks whether all MathExpr have been gathered (i.e. basically checks whether there is any scalar multiplication within a term)</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p>OperatorDistribute <code>OperatorDistribute</code></p> Example <ul> <li>X@(1*Z) =&gt; fail</li> <li>1*(X@Z) =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerGatherMathExpr(RewriteRule):\n    \"\"\"\n    Checks whether all MathExpr have been gathered (i.e. basically checks whether\n    there is any scalar multiplication within a term)\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        OperatorDistribute\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute]\n\n    Example:\n        - X@(1*Z) =&gt; fail\n        - 1*(X@Z) =&gt; pass\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        return self._mulkron(model)\n\n    def map_OperatorKron(self, model: OperatorKron):\n        return self._mulkron(model)\n\n    def _mulkron(self, model: Union[OperatorMul, OperatorKron]):\n        if isinstance(model.op1, OperatorScalarMul) or isinstance(\n            model.op2, OperatorScalarMul\n        ):\n            raise CanonicalFormError(\"Incomplete Gather Math Expression\")\n        return None\n\n    def map_OperatorScalarMul(self, model: OperatorScalarMul):\n        if isinstance(model.op, OperatorScalarMul):\n            raise CanonicalFormError(\n                \"Incomplete scalar multiplications after GatherMathExpression\"\n            )\n        return None\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerOperatorDistribute","title":"<code>CanVerOperatorDistribute</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks for incomplete distribution of Operators</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p>None</p> Example <ul> <li>X@(Y+Z) =&gt; fail</li> <li>X@Y + X@Z =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerOperatorDistribute(RewriteRule):\n    \"\"\"\n    Checks for incomplete distribution of Operators\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        None\n\n    Example:\n        - X@(Y+Z) =&gt; fail\n        - X@Y + X@Z =&gt; pass\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.allowed_ops = Union[\n            OperatorTerminal,\n            Ladder,\n            OperatorMul,\n            OperatorScalarMul,\n            OperatorKron,\n        ]\n\n    def map_OperatorMul(self, model):\n        return self._OperatorMulKron(model)\n\n    def map_OperatorKron(self, model):\n        return self._OperatorMulKron(model)\n\n    def _OperatorMulKron(self, model: Union[OperatorMul, OperatorKron]):\n        if (\n            isinstance(model, OperatorMul)\n            and isinstance(model.op1, OperatorKron)\n            and isinstance(model.op2, OperatorKron)\n        ):\n            raise CanonicalFormError(\n                \"Incomplete Operator Distribution (multiplication of OperatorKron present)\"\n            )\n        elif not (\n            isinstance(model.op1, self.allowed_ops)\n            and isinstance(model.op2, self.allowed_ops)\n        ):\n            raise CanonicalFormError(\"Incomplete Operator Distribution\")\n\n        pass\n\n    def map_OperatorScalarMul(self, model: OperatorScalarMul):\n        if not (isinstance(model.op, self.allowed_ops)):\n            raise CanonicalFormError(\n                \"Scalar multiplication of operators not simplified fully\"\n            )\n        pass\n\n    def map_OperatorSub(self, model: OperatorSub):\n        if isinstance(model, OperatorSub):\n            raise CanonicalFormError(\"Subtraction of terms present\")\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerProperOrder","title":"<code>CanVerProperOrder</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks whether all Operators are ProperOrdered according to how they are bracketed Please see example for clarification</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p>None</p> Example <ul> <li>X@(Y@Z) =&gt; fail</li> <li>(X@Y)@Z =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerProperOrder(RewriteRule):\n    \"\"\"\n    Checks whether all Operators are ProperOrdered according to how they are bracketed\n    Please see example for clarification\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        None\n\n    Example:\n        - X@(Y@Z) =&gt; fail\n        - (X@Y)@Z =&gt; pass\n    \"\"\"\n\n    def map_OperatorAdd(self, model: OperatorAdd):\n        self._OperatorAddMulKron(model)\n        pass\n\n    def map_OperatorMul(self, model: OperatorMul):\n        self._OperatorAddMulKron(model)\n        pass\n\n    def map_OperatorKron(self, model: OperatorKron):\n        self._OperatorAddMulKron(model)\n        pass\n\n    def _OperatorAddMulKron(self, model: Union[OperatorAdd, OperatorMul, OperatorKron]):\n        if isinstance(model.op2, model.__class__):\n            raise CanonicalFormError(\"Incorrect Proper Ordering\")\n        pass\n\n    def map_OperatorScalarMul(self, model: OperatorScalarMul):\n        if isinstance(model.op, model.__class__):\n            raise CanonicalFormError(\n                \"Incorrect Proper Ordering (for scalar multiplication)\"\n            )\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerPruneIdentity","title":"<code>CanVerPruneIdentity</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks if there is any ladder Identity present in ladder multiplication</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p>OperatorDistribute <code>OperatorDistribute</code></p> Example <ul> <li>AJC =&gt; fail</li> <li>A*C =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerPruneIdentity(RewriteRule):\n    \"\"\"\n    Checks if there is any ladder Identity present in ladder multiplication\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        OperatorDistribute\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute]\n\n    Example:\n        - A*J*C =&gt; fail\n        - A*C =&gt; pass\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if isinstance(model.op1, Identity) or isinstance(model.op2, Identity):\n            raise CanonicalFormError(\"Prune Identity is not complete\")\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerGatherPauli","title":"<code>CanVerGatherPauli</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks whether pauli and ladder have been separated.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>PauliAlgebra</code></p> Example <ul> <li>X@A@Y =&gt; fail</li> <li>X@Y@A =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerGatherPauli(RewriteRule):\n    \"\"\"\n    Checks whether pauli and ladder have been separated.\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`PauliAlgebra`][oqd_core.compiler.analog.rewrite.canonicalize.PauliAlgebra]\n\n    Example:\n        - X@A@Y =&gt; fail\n        - X@Y@A =&gt; pass\n    \"\"\"\n\n    def map_OperatorKron(self, model: OperatorKron):\n        if isinstance(model.op2, Pauli):\n            if isinstance(model.op1, (Ladder, OperatorMul)):\n                raise CanonicalFormError(\"Incorrect GatherPauli\")\n            if isinstance(model.op1, OperatorKron):\n                if isinstance(model.op1.op2, (Ladder, OperatorMul)):\n                    raise CanonicalFormError(\"Incorrect GatherPauli\")\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerNormalOrder","title":"<code>CanVerNormalOrder</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks whether the ladder operations are in normal order</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p>OperatorDistribute, GatherMathExpr, ProperOrder, PauliAlgebra, PruneIdentity <code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>PauliAlgebra</code>, <code>PruneIdentity</code></p> Example <ul> <li>A*C =&gt; fail</li> <li>C*A =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerNormalOrder(RewriteRule):\n    \"\"\"\n    Checks whether the ladder operations are in normal order\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        OperatorDistribute, GatherMathExpr, ProperOrder, PauliAlgebra, PruneIdentity\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`PauliAlgebra`][oqd_core.compiler.analog.rewrite.canonicalize.PauliAlgebra],\n        [`PruneIdentity`][oqd_core.compiler.analog.rewrite.canonicalize.PruneIdentity]\n\n\n    Example:\n        - A*C =&gt; fail\n        - C*A =&gt; pass\n    \"\"\"\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if isinstance(model.op2, Creation):\n            if isinstance(model.op1, Annihilation):\n                raise CanonicalFormError(\"Incorrect NormalOrder\")\n            if isinstance(model.op1, OperatorMul):\n                if isinstance(model.op1.op2, Annihilation):\n                    raise CanonicalFormError(\"Incorrect NormalOrder\")\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerSortedOrder","title":"<code>CanVerSortedOrder</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks whether operators are in sorted order according to TermIndex. Please see example for further clarification</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>GatherPauli</code>, <code>NormalOrder</code>, <code>PruneIdentity</code></p> Example <ul> <li>X + I =&gt; fail</li> <li>I + X =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerSortedOrder(RewriteRule):\n    \"\"\"\n    Checks whether operators are in sorted order according to TermIndex.\n    Please see example for further clarification\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`GatherPauli`][oqd_core.compiler.analog.rewrite.canonicalize.GatherPauli],\n        [`NormalOrder`][oqd_core.compiler.analog.rewrite.canonicalize.NormalOrder],\n        [`PruneIdentity`][oqd_core.compiler.analog.rewrite.canonicalize.PruneIdentity]\n\n    Example:\n        - X + I =&gt; fail\n        - I + X =&gt; pass\n    \"\"\"\n\n    def map_OperatorAdd(self, model: OperatorAdd):\n        term2 = analysis_term_index(model.op2)\n        if isinstance(model.op1, OperatorAdd):\n            term1 = analysis_term_index(model.op1.op2)\n        else:\n            term1 = analysis_term_index(model.op1)\n        if term1 &gt; term2:\n            raise CanonicalFormError(\"Terms are not in sorted order\")\n        elif term1 == term2:\n            raise CanonicalFormError(\"Duplicate terms present\")\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_canonicalization.html#oqd_core.compiler.analog.verify.canonicalize.CanVerScaleTerm","title":"<code>CanVerScaleTerm</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Checks whether all terms have a scalar multiplication.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>VisitableBaseModel</code> <p>The rule only verifies <code>Operator</code> in Analog level</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>VisitableBaseMode</code> <p>unchanged</p> Assumptions <p><code>GatherMathExpr</code>, <code>OperatorDistribute</code>, <code>ProperOrder</code>, <code>GatherPauli</code></p> Example <ul> <li>X + 2*Y =&gt; fail</li> <li>1X + 2Y =&gt; pass</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/analog/verify/canonicalize.py</code> <pre><code>class CanVerScaleTerm(RewriteRule):\n    \"\"\"\n    Checks whether all terms have a scalar multiplication.\n\n    Args:\n        model (VisitableBaseModel): The rule only verifies [`Operator`][oqd_core.interface.analog.operator.Operator] in Analog level\n\n    Returns:\n        model (VisitableBaseMode): unchanged\n\n    Assumptions:\n        [`GatherMathExpr`][oqd_core.compiler.analog.rewrite.canonicalize.GatherMathExpr],\n        [`OperatorDistribute`][oqd_core.compiler.analog.rewrite.canonicalize.OperatorDistribute],\n        [`ProperOrder`][oqd_core.compiler.analog.rewrite.canonicalize.ProperOrder],\n        [`GatherPauli`][oqd_core.compiler.analog.rewrite.canonicalize.GatherPauli]\n\n    Example:\n        - X + 2*Y =&gt; fail\n        - 1*X + 2*Y =&gt; pass\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._single_term_scaling_needed = False\n\n    def map_AnalogGate(self, model):\n        self._single_term_scaling_needed = False\n\n    def map_Expectation(self, model):\n        self._single_term_scaling_needed = False\n\n    def map_OperatorScalarMul(self, model: OperatorScalarMul):\n        self._single_term_scaling_needed = True\n        pass\n\n    def map_OperatorMul(self, model: OperatorMul):\n        if not self._single_term_scaling_needed:\n            raise CanonicalFormError(\"Single term operator has not been scaled\")\n\n    def map_OperatorKron(self, model: OperatorKron):\n        if not self._single_term_scaling_needed:\n            raise CanonicalFormError(\"Single term operator has not been scaled\")\n\n    def map_OperatorTerminal(self, model: OperatorKron):\n        if not self._single_term_scaling_needed:\n            raise CanonicalFormError(\"Single term operator has not been scaled\")\n\n    def map_OperatorAdd(self, model: OperatorAdd):\n        self._single_term_scaling_needed = True\n        if isinstance(model.op2, OperatorScalarMul) and isinstance(\n            model.op1, Union[OperatorScalarMul, OperatorAdd]\n        ):\n            pass\n        else:\n            raise CanonicalFormError(\n                \"some operators between addition are not scaled properly\"\n            )\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html","title":"Analog","text":""},{"location":"open-quantum-design-core/reference/analog_interface.html#operations","title":"Operations","text":""},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operation","title":"<code>oqd_core.interface.analog.operation</code>","text":""},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operation.AnalogCircuit","title":"<code>AnalogCircuit</code>","text":"<p>               Bases: <code>AnalogOperation</code></p> <p>Class representing a quantum information experiment represented in terms of analog operations.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>List[Union[Measure, Evolve, Initialize]]</code> <p>Sequence of statements, including initialize, evolve, measure</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operation.py</code> <pre><code>class AnalogCircuit(AnalogOperation):\n    \"\"\"\n    Class representing a quantum information experiment represented in terms of analog operations.\n\n    Attributes:\n        sequence (List[Union[Measure, Evolve, Initialize]]): Sequence of statements, including initialize, evolve, measure\n\n    \"\"\"\n\n    sequence: List[Statement] = []\n\n    n_qreg: Union[NonNegativeInt, None] = None\n    n_qmode: Union[NonNegativeInt, None] = None\n\n    def evolve(self, gate: AnalogGate, duration: float):\n        self.sequence.append(Evolve(duration=duration, gate=gate))\n\n    def initialize(self):\n        self.sequence.append(Initialize())\n\n    def measure(self):\n        self.sequence.append(Measure())\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operation.AnalogGate","title":"<code>AnalogGate</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing an analog gate composed of Hamiltonian terms and dissipation terms</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>Operator</code> <p>Hamiltonian terms of the gate</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operation.py</code> <pre><code>class AnalogGate(TypeReflectBaseModel):\n    \"\"\"\n    Class representing an analog gate composed of Hamiltonian terms and dissipation terms\n\n    Attributes:\n        hamiltonian (Operator): Hamiltonian terms of the gate\n    \"\"\"\n\n    hamiltonian: OperatorSubtypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operation.AnalogOperation","title":"<code>AnalogOperation</code>","text":"<p>               Bases: <code>VisitableBaseModel</code></p> <p>Class representing an analog operation applied to the quantum system</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operation.py</code> <pre><code>class AnalogOperation(VisitableBaseModel):\n    \"\"\"\n    Class representing an analog operation applied to the quantum system\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operation.Evolve","title":"<code>Evolve</code>","text":"<p>               Bases: <code>AnalogOperation</code></p> <p>Class representing an evolution by an analog gate in the analog circuit</p> <p>Attributes:</p> Name Type Description <code>duration</code> <code>float</code> <p>Duration of the evolution</p> <code>gate</code> <code>AnalogGate</code> <p>Analog gate to evolve by</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operation.py</code> <pre><code>class Evolve(AnalogOperation):\n    \"\"\"\n    Class representing an evolution by an analog gate in the analog circuit\n\n    Attributes:\n        duration (float): Duration of the evolution\n        gate (AnalogGate): Analog gate to evolve by\n    \"\"\"\n\n    key: Literal[\"evolve\"] = \"evolve\"\n    duration: float\n    gate: Union[AnalogGate, str]\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operation.Measure","title":"<code>Measure</code>","text":"<p>               Bases: <code>AnalogOperation</code></p> <p>Class representing a measurement in the analog circuit</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operation.py</code> <pre><code>class Measure(AnalogOperation):\n    \"\"\"\n    Class representing a measurement in the analog circuit\n    \"\"\"\n\n    key: Literal[\"measure\"] = \"measure\"\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operation.Initialize","title":"<code>Initialize</code>","text":"<p>               Bases: <code>AnalogOperation</code></p> <p>Class representing a initialization in the analog circuit</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operation.py</code> <pre><code>class Initialize(AnalogOperation):\n    \"\"\"\n    Class representing a initialization in the analog circuit\n    \"\"\"\n\n    key: Literal[\"initialize\"] = \"initialize\"\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#operators","title":"Operators","text":""},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator","title":"<code>oqd_core.interface.analog.operator</code>","text":""},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorSubtypes","title":"<code>OperatorSubtypes = Union[PauliI, PauliX, PauliY, PauliZ, Creation, Annihilation, Identity, OperatorAdd, OperatorSub, OperatorMul, OperatorScalarMul, OperatorKron]</code>  <code>module-attribute</code>","text":"<p>Alias for the union of concrete Operator subtypes</p>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.Operator","title":"<code>Operator</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing the abstract syntax tree (AST) for a quantum operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class Operator(TypeReflectBaseModel):\n    \"\"\"\n    Class representing the abstract syntax tree (AST) for a quantum operator\n    \"\"\"\n\n    def __neg__(self):\n        return OperatorScalarMul(op=self, expr=MathNum(value=-1))\n\n    def __pos__(self):\n        return self\n\n    def __add__(self, other):\n        return OperatorAdd(op1=self, op2=other)\n\n    def __sub__(self, other):\n        return OperatorSub(op1=self, op2=other)\n\n    def __matmul__(self, other):\n        if isinstance(other, MathExpr):\n            raise TypeError(\n                \"Tried Kron product between Operator and MathExpr. \"\n                + \"Scalar multiplication of MathExpr and Operator should be bracketed when perfoming Kron product.\"\n            )\n        return OperatorKron(op1=self, op2=other)\n\n    def __mul__(self, other):\n        if isinstance(other, Operator):\n            return OperatorMul(op1=self, op2=other)\n        else:\n            other = MathExpr.cast(other)\n            return OperatorScalarMul(op=self, expr=other)\n\n    def __rmul__(self, other):\n        other = MathExpr.cast(other)\n        return self * other\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorTerminal","title":"<code>OperatorTerminal</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing a terminal in the <code>Operator</code> abstract syntax tree (AST)</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class OperatorTerminal(Operator):\n    \"\"\"\n    Class representing a terminal in the [`Operator`][oqd_core.interface.analog.operator.Operator] abstract syntax tree (AST)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.Pauli","title":"<code>Pauli</code>","text":"<p>               Bases: <code>OperatorTerminal</code></p> <p>Class representing a Pauli operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class Pauli(OperatorTerminal):\n    \"\"\"\n    Class representing a Pauli operator\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.PauliI","title":"<code>PauliI</code>","text":"<p>               Bases: <code>Pauli</code></p> <p>Class for the Pauli I operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class PauliI(Pauli):\n    \"\"\"\n    Class for the Pauli I operator\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.PauliX","title":"<code>PauliX</code>","text":"<p>               Bases: <code>Pauli</code></p> <p>Class for the Pauli X operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class PauliX(Pauli):\n    \"\"\"\n    Class for the Pauli X operator\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.PauliY","title":"<code>PauliY</code>","text":"<p>               Bases: <code>Pauli</code></p> <p>Class for the Pauli Y operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class PauliY(Pauli):\n    \"\"\"\n    Class for the Pauli Y operator\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.PauliZ","title":"<code>PauliZ</code>","text":"<p>               Bases: <code>Pauli</code></p> <p>Class for the Pauli Z operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class PauliZ(Pauli):\n    \"\"\"\n    Class for the Pauli Z operator\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.Ladder","title":"<code>Ladder</code>","text":"<p>               Bases: <code>OperatorTerminal</code></p> <p>Class representing a ladder operator in Fock space</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class Ladder(OperatorTerminal):\n    \"\"\"\n    Class representing a ladder operator in Fock space\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.Creation","title":"<code>Creation</code>","text":"<p>               Bases: <code>Ladder</code></p> <p>Class for the Creation operator in Fock space</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class Creation(Ladder):\n    \"\"\"\n    Class for the Creation operator in Fock space\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.Annihilation","title":"<code>Annihilation</code>","text":"<p>               Bases: <code>Ladder</code></p> <p>Class for the Annihilation operator in Fock space</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class Annihilation(Ladder):\n    \"\"\"\n    Class for the Annihilation operator in Fock space\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.Identity","title":"<code>Identity</code>","text":"<p>               Bases: <code>Ladder</code></p> <p>Class for the Identity operator in Fock space</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class Identity(Ladder):\n    \"\"\"\n    Class for the Identity operator in Fock space\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorBinaryOp","title":"<code>OperatorBinaryOp</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing binary operations on <code>Operators</code></p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class OperatorBinaryOp(Operator):\n    \"\"\"\n    Class representing binary operations on [`Operators`][oqd_core.interface.analog.operator.Operator]\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorAdd","title":"<code>OperatorAdd</code>","text":"<p>               Bases: <code>OperatorBinaryOp</code></p> <p>Class representing the addition of <code>Operators</code></p> <p>Attributes:</p> Name Type Description <code>op1</code> <code>Operator</code> <p>Left hand side <code>Operator</code></p> <code>op2</code> <code>Operator</code> <p>Right hand side <code>Operator</code></p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class OperatorAdd(OperatorBinaryOp):\n    \"\"\"\n    Class representing the addition of [`Operators`][oqd_core.interface.analog.operator.Operator]\n\n    Attributes:\n        op1 (Operator): Left hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n        op2 (Operator): Right hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n    \"\"\"\n\n    op1: OperatorSubtypes\n    op2: OperatorSubtypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorSub","title":"<code>OperatorSub</code>","text":"<p>               Bases: <code>OperatorBinaryOp</code></p> <p>Class representing the subtraction of <code>Operators</code></p> <p>Attributes:</p> Name Type Description <code>op1</code> <code>Operator</code> <p>Left hand side <code>Operator</code></p> <code>op2</code> <code>Operator</code> <p>Right hand side <code>Operator</code></p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class OperatorSub(OperatorBinaryOp):\n    \"\"\"\n    Class representing the subtraction of [`Operators`][oqd_core.interface.analog.operator.Operator]\n\n    Attributes:\n        op1 (Operator): Left hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n        op2 (Operator): Right hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n    \"\"\"\n\n    op1: OperatorSubtypes\n    op2: OperatorSubtypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorMul","title":"<code>OperatorMul</code>","text":"<p>               Bases: <code>OperatorBinaryOp</code></p> <p>Class representing the multiplication of <code>Operators</code></p> <p>Attributes:</p> Name Type Description <code>op1</code> <code>Operator</code> <p>Left hand side <code>Operator</code></p> <code>op2</code> <code>Operator</code> <p>Right hand side <code>Operator</code></p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class OperatorMul(OperatorBinaryOp):\n    \"\"\"\n    Class representing the multiplication of [`Operators`][oqd_core.interface.analog.operator.Operator]\n\n    Attributes:\n        op1 (Operator): Left hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n        op2 (Operator): Right hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n    \"\"\"\n\n    op1: OperatorSubtypes\n    op2: OperatorSubtypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorScalarMul","title":"<code>OperatorScalarMul</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Class representing scalar multiplication of an <code>Operator</code> and a <code>MathExpr</code></p> <p>Attributes:</p> Name Type Description <code>op</code> <code>Operator</code> <p><code>Operator</code> to multiply</p> <code>expr</code> <code>MathExpr</code> <p><code>MathExpr</code> to multiply by</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class OperatorScalarMul(Operator):\n    \"\"\"\n    Class representing scalar multiplication of an [`Operator`][oqd_core.interface.analog.operator.Operator] and a\n    [`MathExpr`][oqd_core.interface.math.MathExpr]\n\n    Attributes:\n        op (Operator): [`Operator`][oqd_core.interface.analog.operator.Operator] to multiply\n        expr (MathExpr): [`MathExpr`][oqd_core.interface.math.MathExpr] to multiply by\n    \"\"\"\n\n    op: OperatorSubtypes\n    expr: MathExprSubtypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.OperatorKron","title":"<code>OperatorKron</code>","text":"<p>               Bases: <code>OperatorBinaryOp</code></p> <p>Class representing the tensor product of <code>Operators</code></p> <p>Attributes:</p> Name Type Description <code>op1</code> <code>Operator</code> <p>Left hand side <code>Operator</code></p> <code>op2</code> <code>Operator</code> <p>Right hand side <code>Operator</code></p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>class OperatorKron(OperatorBinaryOp):\n    \"\"\"\n    Class representing the tensor product of [`Operators`][oqd_core.interface.analog.operator.Operator]\n\n    Attributes:\n        op1 (Operator): Left hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n        op2 (Operator): Right hand side [`Operator`][oqd_core.interface.analog.operator.Operator]\n    \"\"\"\n\n    op1: OperatorSubtypes\n    op2: OperatorSubtypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.PauliPlus","title":"<code>PauliPlus()</code>","text":"<p>Function that constructs the Pauli + operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>def PauliPlus():\n    \"\"\"\n    Function that constructs the Pauli + operator\n    \"\"\"\n    return OperatorAdd(\n        op1=PauliX(),\n        op2=OperatorScalarMul(\n            op=PauliY(), expr=MathMul(expr1=MathImag(), expr2=MathNum(value=1))\n        ),\n    )\n</code></pre>"},{"location":"open-quantum-design-core/reference/analog_interface.html#oqd_core.interface.analog.operator.PauliMinus","title":"<code>PauliMinus()</code>","text":"<p>Function that constructs the Pauli - operator</p> Source code in <code>oqd-core/src/oqd_core/interface/analog/operator.py</code> <pre><code>def PauliMinus():\n    \"\"\"\n    Function that constructs the Pauli - operator\n    \"\"\"\n    return OperatorAdd(\n        op1=PauliX(),\n        op2=OperatorScalarMul(\n            op=PauliY(), expr=MathMul(expr1=MathImag(), expr2=MathNum(value=-1))\n        ),\n    )\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_canonicalization.html","title":"Canonicalization","text":""},{"location":"open-quantum-design-core/reference/atomic_canonicalization.html#oqd_core.compiler.atomic","title":"<code>oqd_core.compiler.atomic</code>","text":""},{"location":"open-quantum-design-core/reference/atomic_canonicalization.html#oqd_core.compiler.atomic.canonicalize","title":"<code>canonicalize</code>","text":""},{"location":"open-quantum-design-core/reference/atomic_canonicalization.html#oqd_core.compiler.atomic.canonicalize.UnrollLevelLabel","title":"<code>UnrollLevelLabel</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Unrolls the <code>Level</code> labels present in <code>Transitions</code>.</p> Source code in <code>oqd-core/src/oqd_core/compiler/atomic/canonicalize.py</code> <pre><code>class UnrollLevelLabel(RewriteRule):\n    \"\"\"\n    Unrolls the [`Level`][oqd_core.interface.atomic.system.Level] labels present in [`Transitions`][oqd_core.interface.atomic.system.Transition].\n    \"\"\"\n\n    def map_Ion(self, model):\n        self.ion_levels = {level.label: level for level in model.levels}\n\n    def map_Transition(self, model):\n        if isinstance(model.level1, Level) and isinstance(model.level2, Level):\n            return\n\n        level1 = (\n            self.ion_levels[model.level1]\n            if isinstance(model.level1, str)\n            else model.level1\n        )\n        level2 = (\n            self.ion_levels[model.level2]\n            if isinstance(model.level2, str)\n            else model.level2\n        )\n        return model.__class__(\n            label=model.label,\n            level1=level1,\n            level2=level2,\n            einsteinA=model.einsteinA,\n            multipole=model.multipole,\n        )\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_canonicalization.html#oqd_core.compiler.atomic.canonicalize.UnrollTransitionLabel","title":"<code>UnrollTransitionLabel</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Unrolls the <code>Transition</code> labels present in <code>Beams</code>.</p> Source code in <code>oqd-core/src/oqd_core/compiler/atomic/canonicalize.py</code> <pre><code>class UnrollTransitionLabel(RewriteRule):\n    \"\"\"\n    Unrolls the [`Transition`][oqd_core.interface.atomic.system.Transition] labels present in [`Beams`][oqd_core.interface.atomic.protocol.Beam].\n    \"\"\"\n\n    def map_System(self, model):\n        self.ions_transitions = [\n            {transition.label: transition for transition in ion.transitions}\n            for ion in model.ions\n        ]\n\n    def map_Beam(self, model):\n        if isinstance(model.transition, Transition):\n            return\n\n        if isinstance(model.transition, str):\n            transition_label = model.transition\n            reference_ion = model.target\n        else:\n            transition_label = model.transition[0]\n            reference_ion = model.transition[1]\n\n        transition = self.ions_transitions[reference_ion][transition_label]\n        return model.__class__(\n            transition=transition,\n            rabi=model.rabi,\n            detuning=model.detuning,\n            phase=model.phase,\n            polarization=model.polarization,\n            wavevector=model.wavevector,\n            target=model.target,\n        )\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html","title":"Atomic","text":""},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic","title":"<code>oqd_core.interface.atomic</code>","text":""},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.AtomicCircuit","title":"<code>AtomicCircuit</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a trapped-ion experiment in terms of light-matter interactons.</p> <p>Attributes:</p> Name Type Description <code>system</code> <code>System</code> <p>The trapped-ion system.</p> <code>protocol</code> <code>ProtocolSubTypes</code> <p>Pulse program for the trapped-ion experiment referenced to the trapped-ion system.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/circuit.py</code> <pre><code>class AtomicCircuit(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a trapped-ion experiment in terms of light-matter interactons.\n\n    Attributes:\n        system: The trapped-ion system.\n        protocol: Pulse program for the trapped-ion experiment referenced to the trapped-ion system.\n\n    \"\"\"\n\n    system: System\n    protocol: ProtocolSubTypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.Beam","title":"<code>Beam</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a referenced optical channel/beam for the trapped-ion device.</p> <p>Attributes:</p> Name Type Description <code>transition</code> <code>Union[str, Tuple[str, int], Transition]</code> <p><code>Transition</code>, or it's label, that the optical channel/beam is referenced to.</p> <code>rabi</code> <code>CastMathExpr</code> <p>Rabi frequency of the referenced transition driven by the beam.</p> <code>detuning</code> <code>CastMathExpr</code> <p>Detuning away from the referenced transition.</p> <code>phase</code> <code>CastMathExpr</code> <p>Phase relative to the ion's clock.</p> <code>polarization</code> <code>conlist(float, max_length=3, min_length=3)</code> <p>Polarization of the beam.</p> <code>wavevector</code> <code>conlist(float, max_length=3, min_length=3)</code> <p>Wavevector of the beam.</p> <code>target</code> <code>int</code> <p>Index of the target ion of the beam.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class Beam(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a referenced optical channel/beam for the trapped-ion device.\n\n    Attributes:\n        transition: [`Transition`][oqd_core.interface.atomic.system.Transition], or it's label, that the optical channel/beam is referenced to.\n        rabi: Rabi frequency of the referenced transition driven by the beam.\n        detuning: Detuning away from the referenced transition.\n        phase: Phase relative to the ion's clock.\n        polarization: Polarization of the beam.\n        wavevector: Wavevector of the beam.\n        target: Index of the target ion of the beam.\n    \"\"\"\n\n    transition: Union[str, Tuple[str, int], Transition]\n    rabi: CastMathExpr\n    detuning: CastMathExpr\n    phase: CastMathExpr\n    polarization: conlist(float, max_length=3, min_length=3)\n    wavevector: conlist(float, max_length=3, min_length=3)\n    target: int\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.ParallelProtocol","title":"<code>ParallelProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Class representing the parallel composition of a list of pulses or subprotocols.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>List[Union[Pulse, ProtocolSubTypes]]</code> <p>List of pulses or subprotocols to compose together in a parallel fashion.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class ParallelProtocol(Protocol):\n    \"\"\"\n    Class representing the parallel composition of a list of pulses or subprotocols.\n\n    Attributes:\n        sequence: List of pulses or subprotocols to compose together in a parallel fashion.\n    \"\"\"\n\n    sequence: List[Union[Pulse, ProtocolSubTypes]]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.Protocol","title":"<code>Protocol</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a light-matter interaction protocol/pulse program for the optical channels/beams.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class Protocol(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a light-matter interaction protocol/pulse program for the optical channels/beams.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.Pulse","title":"<code>Pulse</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing the application of the beam for some duration.</p> <p>Attributes:</p> Name Type Description <code>beam</code> <code>Beam</code> <p>Optical channel/beam to turn on.</p> <code>duration</code> <code>float</code> <p>Period of time to turn the optical channel on for.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class Pulse(TypeReflectBaseModel):\n    \"\"\"\n    Class representing the application of the beam for some duration.\n\n    Attributes:\n        beam: Optical channel/beam to turn on.\n        duration: Period of time to turn the optical channel on for.\n\n    \"\"\"\n\n    beam: Beam\n    duration: float\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.SequentialProtocol","title":"<code>SequentialProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Class representing the sequential composition of a list of pulses or subprotocols.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>List[Union[Pulse, ProtocolSubTypes]]</code> <p>List of pulses or subprotocols to compose together in a sequntial fashion.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class SequentialProtocol(Protocol):\n    \"\"\"\n    Class representing the sequential composition of a list of pulses or subprotocols.\n\n    Attributes:\n        sequence: List of pulses or subprotocols to compose together in a sequntial fashion.\n    \"\"\"\n\n    sequence: List[Union[Pulse, ProtocolSubTypes]]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.Ion","title":"<code>Ion</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing an ion.</p> <p>Attributes:</p> Name Type Description <code>mass</code> <code>float</code> <p>Mass of the ion.</p> <code>charge</code> <code>float</code> <p>Charge of the ion.</p> <code>levels</code> <code>List[Level]</code> <p>Electronic energy levels of the ion.</p> <code>transitions</code> <code>List[Transition]</code> <p>Allowed transitions in the ion.</p> <code>position</code> <code>List[float]</code> <p>Spatial position of the ion.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Ion(TypeReflectBaseModel):\n    \"\"\"\n    Class representing an ion.\n\n    Attributes:\n        mass: Mass of the ion.\n        charge: Charge of the ion.\n        levels: Electronic energy levels of the ion.\n        transitions: Allowed transitions in the ion.\n        position: Spatial position of the ion.\n    \"\"\"\n\n    mass: float\n    charge: float\n    levels: List[Level]\n    transitions: List[Transition]\n    position: List[float]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.Level","title":"<code>Level</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>\" Class representing an electronic energy level of an ion.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Label for the Level</p> <code>principal</code> <code>NonNegativeInt</code> <p>Principal quantum number.</p> <code>spin</code> <code>NonNegativeAngularMomentumNumber</code> <p>Spin of an electron.</p> <code>orbital</code> <code>NonNegativeAngularMomentumNumber</code> <p>Orbital angular momentum of an electron.</p> <code>nuclear</code> <code>NonNegativeAngularMomentumNumber</code> <p>Nuclear angular momentum.</p> <code>spin_orbital</code> <code>NonNegativeAngularMomentumNumber</code> <p>Angular momentum of the spin-orbital coupling.</p> <code>spin_orbital_nuclear</code> <code>NonNegativeAngularMomentumNumber</code> <p>Angular momentum of the spin-orbital-nuclear coupling.</p> <code>spin_orbital_nuclear_magnetization</code> <code>AngularMomentumNumber</code> <p>Magnetization of the spin-orbital-nuclear coupled angular momentum.</p> <code>energy</code> <code>float</code> <p>Energy of the electronic state.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Level(TypeReflectBaseModel):\n    \"\"\" \"\n    Class representing an electronic energy level of an ion.\n\n    Attributes:\n        label: Label for the Level\n        principal: Principal quantum number.\n        spin: Spin of an electron.\n        orbital: Orbital angular momentum of an electron.\n        nuclear: Nuclear angular momentum.\n        spin_orbital: Angular momentum of the spin-orbital coupling.\n        spin_orbital_nuclear: Angular momentum of the spin-orbital-nuclear coupling.\n        spin_orbital_nuclear_magnetization: Magnetization of the spin-orbital-nuclear coupled angular momentum.\n        energy: Energy of the electronic state.\n\n    \"\"\"\n\n    label: str\n    principal: NonNegativeInt\n    spin: NonNegativeAngularMomentumNumber\n    orbital: NonNegativeAngularMomentumNumber\n    nuclear: NonNegativeAngularMomentumNumber\n    spin_orbital: NonNegativeAngularMomentumNumber\n    spin_orbital_nuclear: NonNegativeAngularMomentumNumber\n    spin_orbital_nuclear_magnetization: AngularMomentumNumber\n    energy: float\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.Phonon","title":"<code>Phonon</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a collective phonon mode of the trapped-ion system.</p> <p>Attributes:</p> Name Type Description <code>energy</code> <code>float</code> <p>Quanta of energy for the phonon mode.</p> <code>eigenvector</code> <code>List[float]</code> <p>Profile of the phonon mode in terms of the vibration of the ions.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Phonon(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a collective phonon mode of the trapped-ion system.\n\n    Attributes:\n        energy: Quanta of energy for the phonon mode.\n        eigenvector: Profile of the phonon mode in terms of the vibration of the ions.\n\n    \"\"\"\n\n    energy: float\n    eigenvector: List[float]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.System","title":"<code>System</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a trapped-ion system.</p> <p>Attributes:</p> Name Type Description <code>ions</code> <code>List[Ion]</code> <p>List of ions in the trapped-ion system.</p> <code>modes</code> <code>List[Phonon]</code> <p>List of collective phonon modes for the trapped-ion system.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class System(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a trapped-ion system.\n\n    Attributes:\n        ions: List of ions in the trapped-ion system.\n        modes: List of collective phonon modes for the trapped-ion system.\n\n    \"\"\"\n\n    ions: List[Ion]\n    modes: List[Phonon]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.Transition","title":"<code>Transition</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a transition between electronic states of an ion.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Label for the Transition</p> <code>level1</code> <code>Union[str, Level]</code> <p>Label for energy level 1.</p> <code>level2</code> <code>Union[str, Level]</code> <p>Label for energy level 2.</p> <code>einsteinA</code> <code>float</code> <p>Einstein A coefficient that characterizes the strength of coupling between energy level 1 and 2.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Transition(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a transition between electronic states of an ion.\n\n    Attributes:\n        label: Label for the Transition\n        level1: Label for energy level 1.\n        level2: Label for energy level 2.\n        einsteinA: Einstein A coefficient that characterizes the strength of coupling between energy level 1 and 2.\n\n    \"\"\"\n\n    label: str\n    level1: Union[str, Level]\n    level2: Union[str, Level]\n    einsteinA: float\n    multipole: Literal[\"E1\", \"E2\", \"M1\"]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.circuit","title":"<code>circuit</code>","text":""},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.circuit.AtomicCircuit","title":"<code>AtomicCircuit</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a trapped-ion experiment in terms of light-matter interactons.</p> <p>Attributes:</p> Name Type Description <code>system</code> <code>System</code> <p>The trapped-ion system.</p> <code>protocol</code> <code>ProtocolSubTypes</code> <p>Pulse program for the trapped-ion experiment referenced to the trapped-ion system.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/circuit.py</code> <pre><code>class AtomicCircuit(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a trapped-ion experiment in terms of light-matter interactons.\n\n    Attributes:\n        system: The trapped-ion system.\n        protocol: Pulse program for the trapped-ion experiment referenced to the trapped-ion system.\n\n    \"\"\"\n\n    system: System\n    protocol: ProtocolSubTypes\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.protocol","title":"<code>protocol</code>","text":""},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.protocol.Beam","title":"<code>Beam</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a referenced optical channel/beam for the trapped-ion device.</p> <p>Attributes:</p> Name Type Description <code>transition</code> <code>Union[str, Tuple[str, int], Transition]</code> <p><code>Transition</code>, or it's label, that the optical channel/beam is referenced to.</p> <code>rabi</code> <code>CastMathExpr</code> <p>Rabi frequency of the referenced transition driven by the beam.</p> <code>detuning</code> <code>CastMathExpr</code> <p>Detuning away from the referenced transition.</p> <code>phase</code> <code>CastMathExpr</code> <p>Phase relative to the ion's clock.</p> <code>polarization</code> <code>conlist(float, max_length=3, min_length=3)</code> <p>Polarization of the beam.</p> <code>wavevector</code> <code>conlist(float, max_length=3, min_length=3)</code> <p>Wavevector of the beam.</p> <code>target</code> <code>int</code> <p>Index of the target ion of the beam.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class Beam(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a referenced optical channel/beam for the trapped-ion device.\n\n    Attributes:\n        transition: [`Transition`][oqd_core.interface.atomic.system.Transition], or it's label, that the optical channel/beam is referenced to.\n        rabi: Rabi frequency of the referenced transition driven by the beam.\n        detuning: Detuning away from the referenced transition.\n        phase: Phase relative to the ion's clock.\n        polarization: Polarization of the beam.\n        wavevector: Wavevector of the beam.\n        target: Index of the target ion of the beam.\n    \"\"\"\n\n    transition: Union[str, Tuple[str, int], Transition]\n    rabi: CastMathExpr\n    detuning: CastMathExpr\n    phase: CastMathExpr\n    polarization: conlist(float, max_length=3, min_length=3)\n    wavevector: conlist(float, max_length=3, min_length=3)\n    target: int\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.protocol.Pulse","title":"<code>Pulse</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing the application of the beam for some duration.</p> <p>Attributes:</p> Name Type Description <code>beam</code> <code>Beam</code> <p>Optical channel/beam to turn on.</p> <code>duration</code> <code>float</code> <p>Period of time to turn the optical channel on for.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class Pulse(TypeReflectBaseModel):\n    \"\"\"\n    Class representing the application of the beam for some duration.\n\n    Attributes:\n        beam: Optical channel/beam to turn on.\n        duration: Period of time to turn the optical channel on for.\n\n    \"\"\"\n\n    beam: Beam\n    duration: float\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.protocol.Protocol","title":"<code>Protocol</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a light-matter interaction protocol/pulse program for the optical channels/beams.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class Protocol(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a light-matter interaction protocol/pulse program for the optical channels/beams.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.protocol.ParallelProtocol","title":"<code>ParallelProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Class representing the parallel composition of a list of pulses or subprotocols.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>List[Union[Pulse, ProtocolSubTypes]]</code> <p>List of pulses or subprotocols to compose together in a parallel fashion.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class ParallelProtocol(Protocol):\n    \"\"\"\n    Class representing the parallel composition of a list of pulses or subprotocols.\n\n    Attributes:\n        sequence: List of pulses or subprotocols to compose together in a parallel fashion.\n    \"\"\"\n\n    sequence: List[Union[Pulse, ProtocolSubTypes]]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.protocol.SequentialProtocol","title":"<code>SequentialProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Class representing the sequential composition of a list of pulses or subprotocols.</p> <p>Attributes:</p> Name Type Description <code>sequence</code> <code>List[Union[Pulse, ProtocolSubTypes]]</code> <p>List of pulses or subprotocols to compose together in a sequntial fashion.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/protocol.py</code> <pre><code>class SequentialProtocol(Protocol):\n    \"\"\"\n    Class representing the sequential composition of a list of pulses or subprotocols.\n\n    Attributes:\n        sequence: List of pulses or subprotocols to compose together in a sequntial fashion.\n    \"\"\"\n\n    sequence: List[Union[Pulse, ProtocolSubTypes]]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system","title":"<code>system</code>","text":""},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.AngularMomentumNumber","title":"<code>AngularMomentumNumber = Annotated[float, AfterValidator(is_halfint)]</code>  <code>module-attribute</code>","text":"<p>A valid positive or negative integer or half-integer for angular momentum.</p>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.NonNegativeAngularMomentumNumber","title":"<code>NonNegativeAngularMomentumNumber = Annotated[NonNegativeFloat, AfterValidator(is_halfint)]</code>  <code>module-attribute</code>","text":"<p>A valid non-negative integer or half-integer for angular momentum.</p>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.Level","title":"<code>Level</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>\" Class representing an electronic energy level of an ion.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Label for the Level</p> <code>principal</code> <code>NonNegativeInt</code> <p>Principal quantum number.</p> <code>spin</code> <code>NonNegativeAngularMomentumNumber</code> <p>Spin of an electron.</p> <code>orbital</code> <code>NonNegativeAngularMomentumNumber</code> <p>Orbital angular momentum of an electron.</p> <code>nuclear</code> <code>NonNegativeAngularMomentumNumber</code> <p>Nuclear angular momentum.</p> <code>spin_orbital</code> <code>NonNegativeAngularMomentumNumber</code> <p>Angular momentum of the spin-orbital coupling.</p> <code>spin_orbital_nuclear</code> <code>NonNegativeAngularMomentumNumber</code> <p>Angular momentum of the spin-orbital-nuclear coupling.</p> <code>spin_orbital_nuclear_magnetization</code> <code>AngularMomentumNumber</code> <p>Magnetization of the spin-orbital-nuclear coupled angular momentum.</p> <code>energy</code> <code>float</code> <p>Energy of the electronic state.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Level(TypeReflectBaseModel):\n    \"\"\" \"\n    Class representing an electronic energy level of an ion.\n\n    Attributes:\n        label: Label for the Level\n        principal: Principal quantum number.\n        spin: Spin of an electron.\n        orbital: Orbital angular momentum of an electron.\n        nuclear: Nuclear angular momentum.\n        spin_orbital: Angular momentum of the spin-orbital coupling.\n        spin_orbital_nuclear: Angular momentum of the spin-orbital-nuclear coupling.\n        spin_orbital_nuclear_magnetization: Magnetization of the spin-orbital-nuclear coupled angular momentum.\n        energy: Energy of the electronic state.\n\n    \"\"\"\n\n    label: str\n    principal: NonNegativeInt\n    spin: NonNegativeAngularMomentumNumber\n    orbital: NonNegativeAngularMomentumNumber\n    nuclear: NonNegativeAngularMomentumNumber\n    spin_orbital: NonNegativeAngularMomentumNumber\n    spin_orbital_nuclear: NonNegativeAngularMomentumNumber\n    spin_orbital_nuclear_magnetization: AngularMomentumNumber\n    energy: float\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.Transition","title":"<code>Transition</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a transition between electronic states of an ion.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Label for the Transition</p> <code>level1</code> <code>Union[str, Level]</code> <p>Label for energy level 1.</p> <code>level2</code> <code>Union[str, Level]</code> <p>Label for energy level 2.</p> <code>einsteinA</code> <code>float</code> <p>Einstein A coefficient that characterizes the strength of coupling between energy level 1 and 2.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Transition(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a transition between electronic states of an ion.\n\n    Attributes:\n        label: Label for the Transition\n        level1: Label for energy level 1.\n        level2: Label for energy level 2.\n        einsteinA: Einstein A coefficient that characterizes the strength of coupling between energy level 1 and 2.\n\n    \"\"\"\n\n    label: str\n    level1: Union[str, Level]\n    level2: Union[str, Level]\n    einsteinA: float\n    multipole: Literal[\"E1\", \"E2\", \"M1\"]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.Ion","title":"<code>Ion</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing an ion.</p> <p>Attributes:</p> Name Type Description <code>mass</code> <code>float</code> <p>Mass of the ion.</p> <code>charge</code> <code>float</code> <p>Charge of the ion.</p> <code>levels</code> <code>List[Level]</code> <p>Electronic energy levels of the ion.</p> <code>transitions</code> <code>List[Transition]</code> <p>Allowed transitions in the ion.</p> <code>position</code> <code>List[float]</code> <p>Spatial position of the ion.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Ion(TypeReflectBaseModel):\n    \"\"\"\n    Class representing an ion.\n\n    Attributes:\n        mass: Mass of the ion.\n        charge: Charge of the ion.\n        levels: Electronic energy levels of the ion.\n        transitions: Allowed transitions in the ion.\n        position: Spatial position of the ion.\n    \"\"\"\n\n    mass: float\n    charge: float\n    levels: List[Level]\n    transitions: List[Transition]\n    position: List[float]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.Phonon","title":"<code>Phonon</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a collective phonon mode of the trapped-ion system.</p> <p>Attributes:</p> Name Type Description <code>energy</code> <code>float</code> <p>Quanta of energy for the phonon mode.</p> <code>eigenvector</code> <code>List[float]</code> <p>Profile of the phonon mode in terms of the vibration of the ions.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class Phonon(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a collective phonon mode of the trapped-ion system.\n\n    Attributes:\n        energy: Quanta of energy for the phonon mode.\n        eigenvector: Profile of the phonon mode in terms of the vibration of the ions.\n\n    \"\"\"\n\n    energy: float\n    eigenvector: List[float]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.System","title":"<code>System</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing a trapped-ion system.</p> <p>Attributes:</p> Name Type Description <code>ions</code> <code>List[Ion]</code> <p>List of ions in the trapped-ion system.</p> <code>modes</code> <code>List[Phonon]</code> <p>List of collective phonon modes for the trapped-ion system.</p> Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>class System(TypeReflectBaseModel):\n    \"\"\"\n    Class representing a trapped-ion system.\n\n    Attributes:\n        ions: List of ions in the trapped-ion system.\n        modes: List of collective phonon modes for the trapped-ion system.\n\n    \"\"\"\n\n    ions: List[Ion]\n    modes: List[Phonon]\n</code></pre>"},{"location":"open-quantum-design-core/reference/atomic_interface.html#oqd_core.interface.atomic.system.is_halfint","title":"<code>is_halfint(v: float) -&gt; bool</code>","text":"<p>Function that verifies a number is an integer or half-integer.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>float</code> <p>Number to verify.</p> required Source code in <code>oqd-core/src/oqd_core/interface/atomic/system.py</code> <pre><code>def is_halfint(v: float) -&gt; bool:\n    \"\"\"\n    Function that verifies a number is an integer or half-integer.\n\n    Args:\n        v: Number to verify.\n    \"\"\"\n    if not (v * 2).is_integer():\n        raise ValueError()\n    return v\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_compiler.html","title":"Math","text":""},{"location":"open-quantum-design-core/reference/math_compiler.html#passes","title":"Passes","text":""},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.passes","title":"<code>oqd_core.compiler.math.passes</code>","text":""},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.passes.evaluate_math_expr","title":"<code>evaluate_math_expr = Post(EvaluateMathExpr())</code>  <code>module-attribute</code>","text":"<p>Pass for evaluating math expression</p>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.passes.simplify_math_expr","title":"<code>simplify_math_expr = Post(SimplifyMathExpr())</code>  <code>module-attribute</code>","text":"<p>Pass for simplifying math expression</p>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.passes.print_math_expr","title":"<code>print_math_expr = Post(PrintMathExpr())</code>  <code>module-attribute</code>","text":"<p>Pass for printing math expression</p>"},{"location":"open-quantum-design-core/reference/math_compiler.html#rules","title":"Rules","text":""},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules","title":"<code>oqd_core.compiler.math.rules</code>","text":""},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules.PrintMathExpr","title":"<code>PrintMathExpr</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>This prints <code>MathExpr</code> objects. Verbosity level can be given as an attribute.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MathExpr</code> <p>The rule only acts on <code>MathExpr</code> objects.</p> required <p>Returns:</p> Name Type Description <code>string</code> <code>str</code> Assumptions <p>None</p> Example <p>MathAdd(expr1 = 2, expr2 = 3) =&gt; str(2 + 3)</p> Source code in <code>oqd-core/src/oqd_core/compiler/math/rules.py</code> <pre><code>class PrintMathExpr(ConversionRule):\n    \"\"\"\n    This prints [`MathExpr`][oqd_core.interface.math.MathExpr] objects. Verbosity level can be given as an attribute.\n\n    Args:\n        model (MathExpr): The rule only acts on [`MathExpr`][oqd_core.interface.math.MathExpr] objects.\n\n    Returns:\n        string (str):\n\n    Assumptions:\n        None\n\n    Example:\n        MathAdd(expr1 = 2, expr2 = 3) =&gt; str(2 + 3)\n    \"\"\"\n\n    def __init__(self, *, verbose=False):\n        super().__init__()\n\n        self.verbose = verbose\n\n    def map_MathVar(self, model: MathVar, operands):\n        string = \"{}\".format(model.name)\n        return string\n\n    def map_MathNum(self, model: MathNum, operands):\n        string = \"{}\".format(model.value)\n        return string\n\n    def map_MathImag(self, model: MathImag, operands):\n        string = \"1j\"\n        return string\n\n    def map_MathFunc(self, model: MathFunc, operands):\n        string = \"{}({})\".format(model.func, operands[\"expr\"])\n        return string\n\n    def map_MathAdd(self, model: MathAdd, operands):\n        if self.verbose:\n            return self._map_MathBinaryOp(model, operands)\n        string = \"{} + {}\".format(operands[\"expr1\"], operands[\"expr2\"])\n        return string\n\n    def map_MathSub(self, model: MathSub, operands):\n        if self.verbose:\n            return self._map_MathBinaryOp(model, operands)\n        s2 = (\n            f\"({operands['expr2']})\"\n            if isinstance(model.expr2, (MathAdd, MathSub))\n            else operands[\"expr2\"]\n        )\n        string = \"{} - {}\".format(operands[\"expr1\"], s2)\n        return string\n\n    def map_MathMul(self, model: MathMul, operands):\n        if self.verbose:\n            return self._map_MathBinaryOp(model, operands)\n        s1 = (\n            f\"({operands['expr1']})\"\n            if isinstance(operands[\"expr1\"], (MathAdd, MathSub))\n            else operands[\"expr1\"]\n        )\n        s2 = (\n            f\"({operands['expr2']})\"\n            if isinstance(model.expr2, (MathAdd, MathSub))\n            else operands[\"expr2\"]\n        )\n\n        string = \"{} * {}\".format(s1, s2)\n        return string\n\n    def map_MathDiv(self, model: MathDiv, operands):\n        if self.verbose:\n            return self._map_MathBinaryOp(model, operands)\n        s1 = (\n            f\"({operands['expr1']})\"\n            if isinstance(model.expr1, (MathAdd, MathSub))\n            else operands[\"expr1\"]\n        )\n        s2 = (\n            f\"({operands['expr2']})\"\n            if isinstance(model.expr2, (MathAdd, MathSub))\n            else operands[\"expr2\"]\n        )\n\n        string = \"{} / {}\".format(s1, s2)\n        return string\n\n    def map_MathPow(self, model: MathPow, operands):\n        if self.verbose:\n            return self._map_MathBinaryOp(model, operands)\n        s1 = (\n            f\"({operands['expr1']})\"\n            if isinstance(model.expr1, (MathAdd, MathSub, MathMul, MathDiv))\n            else operands[\"expr1\"]\n        )\n        s2 = (\n            f\"({operands['expr2']})\"\n            if isinstance(model.expr2, (MathAdd, MathSub, MathMul, MathDiv))\n            else operands[\"expr2\"]\n        )\n\n        string = \"{} ** {}\".format(s1, s2)\n        return string\n\n    def _map_MathBinaryOp(self, model: MathBinaryOp, operands):\n        s1 = (\n            f\"({operands['expr1']})\"\n            if not isinstance(model.expr1, (MathTerminal, MathUnaryOp))\n            else operands[\"expr1\"]\n        )\n        s2 = (\n            f\"({operands['expr2']})\"\n            if not isinstance(model.expr2, (MathTerminal, MathUnaryOp))\n            else operands[\"expr2\"]\n        )\n        operator_dict = dict(\n            MathAdd=\"+\", MathSub=\"-\", MathMul=\"*\", MathDiv=\"/\", MathPow=\"**\"\n        )\n        string = f\"{s1} {operator_dict[model.__class__.__name__]} {s2}\"\n        return string\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules.DistributeMathExpr","title":"<code>DistributeMathExpr</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>This distributes <code>MathExpr</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MathExpr</code> <p>The rule only acts on <code>MathExpr</code> objects.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>MathExpr</code> Assumptions <p>None</p> Example <p>MathStr(string = '3 * (2 + 1)') =&gt; MathStr(string = '3 * 2 + 3 * 1')</p> Source code in <code>oqd-core/src/oqd_core/compiler/math/rules.py</code> <pre><code>class DistributeMathExpr(RewriteRule):\n    \"\"\"\n    This distributes [`MathExpr`][oqd_core.interface.math.MathExpr] objects.\n\n    Args:\n        model (MathExpr): The rule only acts on [`MathExpr`][oqd_core.interface.math.MathExpr] objects.\n\n    Returns:\n        model (MathExpr):\n\n    Assumptions:\n        None\n\n    Example:\n        MathStr(string = '3 * (2 + 1)') =&gt; MathStr(string = '3 * 2 + 3 * 1')\n    \"\"\"\n\n    def map_MathMul(self, model: MathMul):\n        if isinstance(model.expr1, (MathAdd, MathSub)):\n            return model.expr1.__class__(\n                expr1=MathMul(expr1=model.expr1.expr1, expr2=model.expr2),\n                expr2=MathMul(expr1=model.expr1.expr2, expr2=model.expr2),\n            )\n        if isinstance(model.expr2, (MathAdd, MathSub)):\n            return model.expr2.__class__(\n                expr1=MathMul(expr1=model.expr1, expr2=model.expr2.expr1),\n                expr2=MathMul(expr1=model.expr1, expr2=model.expr2.expr2),\n            )\n        pass\n\n    def map_MathSub(self, model: MathSub):\n        return MathAdd(\n            expr1=model.expr1,\n            expr2=MathMul(expr1=MathNum(value=-1), expr2=model.expr2),\n        )\n\n    def map_MathDiv(self, model: MathDiv):\n        return MathMul(\n            expr1=model.expr1,\n            expr2=MathPow(expr1=model.expr2, expr2=MathNum(value=-1)),\n        )\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules.PartitionMathExpr","title":"<code>PartitionMathExpr</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>This separates real and complex portions of <code>MathExpr</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MathExpr</code> <p>The rule only acts on <code>MathExpr</code> objects.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>MathExpr</code> Assumptions <p><code>DistributeMathExpr</code>, <code>ProperOrderMathExpr</code></p> Example <ul> <li>MathStr(string = '1 + 1j + 2') =&gt; MathStr(string = '1 + 2 + 1j')</li> <li>MathStr(string = '1 * 1j * 2') =&gt; MathStr(string = '1j * 1 * 2')</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/math/rules.py</code> <pre><code>class PartitionMathExpr(RewriteRule):\n    \"\"\"\n    This separates real and complex portions of [`MathExpr`][oqd_core.interface.math.MathExpr] objects.\n\n    Args:\n        model (MathExpr): The rule only acts on [`MathExpr`][oqd_core.interface.math.MathExpr] objects.\n\n    Returns:\n        model (MathExpr):\n\n    Assumptions:\n        [`DistributeMathExpr`][oqd_core.compiler.math.rules.DistributeMathExpr],\n        [`ProperOrderMathExpr`][oqd_core.compiler.math.rules.ProperOrderMathExpr]\n\n    Example:\n        - MathStr(string = '1 + 1j + 2') =&gt; MathStr(string = '1 + 2 + 1j')\n        - MathStr(string = '1 * 1j * 2') =&gt; MathStr(string = '1j * 1 * 2')\n    \"\"\"\n\n    def map_MathAdd(self, model):\n        if not (\n            isinstance(model.expr2, MathImag)\n            or (\n                isinstance(model.expr2, MathMul)\n                and isinstance(model.expr2.expr1, MathImag)\n            )\n            or isinstance(model.expr2, MathAdd)\n        ):\n            return MathAdd(expr1=model.expr2, expr2=model.expr1)\n\n    def map_MathMul(self, model: MathMul):\n        priority = dict(MathImag=4, MathNum=3, MathVar=2, MathFunc=1, MathPow=0)\n\n        if isinstance(model.expr2, (MathImag, MathNum, MathVar, MathFunc, MathPow)):\n            if isinstance(model.expr1, MathMul):\n                if (\n                    priority[model.expr2.__class__.__name__]\n                    &gt; priority[model.expr1.expr2.__class__.__name__]\n                ):\n                    return MathMul(\n                        expr1=MathMul(expr1=model.expr1.expr1, expr2=model.expr2),\n                        expr2=model.expr1.expr2,\n                    )\n            else:\n                if (\n                    priority[model.expr2.__class__.__name__]\n                    &gt; priority[model.expr1.__class__.__name__]\n                ):\n                    return MathMul(\n                        expr1=model.expr2,\n                        expr2=model.expr1,\n                    )\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules.ProperOrderMathExpr","title":"<code>ProperOrderMathExpr</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>This rearranges bracketing of <code>MathExpr</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>MathExpr</code> <p>The rule only acts on <code>MathExpr</code> objects.</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>MathExpr</code> Assumptions <p><code>DistributeMathExpr</code></p> Example <ul> <li>MathStr(string = '2 * (3 * 5)') =&gt; MathStr(string = '(2 * 3) * 5')</li> </ul> Source code in <code>oqd-core/src/oqd_core/compiler/math/rules.py</code> <pre><code>class ProperOrderMathExpr(RewriteRule):\n    \"\"\"\n    This rearranges bracketing of [`MathExpr`][oqd_core.interface.math.MathExpr] objects.\n\n    Args:\n        model (MathExpr): The rule only acts on [`MathExpr`][oqd_core.interface.math.MathExpr] objects.\n\n    Returns:\n        model (MathExpr):\n\n    Assumptions:\n        [`DistributeMathExpr`][oqd_core.compiler.math.rules.DistributeMathExpr]\n\n    Example:\n        - MathStr(string = '2 * (3 * 5)') =&gt; MathStr(string = '(2 * 3) * 5')\n    \"\"\"\n\n    def map_MathAdd(self, model: MathAdd):\n        return self._MathAddMul(model)\n\n    def map_MathMul(self, model: MathMul):\n        return self._MathAddMul(model)\n\n    def _MathAddMul(self, model: Union[MathAdd, MathMul]):\n        if isinstance(model.expr2, model.__class__):\n            return model.__class__(\n                expr1=model.__class__(expr1=model.expr1, expr2=model.expr2.expr1),\n                expr2=model.expr2.expr2,\n            )\n        pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules.PruneMathExpr","title":"<code>PruneMathExpr</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>This is constant fold operation where scalar addition, multiplication and power are simplified</p> Source code in <code>oqd-core/src/oqd_core/compiler/math/rules.py</code> <pre><code>class PruneMathExpr(RewriteRule):\n    \"\"\"\n    This is constant fold operation where scalar addition, multiplication and power are simplified\n    \"\"\"\n\n    def map_MathAdd(self, model):\n        if model.expr1 == MathNum(value=0):\n            return model.expr2\n        if model.expr2 == MathNum(value=0):\n            return model.expr1\n\n    def map_MathMul(self, model):\n        if model.expr1 == MathNum(value=1):\n            return model.expr2\n        if model.expr2 == MathNum(value=1):\n            return model.expr1\n\n        if model.expr1 == MathNum(value=0) or model.expr2 == MathNum(value=0):\n            return MathNum(value=0)\n\n    def map_MathPow(self, model):\n        if model.expr1 == MathNum(value=1) or model.expr2 == MathNum(value=1):\n            return model.expr1\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules.SimplifyMathExpr","title":"<code>SimplifyMathExpr</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>This simplified MathExpr objects</p> Source code in <code>oqd-core/src/oqd_core/compiler/math/rules.py</code> <pre><code>class SimplifyMathExpr(RewriteRule):\n    \"\"\"\n    This simplified MathExpr objects\n    \"\"\"\n\n    def map_MathAdd(self, model):\n        if isinstance(model.expr1, MathNum) and isinstance(model.expr2, MathNum):\n            return MathNum(value=model.expr1.value + model.expr2.value)\n\n    def map_MathMul(self, model):\n        if isinstance(model.expr1, MathNum) and isinstance(model.expr2, MathNum):\n            return MathNum(value=model.expr1.value * model.expr2.value)\n\n    def map_MathPow(self, model):\n        if isinstance(model.expr1, MathNum) and isinstance(model.expr2, MathNum):\n            return MathNum(value=model.expr1.value**model.expr2.value)\n\n    def map_MathFunc(self, model):\n        if isinstance(model.expr, MathNum):\n            if getattr(math, model.func, None):\n                value = getattr(math, model.func)(model.expr.value)\n\n            if model.func == \"heaviside\":\n                value = np.heaviside(model.expr.value, 1)\n\n            if model.func == \"conj\":\n                value = np.conj(model.expr.value)\n            return MathNum(value=value)\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_compiler.html#oqd_core.compiler.math.rules.EvaluateMathExpr","title":"<code>EvaluateMathExpr</code>","text":"<p>               Bases: <code>ConversionRule</code></p> <p>This evalaluates MathExpr objects</p> Source code in <code>oqd-core/src/oqd_core/compiler/math/rules.py</code> <pre><code>class EvaluateMathExpr(ConversionRule):\n    \"\"\"\n    This evalaluates MathExpr objects\n    \"\"\"\n\n    def map_MathVar(self, model: MathVar, operands):\n        raise TypeError\n\n    def map_MathNum(self, model: MathNum, operands):\n        return model.value\n\n    def map_MathImag(self, model: MathImag, operands):\n        return complex(\"1j\")\n\n    def map_MathFunc(self, model: MathFunc, operands):\n        if getattr(math, model.func, None):\n            return getattr(math, model.func)(operands[\"expr\"])\n\n        if model.func == \"heaviside\":\n            return np.heaviside(operands[\"expr\"], 1)\n\n        if model.func == \"conj\":\n            return np.conj(operands[\"expr\"])\n\n    def map_MathAdd(self, model: MathAdd, operands):\n        return operands[\"expr1\"] + operands[\"expr2\"]\n\n    def map_MathSub(self, model: MathSub, operands):\n        return operands[\"expr1\"] - operands[\"expr2\"]\n\n    def map_MathMul(self, model: MathMul, operands):\n        return operands[\"expr1\"] * operands[\"expr2\"]\n\n    def map_MathDiv(self, model: MathDiv, operands):\n        return operands[\"expr1\"] / operands[\"expr2\"]\n\n    def map_MathPow(self, model: MathPow, operands):\n        return operands[\"expr1\"] ** operands[\"expr2\"]\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html","title":"Math","text":""},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math","title":"<code>oqd_core.interface.math</code>","text":""},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathExprSubtypes","title":"<code>MathExprSubtypes = Union[MathNum, MathVar, MathImag, MathFunc, MathAdd, MathSub, MathMul, MathDiv, MathPow]</code>  <code>module-attribute</code>","text":"<p>Alias for the union of concrete MathExpr subtypes</p>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathExpr","title":"<code>MathExpr</code>","text":"<p>               Bases: <code>TypeReflectBaseModel</code></p> <p>Class representing the abstract syntax tree (AST) for a mathematical expression</p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathExpr(TypeReflectBaseModel):\n    \"\"\"\n    Class representing the abstract syntax tree (AST) for a mathematical expression\n    \"\"\"\n\n    @classmethod\n    def cast(cls, value: Any):\n        if isinstance(value, dict):\n            return value\n        if isinstance(value, MathExpr):\n            return value\n        if isinstance(value, (int, float)):\n            value = MathNum(value=value)\n            return value\n        if isinstance(value, (complex, np.complex128)):\n            value = MathNum(value=value.real) + MathImag() * value.imag\n            return value\n        if isinstance(value, str):\n            raise TypeError(\n                \"Tried to cast a string to MathExpr. \"\n                + f'Wrap your string (\"{value}\") with MathStr(string=\"{value}\").'\n            )\n        raise TypeError\n\n    def __neg__(self):\n        return MathMul(expr1=MathNum(value=-1), expr2=self)\n\n    def __pos__(self):\n        return self\n\n    def __add__(self, other):\n        return MathAdd(expr1=self, expr2=other)\n\n    def __sub__(self, other):\n        return MathSub(expr1=self, expr2=other)\n\n    def __mul__(self, other):\n        try:\n            return MathMul(expr1=self, expr2=other)\n        except TypeError:  # make sure this is the right error to catch\n            return other * self\n\n    def __truediv__(self, other):\n        return MathDiv(expr1=self, expr2=other)\n\n    def __pow__(self, other):\n        return MathPow(expr1=self, expr2=other)\n\n    def __radd__(self, other):\n        other = MathExpr.cast(other)\n        return other + self\n\n    def __rsub__(self, other):\n        other = MathExpr.cast(other)\n        return other - self\n\n    def __rmul__(self, other):\n        other = MathExpr.cast(other)\n        return other * self\n\n    def __rpow__(self, other):\n        other = MathExpr.cast(other)\n        return other**self\n\n    def __rtruediv__(self, other):\n        other = MathExpr.cast(other)\n        return other / self\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathTerminal","title":"<code>MathTerminal</code>","text":"<p>               Bases: <code>MathExpr</code></p> <p>Class representing a terminal in the <code>MathExpr</code> abstract syntax tree (AST)</p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathTerminal(MathExpr):\n    \"\"\"\n    Class representing a terminal in the [`MathExpr`][oqd_core.interface.math.MathExpr] abstract syntax tree (AST)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathVar","title":"<code>MathVar</code>","text":"<p>               Bases: <code>MathTerminal</code></p> <p>Class representing a variable in a <code>MathExpr</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MathVar(\"t\")\n</code></pre> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathVar(MathTerminal):\n    \"\"\"\n    Class representing a variable in a [`MathExpr`][oqd_core.interface.math.MathExpr]\n\n    Examples:\n        &gt;&gt;&gt; MathVar(\"t\")\n\n    \"\"\"\n\n    name: VarName\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathNum","title":"<code>MathNum</code>","text":"<p>               Bases: <code>MathTerminal</code></p> <p>Class representing a number in a <code>MathExpr</code></p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathNum(MathTerminal):\n    \"\"\"\n    Class representing a number in a [`MathExpr`][oqd_core.interface.math.MathExpr]\n    \"\"\"\n\n    value: Union[int, float]\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathImag","title":"<code>MathImag</code>","text":"<p>               Bases: <code>MathTerminal</code></p> <p>Class representing the imaginary unit in a <code>MathExpr</code> abstract syntax tree (AST)</p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathImag(MathTerminal):\n    \"\"\"\n    Class representing the imaginary unit in a [`MathExpr`][oqd_core.interface.math.MathExpr] abstract syntax tree (AST)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathUnaryOp","title":"<code>MathUnaryOp</code>","text":"<p>               Bases: <code>MathExpr</code></p> <p>Class representing a unary operations on a <code>MathExpr</code> abstract syntax tree (AST)</p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathUnaryOp(MathExpr):\n    \"\"\"\n    Class representing a unary operations on a [`MathExpr`][oqd_core.interface.math.MathExpr] abstract syntax tree (AST)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathFunc","title":"<code>MathFunc</code>","text":"<p>               Bases: <code>MathUnaryOp</code></p> <p>Class representing a named function applied to a <code>MathExpr</code> abstract syntax tree (AST)</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>Literal['sin', 'cos', 'tan', 'exp', 'log', 'sinh', 'cosh', 'tanh']</code> <p>Named function to apply</p> <code>expr</code> <code>MathExpr</code> <p>Argument of the named function</p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathFunc(MathUnaryOp):\n    \"\"\"\n    Class representing a named function applied to a [`MathExpr`][oqd_core.interface.math.MathExpr] abstract syntax tree (AST)\n\n    Attributes:\n        func (Literal[\"sin\", \"cos\", \"tan\", \"exp\", \"log\", \"sinh\", \"cosh\", \"tanh\"]): Named function to apply\n        expr (MathExpr): Argument of the named function\n    \"\"\"\n\n    func: Functions\n    expr: CastMathExpr\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathBinaryOp","title":"<code>MathBinaryOp</code>","text":"<p>               Bases: <code>MathExpr</code></p> <p>Class representing binary operations on <code>MathExprs</code> abstract syntax tree (AST)</p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathBinaryOp(MathExpr):\n    \"\"\"\n    Class representing binary operations on [`MathExprs`][oqd_core.interface.math.MathExpr] abstract syntax tree (AST)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathAdd","title":"<code>MathAdd</code>","text":"<p>               Bases: <code>MathBinaryOp</code></p> <p>Class representing the addition of <code>MathExprs</code></p> <p>Attributes:</p> Name Type Description <code>expr1</code> <code>MathExpr</code> <p>Left hand side <code>MathExpr</code></p> <code>expr2</code> <code>MathExpr</code> <p>Right hand side <code>MathExpr</code></p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathAdd(MathBinaryOp):\n    \"\"\"\n    Class representing the addition of [`MathExprs`][oqd_core.interface.analog.operator.Operator]\n\n    Attributes:\n        expr1 (MathExpr): Left hand side [`MathExpr`][oqd_core.interface.analog.operator.Operator]\n        expr2 (MathExpr): Right hand side [`MathExpr`][oqd_core.interface.analog.operator.Operator]\n    \"\"\"\n\n    expr1: CastMathExpr\n    expr2: CastMathExpr\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathSub","title":"<code>MathSub</code>","text":"<p>               Bases: <code>MathBinaryOp</code></p> <p>Class representing the subtraction of <code>MathExprs</code></p> <p>Attributes:</p> Name Type Description <code>expr1</code> <code>MathExpr</code> <p>Left hand side <code>MathExpr</code></p> <code>expr2</code> <code>MathExpr</code> <p>Right hand side <code>MathExpr</code></p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathSub(MathBinaryOp):\n    \"\"\"\n    Class representing the subtraction of [`MathExprs`][oqd_core.interface.math.MathExpr]\n\n    Attributes:\n        expr1 (MathExpr): Left hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n        expr2 (MathExpr): Right hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n    \"\"\"\n\n    expr1: CastMathExpr\n    expr2: CastMathExpr\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathMul","title":"<code>MathMul</code>","text":"<p>               Bases: <code>MathBinaryOp</code></p> <p>Class representing the multiplication of <code>MathExprs</code></p> <p>Attributes:</p> Name Type Description <code>expr1</code> <code>MathExpr</code> <p>Left hand side <code>MathExpr</code></p> <code>expr2</code> <code>MathExpr</code> <p>Right hand side <code>MathExpr</code></p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathMul(MathBinaryOp):\n    \"\"\"\n    Class representing the multiplication of [`MathExprs`][oqd_core.interface.math.MathExpr]\n\n    Attributes:\n        expr1 (MathExpr): Left hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n        expr2 (MathExpr): Right hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n    \"\"\"\n\n    expr1: CastMathExpr\n    expr2: CastMathExpr\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathDiv","title":"<code>MathDiv</code>","text":"<p>               Bases: <code>MathBinaryOp</code></p> <p>Class representing the division of <code>MathExprs</code></p> <p>Attributes:</p> Name Type Description <code>expr1</code> <code>MathExpr</code> <p>Left hand side <code>MathExpr</code></p> <code>expr2</code> <code>MathExpr</code> <p>Right hand side <code>MathExpr</code></p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathDiv(MathBinaryOp):\n    \"\"\"\n    Class representing the division of [`MathExprs`][oqd_core.interface.math.MathExpr]\n\n    Attributes:\n        expr1 (MathExpr): Left hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n        expr2 (MathExpr): Right hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n    \"\"\"\n\n    expr1: CastMathExpr\n    expr2: CastMathExpr\n</code></pre>"},{"location":"open-quantum-design-core/reference/math_interface.html#oqd_core.interface.math.MathPow","title":"<code>MathPow</code>","text":"<p>               Bases: <code>MathBinaryOp</code></p> <p>Class representing the exponentiation of <code>MathExprs</code></p> <p>Attributes:</p> Name Type Description <code>expr1</code> <code>MathExpr</code> <p>Left hand side <code>MathExpr</code></p> <code>expr2</code> <code>MathExpr</code> <p>Right hand side <code>MathExpr</code></p> Source code in <code>oqd-core/src/oqd_core/interface/math.py</code> <pre><code>class MathPow(MathBinaryOp):\n    \"\"\"\n    Class representing the exponentiation of [`MathExprs`][oqd_core.interface.math.MathExpr]\n\n    Attributes:\n        expr1 (MathExpr): Left hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n        expr2 (MathExpr): Right hand side [`MathExpr`][oqd_core.interface.math.MathExpr]\n    \"\"\"\n\n    expr1: CastMathExpr\n    expr2: CastMathExpr\n</code></pre>"},{"location":"tutorials/index.html","title":"Analog Tutorials","text":"<p>Here you will find some tutorials on using the analog interface for defining and running quantum programs.</p>"},{"location":"tutorials/ising.html","title":"Transverse field Ising model","text":"<p>Next, let's implement everyone's favourite many-body Hamiltonian -- the transverse-field Ising model. The Hamiltonian is of the form,</p> \\[ H = \\sum_{\\langle ij \\rangle} \\sigma^x_i \\sigma^x_j + h \\sum_i \\sigma^z_i \\] <p>We will first implement this for two qubits only, and then expand to a larger system size. Throughout, we will use a transverse field strength of \\(h=1\\),</p> \\[ H = \\sigma^x_1 \\sigma^x_2 + \\sigma^z_1 + \\sigma^z_2 \\]"},{"location":"tutorials/ising.html#building-the-quantum-program","title":"Building the quantum program","text":"<p>First we import the relevant modules,</p> Imports <pre><code>import numpy as np\n\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliZ, PauliY\nfrom oqd_core.interface.analog.operation import *\nfrom oqd_core.backend.metric import *\nfrom oqd_core.backend.task import Task\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\n</code></pre> <p>As before, we can describe the Hamiltonian using the operators in the analog layer interface. <pre><code>X, Z, I = PauliX(), PauliZ(), PauliI()\n\nhamiltonian = (X @ X) + (Z @ I) + (I @ Z)\ngate = AnalogGate(hamiltonian=hamiltonian)\n\ncircuit = AnalogCircuit()\ncircuit.evolve(duration=5, gate=gate)\ncircuit.measure()\n</code></pre></p> <p>To generalize this to <code>n</code> qubits, we can use built-in Python operations and libraries, <pre><code>import functools\nfrom operator import matmul, add\n\nX, Z, I = PauliX(), PauliZ(), PauliI()\n\nn = 5\n\nhamiltonian_xx = functools.reduce(\n    add, [functools.reduce(matmul, [X if i in (j, (j+1)%n) else I for i in range(n)]) for j in range(n)]\n)\nhamiltonian_z = functools.reduce(\n    add, [functools.reduce(matmul, [Z if i==j else I for i in range(n)]) for j in range(n)]\n)\ngate = AnalogGate(hamiltonian=hamiltonian_xx + hamiltonian_z)\n\ncircuit = AnalogCircuit()\ncircuit.evolve(duration=5, gate=gate)\ncircuit.measure()\n</code></pre></p>"},{"location":"tutorials/ising.html#setting-up-and-running-the-classical-emulation","title":"Setting up and running the classical emulation","text":"<p>Similarly, we set up the settings for the classical emulation backend, including the number of shots and metrics (e.g., expectation values, entropy of entanglement) which we want to track through the time evolution.</p> <pre><code>args = TaskArgsAnalog(\n    n_shots=100,\n    metrics={\n        'entanglement_entropy': EntanglementEntropyVN(qreg = [1]),\n    },\n    dt=1e-2,\n)\n\nbackend = QutipBackend()\nresults = backend.run(task = task)\n</code></pre>"},{"location":"tutorials/rabi-flopping.html","title":"Single qubit Rabi flopping","text":"<p>First, let's implement a single-qubit Rabi flopping experiment. Here, a two-level system, initialized in the \\(\\ket{0}\\) basis state, oscillates between \\(\\ket{0}\\) and \\(\\ket{1}\\) during evolution. The Hamiltonian under which the state evolves is, $$ H = -\\frac{\\pi}{4}\\sigma^x $$</p>"},{"location":"tutorials/rabi-flopping.html#building-the-quantum-program","title":"Building the quantum program","text":"<p>We will go through how to specify this quantum program using OQD's analog interface. First import the relevant modules,</p> Imports <pre><code>import numpy as np\n\nfrom oqd_core.interface.analog.operator import PauliI, PauliX, PauliZ, PauliY\nfrom oqd_core.interface.analog.operation import *\nfrom oqd_core.backend.metric import *\nfrom oqd_core.backend.task import Task\nfrom oqd_analog_emulator.qutip_backend import QutipBackend\n</code></pre> <p>Then we construct an <code>AnalogGate</code> object, <pre><code>X = PauliX()\ngate = AnalogGate(hamiltonian= -(np.pi / 4) * X)\n</code></pre></p> <p>The <code>AnalogCircuit</code> represents a sequence of Hamiltonians which the quantum system evolves under for a fixed duration. Let's construct a circuit and add the gate from above and then measure, <pre><code>circuit = AnalogCircuit()\ncircuit.evolve(duration=3, gate=gate)\ncircuit.measure()\n</code></pre></p>"},{"location":"tutorials/rabi-flopping.html#setting-up-the-backend","title":"Setting up the backend","text":"<p>Now, let's emulate the time dynamics of our quantum system. We use one of the provided backends, here the <code>QutipBackend</code>, to solve the evolution of the quantum state through the circuit. We first initialize the backend and a [<code>TaskArgsAnalog</code>][oqd_core.backend.task.TaskArgsAnalog] object with the settings for the emulation, such as the number of shots, the metrics to track through the evolution (e.g., an expectation value), and the time step. <pre><code>backend = QutipBackend()\nargs = TaskArgsAnalog(\n    n_shots=100,\n    metrics={\n        \"Z\": Expectation(operator=Z),\n    },\n    dt=1e-3,\n)\n</code></pre></p>"},{"location":"tutorials/rabi-flopping.html#running-the-backend-emulation","title":"Running the backend emulation","text":"<p>Now, we simply use the <code>.run()</code> method of the backend to run the emulation of the time dynamics of the circuit. <pre><code>results = backend.run(task = task)\n</code></pre></p>"}]}